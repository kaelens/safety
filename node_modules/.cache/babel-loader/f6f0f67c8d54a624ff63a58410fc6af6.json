{"ast":null,"code":"var QRCode = require('./../vendor/QRCode'),\n    QRErrorCorrectLevel = require('./../vendor/QRCode/QRErrorCorrectLevel'),\n    black = \"\\033[40m  \\033[0m\",\n    white = \"\\033[47m  \\033[0m\",\n    toCell = function (isBlack) {\n  return isBlack ? black : white;\n},\n    repeat = function (color) {\n  return {\n    times: function (count) {\n      return new Array(count).join(color);\n    }\n  };\n},\n    fill = function (length, value) {\n  var arr = new Array(length);\n\n  for (var i = 0; i < length; i++) {\n    arr[i] = value;\n  }\n\n  return arr;\n};\n\nmodule.exports = {\n  error: QRErrorCorrectLevel.L,\n  generate: function (input, opts, cb) {\n    if (typeof opts === 'function') {\n      cb = opts;\n      opts = {};\n    }\n\n    var qrcode = new QRCode(-1, this.error);\n    qrcode.addData(input);\n    qrcode.make();\n    var output = '';\n\n    if (opts && opts.small) {\n      var BLACK = true,\n          WHITE = false;\n      var moduleCount = qrcode.getModuleCount();\n      var moduleData = qrcode.modules.slice();\n      var oddRow = moduleCount % 2 === 1;\n\n      if (oddRow) {\n        moduleData.push(fill(moduleCount, WHITE));\n      }\n\n      var platte = {\n        WHITE_ALL: '\\u2588',\n        WHITE_BLACK: '\\u2580',\n        BLACK_WHITE: '\\u2584',\n        BLACK_ALL: ' '\n      };\n      var borderTop = repeat(platte.BLACK_WHITE).times(moduleCount + 3);\n      var borderBottom = repeat(platte.WHITE_BLACK).times(moduleCount + 3);\n      output += borderTop + '\\n';\n\n      for (var row = 0; row < moduleCount; row += 2) {\n        output += platte.WHITE_ALL;\n\n        for (var col = 0; col < moduleCount; col++) {\n          if (moduleData[row][col] === WHITE && moduleData[row + 1][col] === WHITE) {\n            output += platte.WHITE_ALL;\n          } else if (moduleData[row][col] === WHITE && moduleData[row + 1][col] === BLACK) {\n            output += platte.WHITE_BLACK;\n          } else if (moduleData[row][col] === BLACK && moduleData[row + 1][col] === WHITE) {\n            output += platte.BLACK_WHITE;\n          } else {\n            output += platte.BLACK_ALL;\n          }\n        }\n\n        output += platte.WHITE_ALL + '\\n';\n      }\n\n      if (!oddRow) {\n        output += borderBottom;\n      }\n    } else {\n      var border = repeat(white).times(qrcode.getModuleCount() + 3);\n      output += border + '\\n';\n      qrcode.modules.forEach(function (row) {\n        output += white;\n        output += row.map(toCell).join('');\n        output += white + '\\n';\n      });\n      output += border;\n    }\n\n    if (cb) cb(output);else console.log(output);\n  },\n  setErrorLevel: function (error) {\n    this.error = QRErrorCorrectLevel[error] || this.error;\n  }\n};","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/qrcode-terminal/lib/main.js"],"names":["QRCode","require","QRErrorCorrectLevel","black","white","toCell","isBlack","repeat","color","times","count","Array","join","fill","length","value","arr","i","module","exports","error","L","generate","input","opts","cb","qrcode","addData","make","output","small","BLACK","WHITE","moduleCount","getModuleCount","moduleData","modules","slice","oddRow","push","platte","WHITE_ALL","WHITE_BLACK","BLACK_WHITE","BLACK_ALL","borderTop","borderBottom","row","col","border","forEach","map","console","log","setErrorLevel"],"mappings":"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","sourcesContent":["var QRCode = require('./../vendor/QRCode'),\n    QRErrorCorrectLevel = require('./../vendor/QRCode/QRErrorCorrectLevel'),\n    black = \"\\033[40m  \\033[0m\",\n    white = \"\\033[47m  \\033[0m\",\n    toCell = function (isBlack) {\n        return isBlack ? black : white;\n    },\n    repeat = function (color) {\n        return {\n            times: function (count) {\n                return new Array(count).join(color);\n            }\n        };\n    },\n    fill = function(length, value) {\n        var arr = new Array(length);\n        for (var i = 0; i < length; i++) {\n            arr[i] = value;\n        }\n        return arr;\n    };\n\nmodule.exports = {\n\n    error: QRErrorCorrectLevel.L,\n\n    generate: function (input, opts, cb) {\n        if (typeof opts === 'function') {\n            cb = opts;\n            opts = {};\n        }\n\n        var qrcode = new QRCode(-1, this.error);\n        qrcode.addData(input);\n        qrcode.make();\n\n        var output = '';\n        if (opts && opts.small) {\n            var BLACK = true, WHITE = false;\n            var moduleCount = qrcode.getModuleCount();\n            var moduleData = qrcode.modules.slice();\n\n            var oddRow = moduleCount % 2 === 1;\n            if (oddRow) {\n                moduleData.push(fill(moduleCount, WHITE));\n            }\n\n            var platte= {\n                WHITE_ALL: '\\u2588',\n                WHITE_BLACK: '\\u2580',\n                BLACK_WHITE: '\\u2584',\n                BLACK_ALL: ' ',\n            };\n\n            var borderTop = repeat(platte.BLACK_WHITE).times(moduleCount + 3);\n            var borderBottom = repeat(platte.WHITE_BLACK).times(moduleCount + 3);\n            output += borderTop + '\\n';\n\n            for (var row = 0; row < moduleCount; row += 2) {\n                output += platte.WHITE_ALL;\n\n                for (var col = 0; col < moduleCount; col++) {\n                    if (moduleData[row][col] === WHITE && moduleData[row + 1][col] === WHITE) {\n                        output += platte.WHITE_ALL;\n                    } else if (moduleData[row][col] === WHITE && moduleData[row + 1][col] === BLACK) {\n                        output += platte.WHITE_BLACK;\n                    } else if (moduleData[row][col] === BLACK && moduleData[row + 1][col] === WHITE) {\n                        output += platte.BLACK_WHITE;\n                    } else {\n                        output += platte.BLACK_ALL;\n                    }\n                }\n\n                output += platte.WHITE_ALL + '\\n';\n            }\n\n            if (!oddRow) {\n                output += borderBottom;\n            }\n        } else {\n            var border = repeat(white).times(qrcode.getModuleCount() + 3);\n\n            output += border + '\\n';\n            qrcode.modules.forEach(function (row) {\n                output += white;\n                output += row.map(toCell).join(''); \n                output += white + '\\n';\n            });\n            output += border;\n        }\n\n        if (cb) cb(output);\n        else console.log(output);\n    },\n\n    setErrorLevel: function (error) {\n        this.error = QRErrorCorrectLevel[error] || this.error;\n    }\n\n};\n"]},"metadata":{},"sourceType":"script"}