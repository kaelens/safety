{"ast":null,"code":"// This is the base class that the other fetcher types in lib\n// all descend from.\n// It handles the unpacking and retry logic that is shared among\n// all of the other Fetcher types.\nconst npa = require('npm-package-arg');\n\nconst ssri = require('ssri');\n\nconst {\n  promisify\n} = require('util');\n\nconst {\n  basename,\n  dirname\n} = require('path');\n\nconst rimraf = promisify(require('rimraf'));\n\nconst tar = require('tar');\n\nconst procLog = require('./util/proc-log.js');\n\nconst retry = require('promise-retry');\n\nconst fsm = require('fs-minipass');\n\nconst cacache = require('cacache');\n\nconst isPackageBin = require('./util/is-package-bin.js');\n\nconst getContents = require('@npmcli/installed-package-contents'); // we only change ownership on unix platforms, and only if uid is 0\n\n\nconst selfOwner = process.getuid && process.getuid() === 0 ? {\n  uid: 0,\n  gid: process.getgid()\n} : null;\nconst chownr = selfOwner ? promisify(require('chownr')) : null;\nconst inferOwner = selfOwner ? require('infer-owner') : null;\n\nconst mkdirp = require('mkdirp');\n\nconst cacheDir = require('./util/cache-dir.js'); // Private methods.\n// Child classes should not have to override these.\n// Users should never call them.\n\n\nconst _chown = Symbol('_chown');\n\nconst _extract = Symbol('_extract');\n\nconst _mkdir = Symbol('_mkdir');\n\nconst _empty = Symbol('_empty');\n\nconst _toFile = Symbol('_toFile');\n\nconst _tarxOptions = Symbol('_tarxOptions');\n\nconst _entryMode = Symbol('_entryMode');\n\nconst _istream = Symbol('_istream');\n\nconst _assertType = Symbol('_assertType');\n\nconst _tarballFromCache = Symbol('_tarballFromCache');\n\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\n\nclass FetcherBase {\n  constructor(spec, opts) {\n    if (!opts || typeof opts !== 'object') throw new TypeError('options object is required');\n    this.spec = npa(spec, opts.where);\n    this.allowGitIgnore = !!opts.allowGitIgnore; // a bit redundant because presumably the caller already knows this,\n    // but it makes it easier to not have to keep track of the requested\n    // spec when we're dispatching thousands of these at once, and normalizing\n    // is nice.  saveSpec is preferred if set, because it turns stuff like\n    // x/y#committish into github:x/y#committish.  use name@rawSpec for\n    // registry deps so that we turn xyz and xyz@ -> xyz@\n\n    this.from = this.spec.registry ? `${this.spec.name}@${this.spec.rawSpec}` : this.spec.saveSpec;\n\n    this[_assertType](); // clone the opts object so that others aren't upset when we mutate it\n    // by adding/modifying the integrity value.\n\n\n    this.opts = { ...opts\n    };\n    this.cache = opts.cache || cacheDir();\n    this.resolved = opts.resolved || null; // default to caching/verifying with sha512, that's what we usually have\n    // need to change this default, or start overriding it, when sha512\n    // is no longer strong enough.\n\n    this.defaultIntegrityAlgorithm = opts.defaultIntegrityAlgorithm || 'sha512';\n    if (typeof opts.integrity === 'string') this.opts.integrity = ssri.parse(opts.integrity);\n    this.package = null;\n    this.type = this.constructor.name;\n    this.fmode = opts.fmode || 0o666;\n    this.dmode = opts.dmode || 0o777; // we don't need a default umask, because we don't chmod files coming\n    // out of package tarballs.  they're forced to have a mode that is\n    // valid, regardless of what's in the tarball entry, and then we let\n    // the process's umask setting do its job.  but if configured, we do\n    // respect it.\n\n    this.umask = opts.umask || 0;\n    this.log = opts.log || procLog;\n    this.preferOnline = !!opts.preferOnline;\n    this.preferOffline = !!opts.preferOffline;\n    this.offline = !!opts.offline;\n    this.before = opts.before;\n    this.fullMetadata = this.before ? true : !!opts.fullMetadata;\n    this.defaultTag = opts.defaultTag || 'latest';\n    this.registry = (opts.registry || 'https://registry.npmjs.org').replace(/\\/+$/, ''); // command to run 'prepare' scripts on directories and git dirs\n    // To use pacote with yarn, for example, set npmBin to 'yarn'\n    // and npmCliConfig with yarn's equivalents.\n\n    this.npmBin = opts.npmBin || 'npm'; // command to install deps for preparing\n\n    this.npmInstallCmd = opts.npmInstallCmd || ['install', '--force']; // XXX fill more of this in based on what we know from this.opts\n    // we explicitly DO NOT fill in --tag, though, since we are often\n    // going to be packing in the context of a publish, which may set\n    // a dist-tag, but certainly wants to keep defaulting to latest.\n\n    this.npmCliConfig = opts.npmCliConfig || [`--cache=${dirname(this.cache)}`, `--prefer-offline=${!!this.preferOffline}`, `--prefer-online=${!!this.preferOnline}`, `--offline=${!!this.offline}`, ...(this.before ? [`--before=${this.before.toISOString()}`] : []), '--no-progress', '--no-save', '--no-audit'];\n  }\n\n  get integrity() {\n    return this.opts.integrity || null;\n  }\n\n  set integrity(i) {\n    if (!i) return;\n    i = ssri.parse(i);\n    const current = this.opts.integrity; // do not ever update an existing hash value, but do\n    // merge in NEW algos and hashes that we don't already have.\n\n    if (current) current.merge(i);else this.opts.integrity = i;\n  }\n\n  get notImplementedError() {\n    return new Error('not implemented in this fetcher type: ' + this.type);\n  } // override in child classes\n  // Returns a Promise that resolves to this.resolved string value\n\n\n  resolve() {\n    return this.resolved ? Promise.resolve(this.resolved) : Promise.reject(this.notImplementedError);\n  }\n\n  packument() {\n    return Promise.reject(this.notImplementedError);\n  } // override in child class\n  // returns a manifest containing:\n  // - name\n  // - version\n  // - _resolved\n  // - _integrity\n  // - plus whatever else was in there (corgi, full metadata, or pj file)\n\n\n  manifest() {\n    return Promise.reject(this.notImplementedError);\n  } // private, should be overridden.\n  // Note that they should *not* calculate or check integrity, but *just*\n  // return the raw tarball data stream.\n\n\n  [_tarballFromResolved]() {\n    throw this.notImplementedError;\n  } // public, should not be overridden\n\n\n  tarball() {\n    return this.tarballStream(stream => new Promise((res, rej) => {\n      const buf = [];\n      stream.on('error', er => rej(er));\n      stream.on('end', () => {\n        const data = Buffer.concat(buf);\n        data.integrity = this.integrity && String(this.integrity);\n        data.resolved = this.resolved;\n        data.from = this.from;\n        return res(data);\n      });\n      stream.on('data', d => buf.push(d));\n    }));\n  } // private\n  // Note: cacache will raise a EINTEGRITY error if the integrity doesn't match\n\n\n  [_tarballFromCache]() {\n    return cacache.get.stream.byDigest(this.cache, this.integrity, this.opts);\n  }\n\n  [_istream](stream) {\n    // everyone will need one of these, either for verifying or calculating\n    // We always set it, because we have might only have a weak legacy hex\n    // sha1 in the packument, and this MAY upgrade it to a stronger algo.\n    // If we had an integrity, and it doesn't match, then this does not\n    // override that error; the istream will raise the error before it\n    // gets to the point of re-setting the integrity.\n    const istream = ssri.integrityStream(this.opts);\n    istream.on('integrity', i => this.integrity = i);\n    return stream.on('error', er => istream.emit('error', er)).pipe(istream);\n  }\n\n  pickIntegrityAlgorithm() {\n    return this.integrity ? this.integrity.pickAlgorithm(this.opts) : this.defaultIntegrityAlgorithm;\n  } // TODO: check error class, once those are rolled out to our deps\n\n\n  isDataCorruptionError(er) {\n    return er.code === 'EINTEGRITY' || er.code === 'Z_DATA_ERROR';\n  } // override the types getter\n\n\n  get types() {}\n\n  [_assertType]() {\n    if (this.types && !this.types.includes(this.spec.type)) {\n      throw new TypeError(`Wrong spec type (${this.spec.type}) for ${this.constructor.name}. Supported types: ${this.types.join(', ')}`);\n    }\n  } // We allow ENOENTs from cacache, but not anywhere else.\n  // An ENOENT trying to read a tgz file, for example, is Right Out.\n\n\n  isRetriableError(er) {\n    // TODO: check error class, once those are rolled out to our deps\n    return this.isDataCorruptionError(er) || er.code === 'ENOENT';\n  } // Mostly internal, but has some uses\n  // Pass in a function which returns a promise\n  // Function will be called 1 or more times with streams that may fail.\n  // Retries:\n  // Function MUST handle errors on the stream by rejecting the promise,\n  // so that retry logic can pick it up and either retry or fail whatever\n  // promise it was making (ie, failing extraction, etc.)\n  //\n  // The return value of this method is a Promise that resolves the same\n  // as whatever the streamHandler resolves to.\n  //\n  // This should never be overridden by child classes, but it is public.\n\n\n  tarballStream(streamHandler) {\n    // Only short-circuit via cache if we have everything else we'll need,\n    // and the user has not expressed a preference for checking online.\n    const fromCache = !this.preferOnline && this.integrity && this.resolved ? streamHandler(this[_tarballFromCache]()).catch(er => {\n      if (this.isDataCorruptionError(er)) {\n        this.log.warn('tarball', `cached data for ${this.spec} (${this.integrity}) seems to be corrupted. Refreshing cache.`);\n        return this.cleanupCached().then(() => {\n          throw er;\n        });\n      } else {\n        throw er;\n      }\n    }) : null;\n\n    const fromResolved = er => {\n      if (er) {\n        if (!this.isRetriableError(er)) throw er;\n        this.log.silly('tarball', `no local data for ${this.spec}. Extracting by manifest.`);\n      }\n\n      return this.resolve().then(() => retry(tryAgain => streamHandler(this[_istream](this[_tarballFromResolved]())).catch(er => {\n        // Most likely data integrity.  A cache ENOENT error is unlikely\n        // here, since we're definitely not reading from the cache, but it\n        // IS possible that the fetch subsystem accessed the cache, and the\n        // entry got blown away or something.  Try one more time to be sure.\n        if (this.isRetriableError(er)) {\n          this.log.warn('tarball', `tarball data for ${this.spec} (${this.integrity}) seems to be corrupted. Trying again.`);\n          return this.cleanupCached().then(() => tryAgain(er));\n        }\n\n        throw er;\n      }), {\n        retries: 1,\n        minTimeout: 0,\n        maxTimeout: 0\n      }));\n    };\n\n    return fromCache ? fromCache.catch(fromResolved) : fromResolved();\n  }\n\n  cleanupCached() {\n    return cacache.rm.content(this.cache, this.integrity, this.opts);\n  }\n\n  async [_chown](path, uid, gid) {\n    return selfOwner && (selfOwner.gid !== gid || selfOwner.uid !== uid) ? chownr(path, uid, gid) :\n    /* istanbul ignore next - we don't test in root-owned folders */\n    null;\n  }\n\n  [_empty](path) {\n    return getContents({\n      path,\n      depth: 1\n    }).then(contents => Promise.all(contents.map(entry => rimraf(entry))));\n  }\n\n  [_mkdir](dest) {\n    // if we're bothering to do owner inference, then do it.\n    // otherwise just make the dir, and return an empty object.\n    // always empty the dir dir to start with, but do so\n    // _after_ inferring the owner, in case there's an existing folder\n    // there that we would want to preserve which differs from the\n    // parent folder (rare, but probably happens sometimes).\n    return !inferOwner ? this[_empty](dest).then(() => mkdirp(dest)).then(() => ({})) : inferOwner(dest).then(({\n      uid,\n      gid\n    }) => this[_empty](dest).then(() => mkdirp(dest)).then(made => {\n      // ignore the || dest part in coverage.  It's there to handle\n      // race conditions where the dir may be made by someone else\n      // after being removed by us.\n      const dir = made ||\n      /* istanbul ignore next */\n      dest;\n      return this[_chown](dir, uid, gid);\n    }).then(() => ({\n      uid,\n      gid\n    })));\n  } // extraction is always the same.  the only difference is where\n  // the tarball comes from.\n\n\n  extract(dest) {\n    return this[_mkdir](dest).then(({\n      uid,\n      gid\n    }) => this.tarballStream(tarball => this[_extract](dest, tarball, uid, gid)));\n  }\n\n  [_toFile](dest) {\n    return this.tarballStream(str => new Promise((res, rej) => {\n      const writer = new fsm.WriteStream(dest);\n      str.on('error', er => writer.emit('error', er));\n      writer.on('error', er => rej(er));\n      writer.on('close', () => res({\n        integrity: this.integrity && String(this.integrity),\n        resolved: this.resolved,\n        from: this.from\n      }));\n      str.pipe(writer);\n    }));\n  } // don't use this[_mkdir] because we don't want to rimraf anything\n\n\n  tarballFile(dest) {\n    const dir = dirname(dest);\n    return !inferOwner ? mkdirp(dir).then(() => this[_toFile](dest)) : inferOwner(dest).then(({\n      uid,\n      gid\n    }) => mkdirp(dir).then(made => this[_toFile](dest).then(res => this[_chown](made || dir, uid, gid).then(() => res))));\n  }\n\n  [_extract](dest, tarball, uid, gid) {\n    const extractor = tar.x(this[_tarxOptions]({\n      cwd: dest,\n      uid,\n      gid\n    }));\n    const p = new Promise((resolve, reject) => {\n      extractor.on('end', () => {\n        resolve({\n          resolved: this.resolved,\n          integrity: this.integrity && String(this.integrity),\n          from: this.from\n        });\n      });\n      extractor.on('error', er => {\n        this.log.warn('tar', er.message);\n        this.log.silly('tar', er);\n        reject(er);\n      });\n      tarball.on('error', er => reject(er));\n    });\n    tarball.pipe(extractor);\n    return p;\n  } // always ensure that entries are at least as permissive as our configured\n  // dmode/fmode, but never more permissive than the umask allows.\n\n\n  [_entryMode](path, mode, type) {\n    const m = /Directory|GNUDumpDir/.test(type) ? this.dmode : /File$/.test(type) ? this.fmode :\n    /* istanbul ignore next - should never happen in a pkg */\n    0; // make sure package bins are executable\n\n    const exe = isPackageBin(this.package, path) ? 0o111 : 0; // always ensure that files are read/writable by the owner\n\n    return (mode | m) & ~this.umask | exe | 0o600;\n  }\n\n  [_tarxOptions]({\n    cwd,\n    uid,\n    gid\n  }) {\n    const sawIgnores = new Set();\n    return {\n      cwd,\n      noChmod: true,\n      filter: (name, entry) => {\n        if (/Link$/.test(entry.type)) return false;\n        entry.mode = this[_entryMode](entry.path, entry.mode, entry.type); // this replicates the npm pack behavior where .gitignore files\n        // are treated like .npmignore files, but only if a .npmignore\n        // file is not present.\n\n        if (/File$/.test(entry.type)) {\n          const base = basename(entry.path);\n          if (base === '.npmignore') sawIgnores.add(entry.path);else if (base === '.gitignore' && !this.allowGitIgnore) {\n            // rename, but only if there's not already a .npmignore\n            const ni = entry.path.replace(/\\.gitignore$/, '.npmignore');\n            if (sawIgnores.has(ni)) return false;\n            entry.path = ni;\n          }\n          return true;\n        }\n      },\n      strip: 1,\n      onwarn:\n      /* istanbul ignore next - we can trust that tar logs */\n      (code, msg, data) => {\n        this.log.warn('tar', code, msg);\n        this.log.silly('tar', code, msg, data);\n      },\n      uid,\n      gid,\n      umask: this.umask\n    };\n  }\n\n}\n\nmodule.exports = FetcherBase; // Child classes\n\nconst GitFetcher = require('./git.js');\n\nconst RegistryFetcher = require('./registry.js');\n\nconst FileFetcher = require('./file.js');\n\nconst DirFetcher = require('./dir.js');\n\nconst RemoteFetcher = require('./remote.js'); // Get an appropriate fetcher object from a spec and options\n\n\nFetcherBase.get = (rawSpec, opts = {}) => {\n  const spec = npa(rawSpec, opts.where);\n\n  switch (spec.type) {\n    case 'git':\n      return new GitFetcher(spec, opts);\n\n    case 'remote':\n      return new RemoteFetcher(spec, opts);\n\n    case 'version':\n    case 'range':\n    case 'tag':\n    case 'alias':\n      return new RegistryFetcher(spec.subSpec || spec, opts);\n\n    case 'file':\n      return new FileFetcher(spec, opts);\n\n    case 'directory':\n      return new DirFetcher(spec, opts);\n\n    default:\n      throw new TypeError('Unknown spec type: ' + spec.type);\n  }\n};","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/pacote/lib/fetcher.js"],"names":["npa","require","ssri","promisify","basename","dirname","rimraf","tar","procLog","retry","fsm","cacache","isPackageBin","getContents","selfOwner","process","getuid","uid","gid","getgid","chownr","inferOwner","mkdirp","cacheDir","_chown","Symbol","_extract","_mkdir","_empty","_toFile","_tarxOptions","_entryMode","_istream","_assertType","_tarballFromCache","_tarballFromResolved","for","FetcherBase","constructor","spec","opts","TypeError","where","allowGitIgnore","from","registry","name","rawSpec","saveSpec","cache","resolved","defaultIntegrityAlgorithm","integrity","parse","package","type","fmode","dmode","umask","log","preferOnline","preferOffline","offline","before","fullMetadata","defaultTag","replace","npmBin","npmInstallCmd","npmCliConfig","toISOString","i","current","merge","notImplementedError","Error","resolve","Promise","reject","packument","manifest","tarball","tarballStream","stream","res","rej","buf","on","er","data","Buffer","concat","String","d","push","get","byDigest","istream","integrityStream","emit","pipe","pickIntegrityAlgorithm","pickAlgorithm","isDataCorruptionError","code","types","includes","join","isRetriableError","streamHandler","fromCache","catch","warn","cleanupCached","then","fromResolved","silly","tryAgain","retries","minTimeout","maxTimeout","rm","content","path","depth","contents","all","map","entry","dest","made","dir","extract","str","writer","WriteStream","tarballFile","extractor","x","cwd","p","message","mode","m","test","exe","sawIgnores","Set","noChmod","filter","base","add","ni","has","strip","onwarn","msg","module","exports","GitFetcher","RegistryFetcher","FileFetcher","DirFetcher","RemoteFetcher","subSpec"],"mappings":"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","sourcesContent":["// This is the base class that the other fetcher types in lib\n// all descend from.\n// It handles the unpacking and retry logic that is shared among\n// all of the other Fetcher types.\n\nconst npa = require('npm-package-arg')\nconst ssri = require('ssri')\nconst { promisify } = require('util')\nconst { basename, dirname } = require('path')\nconst rimraf = promisify(require('rimraf'))\nconst tar = require('tar')\nconst procLog = require('./util/proc-log.js')\nconst retry = require('promise-retry')\nconst fsm = require('fs-minipass')\nconst cacache = require('cacache')\nconst isPackageBin = require('./util/is-package-bin.js')\nconst getContents = require('@npmcli/installed-package-contents')\n\n// we only change ownership on unix platforms, and only if uid is 0\nconst selfOwner = process.getuid && process.getuid() === 0 ? {\n  uid: 0,\n  gid: process.getgid(),\n} : null\nconst chownr = selfOwner ? promisify(require('chownr')) : null\nconst inferOwner = selfOwner ? require('infer-owner') : null\nconst mkdirp = require('mkdirp')\nconst cacheDir = require('./util/cache-dir.js')\n\n// Private methods.\n// Child classes should not have to override these.\n// Users should never call them.\nconst _chown = Symbol('_chown')\nconst _extract = Symbol('_extract')\nconst _mkdir = Symbol('_mkdir')\nconst _empty = Symbol('_empty')\nconst _toFile = Symbol('_toFile')\nconst _tarxOptions = Symbol('_tarxOptions')\nconst _entryMode = Symbol('_entryMode')\nconst _istream = Symbol('_istream')\nconst _assertType = Symbol('_assertType')\nconst _tarballFromCache = Symbol('_tarballFromCache')\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved')\n\nclass FetcherBase {\n  constructor (spec, opts) {\n    if (!opts || typeof opts !== 'object')\n      throw new TypeError('options object is required')\n    this.spec = npa(spec, opts.where)\n\n    this.allowGitIgnore = !!opts.allowGitIgnore\n\n    // a bit redundant because presumably the caller already knows this,\n    // but it makes it easier to not have to keep track of the requested\n    // spec when we're dispatching thousands of these at once, and normalizing\n    // is nice.  saveSpec is preferred if set, because it turns stuff like\n    // x/y#committish into github:x/y#committish.  use name@rawSpec for\n    // registry deps so that we turn xyz and xyz@ -> xyz@\n    this.from = this.spec.registry\n      ? `${this.spec.name}@${this.spec.rawSpec}` : this.spec.saveSpec\n\n    this[_assertType]()\n    // clone the opts object so that others aren't upset when we mutate it\n    // by adding/modifying the integrity value.\n    this.opts = {...opts}\n\n    this.cache = opts.cache || cacheDir()\n    this.resolved = opts.resolved || null\n\n    // default to caching/verifying with sha512, that's what we usually have\n    // need to change this default, or start overriding it, when sha512\n    // is no longer strong enough.\n    this.defaultIntegrityAlgorithm = opts.defaultIntegrityAlgorithm || 'sha512'\n\n    if (typeof opts.integrity === 'string')\n      this.opts.integrity = ssri.parse(opts.integrity)\n\n    this.package = null\n    this.type = this.constructor.name\n    this.fmode = opts.fmode || 0o666\n    this.dmode = opts.dmode || 0o777\n    // we don't need a default umask, because we don't chmod files coming\n    // out of package tarballs.  they're forced to have a mode that is\n    // valid, regardless of what's in the tarball entry, and then we let\n    // the process's umask setting do its job.  but if configured, we do\n    // respect it.\n    this.umask = opts.umask || 0\n    this.log = opts.log || procLog\n\n    this.preferOnline = !!opts.preferOnline\n    this.preferOffline = !!opts.preferOffline\n    this.offline = !!opts.offline\n\n    this.before = opts.before\n    this.fullMetadata = this.before ? true : !!opts.fullMetadata\n\n    this.defaultTag = opts.defaultTag || 'latest'\n    this.registry = (opts.registry || 'https://registry.npmjs.org')\n      .replace(/\\/+$/, '')\n\n    // command to run 'prepare' scripts on directories and git dirs\n    // To use pacote with yarn, for example, set npmBin to 'yarn'\n    // and npmCliConfig with yarn's equivalents.\n    this.npmBin = opts.npmBin || 'npm'\n\n    // command to install deps for preparing\n    this.npmInstallCmd = opts.npmInstallCmd || [ 'install', '--force' ]\n\n    // XXX fill more of this in based on what we know from this.opts\n    // we explicitly DO NOT fill in --tag, though, since we are often\n    // going to be packing in the context of a publish, which may set\n    // a dist-tag, but certainly wants to keep defaulting to latest.\n    this.npmCliConfig = opts.npmCliConfig || [\n      `--cache=${dirname(this.cache)}`,\n      `--prefer-offline=${!!this.preferOffline}`,\n      `--prefer-online=${!!this.preferOnline}`,\n      `--offline=${!!this.offline}`,\n      ...(this.before ? [`--before=${this.before.toISOString()}`] : []),\n      '--no-progress',\n      '--no-save',\n      '--no-audit',\n    ]\n  }\n\n  get integrity () {\n    return this.opts.integrity || null\n  }\n  set integrity (i) {\n    if (!i)\n      return\n\n    i = ssri.parse(i)\n    const current = this.opts.integrity\n\n    // do not ever update an existing hash value, but do\n    // merge in NEW algos and hashes that we don't already have.\n    if (current)\n      current.merge(i)\n    else\n      this.opts.integrity = i\n  }\n\n  get notImplementedError () {\n    return new Error('not implemented in this fetcher type: ' + this.type)\n  }\n\n  // override in child classes\n  // Returns a Promise that resolves to this.resolved string value\n  resolve () {\n    return this.resolved ? Promise.resolve(this.resolved)\n      : Promise.reject(this.notImplementedError)\n  }\n\n  packument () {\n    return Promise.reject(this.notImplementedError)\n  }\n\n  // override in child class\n  // returns a manifest containing:\n  // - name\n  // - version\n  // - _resolved\n  // - _integrity\n  // - plus whatever else was in there (corgi, full metadata, or pj file)\n  manifest () {\n    return Promise.reject(this.notImplementedError)\n  }\n\n  // private, should be overridden.\n  // Note that they should *not* calculate or check integrity, but *just*\n  // return the raw tarball data stream.\n  [_tarballFromResolved] () {\n    throw this.notImplementedError\n  }\n\n  // public, should not be overridden\n  tarball () {\n    return this.tarballStream(stream => new Promise((res, rej) => {\n      const buf = []\n      stream.on('error', er => rej(er))\n      stream.on('end', () => {\n        const data = Buffer.concat(buf)\n        data.integrity = this.integrity && String(this.integrity)\n        data.resolved = this.resolved\n        data.from = this.from\n        return res(data)\n      })\n      stream.on('data', d => buf.push(d))\n    }))\n  }\n\n  // private\n  // Note: cacache will raise a EINTEGRITY error if the integrity doesn't match\n  [_tarballFromCache] () {\n    return cacache.get.stream.byDigest(this.cache, this.integrity, this.opts)\n  }\n\n  [_istream] (stream) {\n    // everyone will need one of these, either for verifying or calculating\n    // We always set it, because we have might only have a weak legacy hex\n    // sha1 in the packument, and this MAY upgrade it to a stronger algo.\n    // If we had an integrity, and it doesn't match, then this does not\n    // override that error; the istream will raise the error before it\n    // gets to the point of re-setting the integrity.\n    const istream = ssri.integrityStream(this.opts)\n    istream.on('integrity', i => this.integrity = i)\n    return stream.on('error', er => istream.emit('error', er)).pipe(istream)\n  }\n\n  pickIntegrityAlgorithm () {\n    return this.integrity ? this.integrity.pickAlgorithm(this.opts)\n      : this.defaultIntegrityAlgorithm\n  }\n\n  // TODO: check error class, once those are rolled out to our deps\n  isDataCorruptionError (er) {\n    return er.code === 'EINTEGRITY' || er.code === 'Z_DATA_ERROR'\n  }\n\n  // override the types getter\n  get types () {}\n  [_assertType] () {\n    if (this.types && !this.types.includes(this.spec.type)) {\n      throw new TypeError(`Wrong spec type (${\n        this.spec.type\n      }) for ${\n        this.constructor.name\n      }. Supported types: ${this.types.join(', ')}`)\n    }\n  }\n\n  // We allow ENOENTs from cacache, but not anywhere else.\n  // An ENOENT trying to read a tgz file, for example, is Right Out.\n  isRetriableError (er) {\n    // TODO: check error class, once those are rolled out to our deps\n    return this.isDataCorruptionError(er) || er.code === 'ENOENT'\n  }\n\n  // Mostly internal, but has some uses\n  // Pass in a function which returns a promise\n  // Function will be called 1 or more times with streams that may fail.\n  // Retries:\n  // Function MUST handle errors on the stream by rejecting the promise,\n  // so that retry logic can pick it up and either retry or fail whatever\n  // promise it was making (ie, failing extraction, etc.)\n  //\n  // The return value of this method is a Promise that resolves the same\n  // as whatever the streamHandler resolves to.\n  //\n  // This should never be overridden by child classes, but it is public.\n  tarballStream (streamHandler) {\n    // Only short-circuit via cache if we have everything else we'll need,\n    // and the user has not expressed a preference for checking online.\n\n    const fromCache = (\n      !this.preferOnline &&\n      this.integrity &&\n      this.resolved\n    ) ? streamHandler(this[_tarballFromCache]()).catch(er => {\n      if (this.isDataCorruptionError(er)) {\n        this.log.warn('tarball', `cached data for ${\n          this.spec\n        } (${this.integrity}) seems to be corrupted. Refreshing cache.`)\n        return this.cleanupCached().then(() => { throw er })\n      } else {\n        throw er\n      }\n    }) : null\n\n    const fromResolved = er => {\n      if (er) {\n        if (!this.isRetriableError(er))\n          throw er\n        this.log.silly('tarball', `no local data for ${\n          this.spec\n        }. Extracting by manifest.`)\n      }\n      return this.resolve().then(() => retry(tryAgain =>\n        streamHandler(this[_istream](this[_tarballFromResolved]()))\n        .catch(er => {\n          // Most likely data integrity.  A cache ENOENT error is unlikely\n          // here, since we're definitely not reading from the cache, but it\n          // IS possible that the fetch subsystem accessed the cache, and the\n          // entry got blown away or something.  Try one more time to be sure.\n          if (this.isRetriableError(er)) {\n            this.log.warn('tarball', `tarball data for ${\n              this.spec\n            } (${this.integrity}) seems to be corrupted. Trying again.`)\n            return this.cleanupCached().then(() => tryAgain(er))\n          }\n          throw er\n        }), { retries: 1, minTimeout: 0, maxTimeout: 0 }))\n    }\n\n    return fromCache ? fromCache.catch(fromResolved) : fromResolved()\n  }\n\n  cleanupCached () {\n    return cacache.rm.content(this.cache, this.integrity, this.opts)\n  }\n\n  async [_chown] (path, uid, gid) {\n    return selfOwner && (selfOwner.gid !== gid || selfOwner.uid !== uid)\n      ? chownr(path, uid, gid)\n      : /* istanbul ignore next - we don't test in root-owned folders */ null\n  }\n\n  [_empty] (path) {\n    return getContents({path, depth: 1}).then(contents => Promise.all(\n      contents.map(entry => rimraf(entry))))\n  }\n\n  [_mkdir] (dest) {\n    // if we're bothering to do owner inference, then do it.\n    // otherwise just make the dir, and return an empty object.\n    // always empty the dir dir to start with, but do so\n    // _after_ inferring the owner, in case there's an existing folder\n    // there that we would want to preserve which differs from the\n    // parent folder (rare, but probably happens sometimes).\n    return !inferOwner\n      ? this[_empty](dest).then(() => mkdirp(dest)).then(() => ({}))\n      : inferOwner(dest).then(({uid, gid}) =>\n        this[_empty](dest)\n          .then(() => mkdirp(dest))\n          .then(made => {\n            // ignore the || dest part in coverage.  It's there to handle\n            // race conditions where the dir may be made by someone else\n            // after being removed by us.\n            const dir = made || /* istanbul ignore next */ dest\n            return this[_chown](dir, uid, gid)\n          })\n          .then(() => ({uid, gid})))\n  }\n\n  // extraction is always the same.  the only difference is where\n  // the tarball comes from.\n  extract (dest) {\n    return this[_mkdir](dest).then(({uid, gid}) =>\n      this.tarballStream(tarball => this[_extract](dest, tarball, uid, gid)))\n  }\n\n  [_toFile] (dest) {\n    return this.tarballStream(str => new Promise((res, rej) => {\n      const writer = new fsm.WriteStream(dest)\n      str.on('error', er => writer.emit('error', er))\n      writer.on('error', er => rej(er))\n      writer.on('close', () => res({\n        integrity: this.integrity && String(this.integrity),\n        resolved: this.resolved,\n        from: this.from,\n      }))\n      str.pipe(writer)\n    }))\n  }\n\n  // don't use this[_mkdir] because we don't want to rimraf anything\n  tarballFile (dest) {\n    const dir = dirname(dest)\n    return !inferOwner\n      ? mkdirp(dir).then(() => this[_toFile](dest))\n      : inferOwner(dest).then(({uid, gid}) =>\n        mkdirp(dir).then(made => this[_toFile](dest)\n          .then(res => this[_chown](made || dir, uid, gid)\n            .then(() => res))))\n  }\n\n  [_extract] (dest, tarball, uid, gid) {\n    const extractor = tar.x(this[_tarxOptions]({ cwd: dest, uid, gid }))\n    const p = new Promise((resolve, reject) => {\n      extractor.on('end', () => {\n        resolve({\n          resolved: this.resolved,\n          integrity: this.integrity && String(this.integrity),\n          from: this.from,\n        })\n      })\n\n      extractor.on('error', er => {\n        this.log.warn('tar', er.message)\n        this.log.silly('tar', er)\n        reject(er)\n      })\n\n      tarball.on('error', er => reject(er))\n    })\n\n    tarball.pipe(extractor)\n    return p\n  }\n\n  // always ensure that entries are at least as permissive as our configured\n  // dmode/fmode, but never more permissive than the umask allows.\n  [_entryMode] (path, mode, type) {\n    const m = /Directory|GNUDumpDir/.test(type) ? this.dmode\n      : /File$/.test(type) ? this.fmode\n      : /* istanbul ignore next - should never happen in a pkg */ 0\n\n    // make sure package bins are executable\n    const exe = isPackageBin(this.package, path) ? 0o111 : 0\n    // always ensure that files are read/writable by the owner\n    return ((mode | m) & ~this.umask) | exe | 0o600\n  }\n\n  [_tarxOptions] ({ cwd, uid, gid }) {\n    const sawIgnores = new Set()\n    return {\n      cwd,\n      noChmod: true,\n      filter: (name, entry) => {\n        if (/Link$/.test(entry.type))\n          return false\n        entry.mode = this[_entryMode](entry.path, entry.mode, entry.type)\n        // this replicates the npm pack behavior where .gitignore files\n        // are treated like .npmignore files, but only if a .npmignore\n        // file is not present.\n        if (/File$/.test(entry.type)) {\n          const base = basename(entry.path)\n          if (base === '.npmignore')\n            sawIgnores.add(entry.path)\n          else if (base === '.gitignore' && !this.allowGitIgnore) {\n            // rename, but only if there's not already a .npmignore\n            const ni = entry.path.replace(/\\.gitignore$/, '.npmignore')\n            if (sawIgnores.has(ni))\n              return false\n            entry.path = ni\n          }\n          return true\n        }\n      },\n      strip: 1,\n      onwarn: /* istanbul ignore next - we can trust that tar logs */\n      (code, msg, data) => {\n        this.log.warn('tar', code, msg)\n        this.log.silly('tar', code, msg, data)\n      },\n      uid,\n      gid,\n      umask: this.umask,\n    }\n  }\n}\n\nmodule.exports = FetcherBase\n\n// Child classes\nconst GitFetcher = require('./git.js')\nconst RegistryFetcher = require('./registry.js')\nconst FileFetcher = require('./file.js')\nconst DirFetcher = require('./dir.js')\nconst RemoteFetcher = require('./remote.js')\n\n// Get an appropriate fetcher object from a spec and options\nFetcherBase.get = (rawSpec, opts = {}) => {\n  const spec = npa(rawSpec, opts.where)\n  switch (spec.type) {\n    case 'git':\n      return new GitFetcher(spec, opts)\n\n    case 'remote':\n      return new RemoteFetcher(spec, opts)\n\n    case 'version':\n    case 'range':\n    case 'tag':\n    case 'alias':\n      return new RegistryFetcher(spec.subSpec || spec, opts)\n\n    case 'file':\n      return new FileFetcher(spec, opts)\n\n    case 'directory':\n      return new DirFetcher(spec, opts)\n\n    default:\n      throw new TypeError('Unknown spec type: ' + spec.type)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}