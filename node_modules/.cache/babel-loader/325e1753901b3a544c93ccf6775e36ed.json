{"ast":null,"code":"const parseJSON = require('json-parse-even-better-errors');\n\nconst {\n  diff\n} = require('just-diff');\n\nconst {\n  diffApply\n} = require('just-diff-apply');\n\nconst stripBOM = content => {\n  content = content.toString(); // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n  // because the buffer-to-string conversion in `fs.readFileSync()`\n  // translates it to FEFF, the UTF-16 BOM.\n\n  if (content.charCodeAt(0) === 0xFEFF) content = content.slice(1);\n  return content;\n};\n\nconst PARENT_RE = /\\|{7,}/g;\nconst OURS_RE = /<{7,}/g;\nconst THEIRS_RE = /={7,}/g;\nconst END_RE = />{7,}/g;\n\nconst isDiff = str => str.match(OURS_RE) && str.match(THEIRS_RE) && str.match(END_RE);\n\nconst parseConflictJSON = (str, reviver, prefer) => {\n  prefer = prefer || 'ours';\n  if (prefer !== 'theirs' && prefer !== 'ours') throw new TypeError('prefer param must be \"ours\" or \"theirs\" if set');\n  str = stripBOM(str);\n  if (!isDiff(str)) return parseJSON(str);\n  const pieces = str.split(/[\\n\\r]+/g).reduce((acc, line) => {\n    if (line.match(PARENT_RE)) acc.state = 'parent';else if (line.match(OURS_RE)) acc.state = 'ours';else if (line.match(THEIRS_RE)) acc.state = 'theirs';else if (line.match(END_RE)) acc.state = 'top';else {\n      if (acc.state === 'top' || acc.state === 'ours') acc.ours += line;\n      if (acc.state === 'top' || acc.state === 'theirs') acc.theirs += line;\n      if (acc.state === 'top' || acc.state === 'parent') acc.parent += line;\n    }\n    return acc;\n  }, {\n    state: 'top',\n    ours: '',\n    theirs: '',\n    parent: ''\n  }); // this will throw if either piece is not valid JSON, that's intended\n\n  const parent = parseJSON(pieces.parent, reviver);\n  const ours = parseJSON(pieces.ours, reviver);\n  const theirs = parseJSON(pieces.theirs, reviver);\n  return prefer === 'ours' ? resolve(parent, ours, theirs) : resolve(parent, theirs, ours);\n};\n\nconst isObj = obj => obj && typeof obj === 'object';\n\nconst copyPath = (to, from, path, i) => {\n  const p = path[i];\n  if (isObj(to[p]) && isObj(from[p]) && Array.isArray(to[p]) === Array.isArray(from[p])) return copyPath(to[p], from[p], path, i + 1);\n  to[p] = from[p];\n}; // get the diff from parent->ours and applying our changes on top of theirs.\n// If they turned an object into a non-object, then put it back.\n\n\nconst resolve = (parent, ours, theirs) => {\n  const dours = diff(parent, ours);\n\n  for (let i = 0; i < dours.length; i++) {\n    try {\n      diffApply(theirs, [dours[i]]);\n    } catch (e) {\n      copyPath(theirs, ours, dours[i].path, 0);\n    }\n  }\n\n  return theirs;\n};\n\nmodule.exports = Object.assign(parseConflictJSON, {\n  isDiff\n});","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/parse-conflict-json/index.js"],"names":["parseJSON","require","diff","diffApply","stripBOM","content","toString","charCodeAt","slice","PARENT_RE","OURS_RE","THEIRS_RE","END_RE","isDiff","str","match","parseConflictJSON","reviver","prefer","TypeError","pieces","split","reduce","acc","line","state","ours","theirs","parent","resolve","isObj","obj","copyPath","to","from","path","i","p","Array","isArray","dours","length","e","module","exports","Object","assign"],"mappings":"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","sourcesContent":["const parseJSON = require('json-parse-even-better-errors')\nconst { diff } = require('just-diff')\nconst { diffApply } = require('just-diff-apply')\n\nconst stripBOM = content => {\n  content = content.toString()\n  // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n  // because the buffer-to-string conversion in `fs.readFileSync()`\n  // translates it to FEFF, the UTF-16 BOM.\n  if (content.charCodeAt(0) === 0xFEFF)\n    content = content.slice(1)\n  return content\n}\n\nconst PARENT_RE = /\\|{7,}/g\nconst OURS_RE = /<{7,}/g\nconst THEIRS_RE = /={7,}/g\nconst END_RE = />{7,}/g\n\nconst isDiff = str =>\n  str.match(OURS_RE) && str.match(THEIRS_RE) && str.match(END_RE)\n\nconst parseConflictJSON = (str, reviver, prefer) => {\n  prefer = prefer || 'ours'\n  if (prefer !== 'theirs' && prefer !== 'ours')\n    throw new TypeError('prefer param must be \"ours\" or \"theirs\" if set')\n\n  str = stripBOM(str)\n\n  if (!isDiff(str))\n    return parseJSON(str)\n\n  const pieces = str.split(/[\\n\\r]+/g).reduce((acc, line) => {\n    if (line.match(PARENT_RE))\n      acc.state = 'parent'\n    else if (line.match(OURS_RE))\n      acc.state = 'ours'\n    else if (line.match(THEIRS_RE))\n      acc.state = 'theirs'\n    else if (line.match(END_RE))\n      acc.state = 'top'\n    else {\n      if (acc.state === 'top' || acc.state === 'ours')\n        acc.ours += line\n      if (acc.state === 'top' || acc.state === 'theirs')\n        acc.theirs += line\n      if (acc.state === 'top' || acc.state === 'parent')\n        acc.parent += line\n    }\n    return acc\n  }, {\n    state: 'top',\n    ours: '',\n    theirs: '',\n    parent: ''\n  })\n\n  // this will throw if either piece is not valid JSON, that's intended\n  const parent = parseJSON(pieces.parent, reviver)\n  const ours = parseJSON(pieces.ours, reviver)\n  const theirs = parseJSON(pieces.theirs, reviver)\n\n  return prefer === 'ours'\n    ? resolve(parent, ours, theirs)\n    : resolve(parent, theirs, ours)\n}\n\nconst isObj = obj => obj && typeof obj === 'object'\n\nconst copyPath = (to, from, path, i) => {\n  const p = path[i]\n  if (isObj(to[p]) && isObj(from[p]) &&\n      Array.isArray(to[p]) === Array.isArray(from[p]))\n    return copyPath(to[p], from[p], path, i + 1)\n  to[p] = from[p]\n}\n\n// get the diff from parent->ours and applying our changes on top of theirs.\n// If they turned an object into a non-object, then put it back.\nconst resolve = (parent, ours, theirs) => {\n  const dours = diff(parent, ours)\n  for (let i = 0; i < dours.length; i++) {\n    try {\n      diffApply(theirs, [dours[i]])\n    } catch (e) {\n      copyPath(theirs, ours, dours[i].path, 0)\n    }\n  }\n  return theirs\n}\n\nmodule.exports = Object.assign(parseConflictJSON, { isDiff })\n"]},"metadata":{},"sourceType":"script"}