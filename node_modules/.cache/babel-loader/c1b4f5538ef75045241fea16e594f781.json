{"ast":null,"code":"// when we have to dupe a set of peer dependencies deeper into the tree in\n// order to make room for a dep that would otherwise conflict, we use\n// this to get the set of all deps that have to be checked to ensure\n// nothing is locking them into the current location.\n//\n// this is different in its semantics from an \"optional set\" (ie, the nodes\n// that should be removed if an optional dep fails), because in this case,\n// we specifically intend to include deps in the peer set that have\n// dependants outside the set.\nconst peerSet = node => {\n  const set = new Set([node]);\n\n  for (const node of set) {\n    for (const edge of node.edgesOut.values()) {\n      if (edge.valid && edge.peer && edge.to) set.add(edge.to);\n    }\n\n    for (const edge of node.edgesIn) {\n      if (edge.valid && edge.peer) set.add(edge.from);\n    }\n  }\n\n  return set;\n};\n\nmodule.exports = peerSet;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/@npmcli/arborist/lib/peer-set.js"],"names":["peerSet","node","set","Set","edge","edgesOut","values","valid","peer","to","add","edgesIn","from","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,OAAO,GAAGC,IAAI,IAAI;AACtB,QAAMC,GAAG,GAAG,IAAIC,GAAJ,CAAQ,CAACF,IAAD,CAAR,CAAZ;;AACA,OAAK,MAAMA,IAAX,IAAmBC,GAAnB,EAAwB;AACtB,SAAK,MAAME,IAAX,IAAmBH,IAAI,CAACI,QAAL,CAAcC,MAAd,EAAnB,EAA2C;AACzC,UAAIF,IAAI,CAACG,KAAL,IAAcH,IAAI,CAACI,IAAnB,IAA2BJ,IAAI,CAACK,EAApC,EACEP,GAAG,CAACQ,GAAJ,CAAQN,IAAI,CAACK,EAAb;AACH;;AACD,SAAK,MAAML,IAAX,IAAmBH,IAAI,CAACU,OAAxB,EAAiC;AAC/B,UAAIP,IAAI,CAACG,KAAL,IAAcH,IAAI,CAACI,IAAvB,EACEN,GAAG,CAACQ,GAAJ,CAAQN,IAAI,CAACQ,IAAb;AACH;AACF;;AACD,SAAOV,GAAP;AACD,CAbD;;AAeAW,MAAM,CAACC,OAAP,GAAiBd,OAAjB","sourcesContent":["// when we have to dupe a set of peer dependencies deeper into the tree in\n// order to make room for a dep that would otherwise conflict, we use\n// this to get the set of all deps that have to be checked to ensure\n// nothing is locking them into the current location.\n//\n// this is different in its semantics from an \"optional set\" (ie, the nodes\n// that should be removed if an optional dep fails), because in this case,\n// we specifically intend to include deps in the peer set that have\n// dependants outside the set.\nconst peerSet = node => {\n  const set = new Set([node])\n  for (const node of set) {\n    for (const edge of node.edgesOut.values()) {\n      if (edge.valid && edge.peer && edge.to)\n        set.add(edge.to)\n    }\n    for (const edge of node.edgesIn) {\n      if (edge.valid && edge.peer)\n        set.add(edge.from)\n    }\n  }\n  return set\n}\n\nmodule.exports = peerSet\n"]},"metadata":{},"sourceType":"script"}