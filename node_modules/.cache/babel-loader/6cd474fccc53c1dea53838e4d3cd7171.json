{"ast":null,"code":"const {\n  promisify\n} = require('util');\n\nconst {\n  resolve,\n  dirname\n} = require('path');\n\nconst fs = require('fs');\n\nconst lstat = promisify(fs.lstat);\n\nconst throwNonEnoent = er => {\n  if (er.code !== 'ENOENT') throw er;\n};\n\nconst cmdShim = require('cmd-shim');\n\nconst readCmdShim = require('read-cmd-shim');\n\nconst fixBin = require('./fix-bin.js'); // even in --force mode, we never create a shim over a shim we've\n// already created.  you can have multiple packages in a tree trying\n// to contend for the same bin, which creates a race condition and\n// nondeterminism.\n\n\nconst seen = new Set();\n\nconst failEEXIST = ({\n  path,\n  to,\n  from\n}) => Promise.reject(Object.assign(new Error('EEXIST: file already exists'), {\n  path: to,\n  dest: from,\n  code: 'EEXIST'\n}));\n\nconst handleReadCmdShimError = ({\n  er,\n  from,\n  to\n}) => er.code === 'ENOENT' ? null : er.code === 'ENOTASHIM' ? failEEXIST({\n  from,\n  to\n}) : Promise.reject(er);\n\nconst SKIP = Symbol('skip - missing or already installed');\n\nconst shimBin = ({\n  path,\n  to,\n  from,\n  absFrom,\n  force\n}) => {\n  const shims = [to, to + '.cmd', to + '.ps1'];\n\n  for (const shim of shims) {\n    if (seen.has(shim)) return true;\n    seen.add(shim);\n  }\n\n  return Promise.all([...shims, absFrom].map(f => lstat(f).catch(throwNonEnoent))).then(stats => {\n    const [stToBase, stToCmd, stToPs1, stFrom] = stats;\n    if (!stFrom) return SKIP;\n    if (force) return;\n    return Promise.all(shims.map((s, i) => [s, stats[i]]).map(([s, st]) => {\n      if (!st) return;\n      return readCmdShim(s).then(target => {\n        target = resolve(dirname(to), target);\n        if (target.indexOf(resolve(path)) !== 0) return failEEXIST({\n          from,\n          to,\n          path\n        });\n      }, er => handleReadCmdShimError({\n        er,\n        from,\n        to\n      }));\n    }));\n  }).then(skip => skip !== SKIP && doShim(absFrom, to));\n};\n\nconst doShim = (absFrom, to) => cmdShim(absFrom, to).then(() => fixBin(absFrom));\n\nconst resetSeen = () => {\n  for (const p of seen) {\n    seen.delete(p);\n  }\n};\n\nmodule.exports = Object.assign(shimBin, {\n  resetSeen\n});","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/bin-links/lib/shim-bin.js"],"names":["promisify","require","resolve","dirname","fs","lstat","throwNonEnoent","er","code","cmdShim","readCmdShim","fixBin","seen","Set","failEEXIST","path","to","from","Promise","reject","Object","assign","Error","dest","handleReadCmdShimError","SKIP","Symbol","shimBin","absFrom","force","shims","shim","has","add","all","map","f","catch","then","stats","stToBase","stToCmd","stToPs1","stFrom","s","i","st","target","indexOf","skip","doShim","resetSeen","p","delete","module","exports"],"mappings":"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","sourcesContent":["const { promisify } = require('util')\nconst { resolve, dirname } = require('path')\nconst fs = require('fs')\nconst lstat = promisify(fs.lstat)\nconst throwNonEnoent = er => { if (er.code !== 'ENOENT') throw er }\n\nconst cmdShim = require('cmd-shim')\nconst readCmdShim = require('read-cmd-shim')\n\nconst fixBin = require('./fix-bin.js')\n\n// even in --force mode, we never create a shim over a shim we've\n// already created.  you can have multiple packages in a tree trying\n// to contend for the same bin, which creates a race condition and\n// nondeterminism.\nconst seen = new Set()\n\nconst failEEXIST = ({path, to, from}) =>\n  Promise.reject(Object.assign(new Error('EEXIST: file already exists'), {\n    path: to,\n    dest: from,\n    code: 'EEXIST',\n  }))\n\nconst handleReadCmdShimError = ({er, from, to}) =>\n  er.code === 'ENOENT' ? null\n  : er.code === 'ENOTASHIM' ? failEEXIST({from, to})\n  : Promise.reject(er)\n\nconst SKIP = Symbol('skip - missing or already installed')\nconst shimBin = ({path, to, from, absFrom, force}) => {\n  const shims = [\n    to,\n    to + '.cmd',\n    to + '.ps1',\n  ]\n\n  for (const shim of shims) {\n    if (seen.has(shim))\n      return true\n    seen.add(shim)\n  }\n\n  return Promise.all([\n    ...shims,\n    absFrom,\n  ].map(f => lstat(f).catch(throwNonEnoent))).then((stats) => {\n    const [\n      stToBase,\n      stToCmd,\n      stToPs1,\n      stFrom,\n    ] = stats\n    if (!stFrom)\n      return SKIP\n\n    if (force)\n      return\n\n    return Promise.all(shims.map((s, i) => [s, stats[i]]).map(([s, st]) => {\n      if (!st)\n        return\n      return readCmdShim(s)\n        .then(target => {\n          target = resolve(dirname(to), target)\n          if (target.indexOf(resolve(path)) !== 0)\n            return failEEXIST({from, to, path})\n        }, er => handleReadCmdShimError({er, from, to}))\n    }))\n  })\n  .then(skip => skip !== SKIP && doShim(absFrom, to))\n}\n\nconst doShim = (absFrom, to) =>\n  cmdShim(absFrom, to).then(() => fixBin(absFrom))\n\nconst resetSeen = () => {\n  for (const p of seen) {\n    seen.delete(p)\n  }\n}\n\nmodule.exports = Object.assign(shimBin, { resetSeen })\n"]},"metadata":{},"sourceType":"script"}