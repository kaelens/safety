{"ast":null,"code":"const {\n  dirname,\n  relative,\n  join,\n  resolve,\n  basename\n} = require('path');\n\nconst linkGently = require('./link-gently.js');\n\nconst manTarget = require('./man-target.js');\n\nconst linkMans = ({\n  path,\n  pkg,\n  top,\n  force\n}) => {\n  const target = manTarget({\n    path,\n    top\n  });\n  if (!target || !pkg.man || !Array.isArray(pkg.man) || !pkg.man.length) return Promise.resolve([]); // break any links to c:\\\\blah or /foo/blah or ../blah\n  // and filter out duplicates\n\n  const set = [...new Set(pkg.man.map(man => man ? join('/', man).replace(/\\\\|:/g, '/').substr(1) : null).filter(man => typeof man === 'string'))];\n  return Promise.all(set.map(man => {\n    const parseMan = man.match(/(.*\\.([0-9]+)(\\.gz)?)$/);\n\n    if (!parseMan) {\n      return Promise.reject(Object.assign(new Error('invalid man entry name\\n' + 'Man files must end with a number, ' + 'and optionally a .gz suffix if they are compressed.'), {\n        code: 'EBADMAN',\n        path,\n        pkgid: pkg._id,\n        man\n      }));\n    }\n\n    const stem = parseMan[1];\n    const sxn = parseMan[2];\n    const base = basename(stem);\n    const absFrom = resolve(path, man);\n    /* istanbul ignore if - that unpossible */\n\n    if (absFrom.indexOf(path) !== 0) {\n      return Promise.reject(Object.assign(new Error('invalid man entry'), {\n        code: 'EBADMAN',\n        path,\n        pkgid: pkg._id,\n        man\n      }));\n    }\n\n    const to = resolve(target, 'man' + sxn, base);\n    const from = relative(dirname(to), absFrom);\n    return linkGently({\n      from,\n      to,\n      path,\n      absFrom,\n      force\n    });\n  }));\n};\n\nmodule.exports = linkMans;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/bin-links/lib/link-mans.js"],"names":["dirname","relative","join","resolve","basename","require","linkGently","manTarget","linkMans","path","pkg","top","force","target","man","Array","isArray","length","Promise","set","Set","map","replace","substr","filter","all","parseMan","match","reject","Object","assign","Error","code","pkgid","_id","stem","sxn","base","absFrom","indexOf","to","from","module","exports"],"mappings":"AAAA,MAAM;AAAEA,EAAAA,OAAF;AAAWC,EAAAA,QAAX;AAAqBC,EAAAA,IAArB;AAA2BC,EAAAA,OAA3B;AAAoCC,EAAAA;AAApC,IAAiDC,OAAO,CAAC,MAAD,CAA9D;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,kBAAD,CAA1B;;AACA,MAAME,SAAS,GAAGF,OAAO,CAAC,iBAAD,CAAzB;;AAEA,MAAMG,QAAQ,GAAG,CAAC;AAACC,EAAAA,IAAD;AAAOC,EAAAA,GAAP;AAAYC,EAAAA,GAAZ;AAAiBC,EAAAA;AAAjB,CAAD,KAA6B;AAC5C,QAAMC,MAAM,GAAGN,SAAS,CAAC;AAACE,IAAAA,IAAD;AAAOE,IAAAA;AAAP,GAAD,CAAxB;AACA,MAAI,CAACE,MAAD,IAAW,CAACH,GAAG,CAACI,GAAhB,IAAuB,CAACC,KAAK,CAACC,OAAN,CAAcN,GAAG,CAACI,GAAlB,CAAxB,IAAkD,CAACJ,GAAG,CAACI,GAAJ,CAAQG,MAA/D,EACE,OAAOC,OAAO,CAACf,OAAR,CAAgB,EAAhB,CAAP,CAH0C,CAK5C;AACA;;AACA,QAAMgB,GAAG,GAAG,CAAC,GAAG,IAAIC,GAAJ,CAAQV,GAAG,CAACI,GAAJ,CAAQO,GAAR,CAAYP,GAAG,IACrCA,GAAG,GAAGZ,IAAI,CAAC,GAAD,EAAMY,GAAN,CAAJ,CAAeQ,OAAf,CAAuB,OAAvB,EAAgC,GAAhC,EAAqCC,MAArC,CAA4C,CAA5C,CAAH,GAAoD,IADjC,EAErBC,MAFqB,CAEdV,GAAG,IAAI,OAAOA,GAAP,KAAe,QAFR,CAAR,CAAJ,CAAZ;AAIA,SAAOI,OAAO,CAACO,GAAR,CAAYN,GAAG,CAACE,GAAJ,CAAQP,GAAG,IAAI;AAChC,UAAMY,QAAQ,GAAGZ,GAAG,CAACa,KAAJ,CAAU,wBAAV,CAAjB;;AACA,QAAI,CAACD,QAAL,EAAe;AACb,aAAOR,OAAO,CAACU,MAAR,CAAeC,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAU,6BAC5C,oCAD4C,GAE5C,qDAFkC,CAAd,EAGnB;AACDC,QAAAA,IAAI,EAAE,SADL;AAEDvB,QAAAA,IAFC;AAGDwB,QAAAA,KAAK,EAAEvB,GAAG,CAACwB,GAHV;AAIDpB,QAAAA;AAJC,OAHmB,CAAf,CAAP;AASD;;AAED,UAAMqB,IAAI,GAAGT,QAAQ,CAAC,CAAD,CAArB;AACA,UAAMU,GAAG,GAAGV,QAAQ,CAAC,CAAD,CAApB;AACA,UAAMW,IAAI,GAAGjC,QAAQ,CAAC+B,IAAD,CAArB;AACA,UAAMG,OAAO,GAAGnC,OAAO,CAACM,IAAD,EAAOK,GAAP,CAAvB;AACA;;AACA,QAAIwB,OAAO,CAACC,OAAR,CAAgB9B,IAAhB,MAA0B,CAA9B,EAAiC;AAC/B,aAAOS,OAAO,CAACU,MAAR,CAAeC,MAAM,CAACC,MAAP,CAAc,IAAIC,KAAJ,CAAU,mBAAV,CAAd,EAA8C;AAClEC,QAAAA,IAAI,EAAE,SAD4D;AAElEvB,QAAAA,IAFkE;AAGlEwB,QAAAA,KAAK,EAAEvB,GAAG,CAACwB,GAHuD;AAIlEpB,QAAAA;AAJkE,OAA9C,CAAf,CAAP;AAMD;;AAED,UAAM0B,EAAE,GAAGrC,OAAO,CAACU,MAAD,EAAS,QAAQuB,GAAjB,EAAsBC,IAAtB,CAAlB;AACA,UAAMI,IAAI,GAAGxC,QAAQ,CAACD,OAAO,CAACwC,EAAD,CAAR,EAAcF,OAAd,CAArB;AAEA,WAAOhC,UAAU,CAAC;AAACmC,MAAAA,IAAD;AAAOD,MAAAA,EAAP;AAAW/B,MAAAA,IAAX;AAAiB6B,MAAAA,OAAjB;AAA0B1B,MAAAA;AAA1B,KAAD,CAAjB;AACD,GAhCkB,CAAZ,CAAP;AAiCD,CA5CD;;AA8CA8B,MAAM,CAACC,OAAP,GAAiBnC,QAAjB","sourcesContent":["const { dirname, relative, join, resolve, basename } = require('path')\nconst linkGently = require('./link-gently.js')\nconst manTarget = require('./man-target.js')\n\nconst linkMans = ({path, pkg, top, force}) => {\n  const target = manTarget({path, top})\n  if (!target || !pkg.man || !Array.isArray(pkg.man) || !pkg.man.length)\n    return Promise.resolve([])\n\n  // break any links to c:\\\\blah or /foo/blah or ../blah\n  // and filter out duplicates\n  const set = [...new Set(pkg.man.map(man =>\n    man ? join('/', man).replace(/\\\\|:/g, '/').substr(1) : null)\n    .filter(man => typeof man === 'string'))]\n\n  return Promise.all(set.map(man => {\n    const parseMan = man.match(/(.*\\.([0-9]+)(\\.gz)?)$/)\n    if (!parseMan) {\n      return Promise.reject(Object.assign(new Error('invalid man entry name\\n' +\n        'Man files must end with a number, ' +\n        'and optionally a .gz suffix if they are compressed.'\n      ), {\n        code: 'EBADMAN',\n        path,\n        pkgid: pkg._id,\n        man,\n      }))\n    }\n\n    const stem = parseMan[1]\n    const sxn = parseMan[2]\n    const base = basename(stem)\n    const absFrom = resolve(path, man)\n    /* istanbul ignore if - that unpossible */\n    if (absFrom.indexOf(path) !== 0) {\n      return Promise.reject(Object.assign(new Error('invalid man entry'), {\n        code: 'EBADMAN',\n        path,\n        pkgid: pkg._id,\n        man,\n      }))\n    }\n\n    const to = resolve(target, 'man' + sxn, base)\n    const from = relative(dirname(to), absFrom)\n\n    return linkGently({from, to, path, absFrom, force})\n  }))\n}\n\nmodule.exports = linkMans\n"]},"metadata":{},"sourceType":"script"}