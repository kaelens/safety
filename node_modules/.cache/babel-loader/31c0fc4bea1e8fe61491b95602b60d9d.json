{"ast":null,"code":"const signals = require('./signals.js'); // for testing, expose the process being used\n\n\nmodule.exports = Object.assign(fn => setup(fn), {\n  process\n}); // do all of this in a setup function so that we can call it\n// multiple times for multiple reifies that might be going on.\n// Otherwise, Arborist.reify() is a global action, which is a\n// new constraint we'd be adding with this behavior.\n\nconst setup = fn => {\n  const {\n    process\n  } = module.exports;\n  const sigListeners = {\n    loaded: false\n  };\n\n  const unload = () => {\n    if (!sigListeners.loaded) return;\n\n    for (const sig of signals) {\n      try {\n        process.removeListener(sig, sigListeners[sig]);\n      } catch (er) {}\n    }\n\n    process.removeListener('beforeExit', onBeforeExit);\n    sigListeners.loaded = false;\n  };\n\n  const onBeforeExit = () => {\n    // this trick ensures that we exit with the same signal we caught\n    // Ie, if you press ^C and npm gets a SIGINT, we'll do the rollback\n    // and then exit with a SIGINT signal once we've removed the handler.\n    // The timeout is there because signals are asynchronous, so we need\n    // the process to NOT exit on its own, which means we have to have\n    // something keeping the event loop looping.  Hence this hack.\n    unload();\n    process.kill(process.pid, signalReceived);\n    setTimeout(() => {}, 500);\n  };\n\n  let signalReceived = null;\n\n  const listener = (sig, fn) => () => {\n    signalReceived = sig; // if we exit normally, but caught a signal which would have been fatal,\n    // then re-send it once we're done with whatever cleanup we have to do.\n\n    unload();\n    if (process.listeners(sig).length < 1) process.once('beforeExit', onBeforeExit);\n    fn({\n      signal: sig\n    });\n  }; // do the actual loading here\n\n\n  for (const sig of signals) {\n    sigListeners[sig] = listener(sig, fn);\n    const max = process.getMaxListeners();\n\n    try {\n      // if we call this a bunch of times, avoid triggering the warning\n      const {\n        length\n      } = process.listeners(sig);\n      if (length >= max) process.setMaxListeners(length + 1);\n      process.on(sig, sigListeners[sig]);\n    } catch (er) {}\n  }\n\n  sigListeners.loaded = true;\n  return unload;\n};","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/@npmcli/arborist/lib/signal-handling.js"],"names":["signals","require","module","exports","Object","assign","fn","setup","process","sigListeners","loaded","unload","sig","removeListener","er","onBeforeExit","kill","pid","signalReceived","setTimeout","listener","listeners","length","once","signal","max","getMaxListeners","setMaxListeners","on"],"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,cAAD,CAAvB,C,CAEA;;;AACAC,MAAM,CAACC,OAAP,GAAiBC,MAAM,CAACC,MAAP,CAAcC,EAAE,IAAIC,KAAK,CAACD,EAAD,CAAzB,EAA+B;AAAEE,EAAAA;AAAF,CAA/B,CAAjB,C,CAEA;AACA;AACA;AACA;;AACA,MAAMD,KAAK,GAAGD,EAAE,IAAI;AAClB,QAAM;AAAEE,IAAAA;AAAF,MAAcN,MAAM,CAACC,OAA3B;AAEA,QAAMM,YAAY,GAAG;AAAEC,IAAAA,MAAM,EAAE;AAAV,GAArB;;AAEA,QAAMC,MAAM,GAAG,MAAM;AACnB,QAAI,CAACF,YAAY,CAACC,MAAlB,EACE;;AACF,SAAK,MAAME,GAAX,IAAkBZ,OAAlB,EAA2B;AACzB,UAAI;AACFQ,QAAAA,OAAO,CAACK,cAAR,CAAuBD,GAAvB,EAA4BH,YAAY,CAACG,GAAD,CAAxC;AACD,OAFD,CAEE,OAAOE,EAAP,EAAW,CAAE;AAChB;;AACDN,IAAAA,OAAO,CAACK,cAAR,CAAuB,YAAvB,EAAqCE,YAArC;AACAN,IAAAA,YAAY,CAACC,MAAb,GAAsB,KAAtB;AACD,GAVD;;AAYA,QAAMK,YAAY,GAAG,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACAJ,IAAAA,MAAM;AACNH,IAAAA,OAAO,CAACQ,IAAR,CAAaR,OAAO,CAACS,GAArB,EAA0BC,cAA1B;AACAC,IAAAA,UAAU,CAAC,MAAM,CAAE,CAAT,EAAW,GAAX,CAAV;AACD,GAVD;;AAYA,MAAID,cAAc,GAAG,IAArB;;AACA,QAAME,QAAQ,GAAG,CAACR,GAAD,EAAMN,EAAN,KAAa,MAAM;AAClCY,IAAAA,cAAc,GAAGN,GAAjB,CADkC,CAGlC;AACA;;AACAD,IAAAA,MAAM;AACN,QAAIH,OAAO,CAACa,SAAR,CAAkBT,GAAlB,EAAuBU,MAAvB,GAAgC,CAApC,EACEd,OAAO,CAACe,IAAR,CAAa,YAAb,EAA2BR,YAA3B;AAEFT,IAAAA,EAAE,CAAC;AAAEkB,MAAAA,MAAM,EAAEZ;AAAV,KAAD,CAAF;AACD,GAVD,CA9BkB,CA0ClB;;;AACA,OAAK,MAAMA,GAAX,IAAkBZ,OAAlB,EAA2B;AACzBS,IAAAA,YAAY,CAACG,GAAD,CAAZ,GAAoBQ,QAAQ,CAACR,GAAD,EAAMN,EAAN,CAA5B;AACA,UAAMmB,GAAG,GAAGjB,OAAO,CAACkB,eAAR,EAAZ;;AACA,QAAI;AACF;AACA,YAAM;AAAEJ,QAAAA;AAAF,UAAad,OAAO,CAACa,SAAR,CAAkBT,GAAlB,CAAnB;AACA,UAAIU,MAAM,IAAIG,GAAd,EACEjB,OAAO,CAACmB,eAAR,CAAwBL,MAAM,GAAG,CAAjC;AACFd,MAAAA,OAAO,CAACoB,EAAR,CAAWhB,GAAX,EAAgBH,YAAY,CAACG,GAAD,CAA5B;AACD,KAND,CAME,OAAOE,EAAP,EAAW,CAAE;AAChB;;AACDL,EAAAA,YAAY,CAACC,MAAb,GAAsB,IAAtB;AAEA,SAAOC,MAAP;AACD,CAzDD","sourcesContent":["const signals = require('./signals.js')\n\n// for testing, expose the process being used\nmodule.exports = Object.assign(fn => setup(fn), { process })\n\n// do all of this in a setup function so that we can call it\n// multiple times for multiple reifies that might be going on.\n// Otherwise, Arborist.reify() is a global action, which is a\n// new constraint we'd be adding with this behavior.\nconst setup = fn => {\n  const { process } = module.exports\n\n  const sigListeners = { loaded: false }\n\n  const unload = () => {\n    if (!sigListeners.loaded)\n      return\n    for (const sig of signals) {\n      try {\n        process.removeListener(sig, sigListeners[sig])\n      } catch (er) {}\n    }\n    process.removeListener('beforeExit', onBeforeExit)\n    sigListeners.loaded = false\n  }\n\n  const onBeforeExit = () => {\n    // this trick ensures that we exit with the same signal we caught\n    // Ie, if you press ^C and npm gets a SIGINT, we'll do the rollback\n    // and then exit with a SIGINT signal once we've removed the handler.\n    // The timeout is there because signals are asynchronous, so we need\n    // the process to NOT exit on its own, which means we have to have\n    // something keeping the event loop looping.  Hence this hack.\n    unload()\n    process.kill(process.pid, signalReceived)\n    setTimeout(() => {}, 500)\n  }\n\n  let signalReceived = null\n  const listener = (sig, fn) => () => {\n    signalReceived = sig\n\n    // if we exit normally, but caught a signal which would have been fatal,\n    // then re-send it once we're done with whatever cleanup we have to do.\n    unload()\n    if (process.listeners(sig).length < 1)\n      process.once('beforeExit', onBeforeExit)\n\n    fn({ signal: sig })\n  }\n\n  // do the actual loading here\n  for (const sig of signals) {\n    sigListeners[sig] = listener(sig, fn)\n    const max = process.getMaxListeners()\n    try {\n      // if we call this a bunch of times, avoid triggering the warning\n      const { length } = process.listeners(sig)\n      if (length >= max)\n        process.setMaxListeners(length + 1)\n      process.on(sig, sigListeners[sig])\n    } catch (er) {}\n  }\n  sigListeners.loaded = true\n\n  return unload\n}\n"]},"metadata":{},"sourceType":"script"}