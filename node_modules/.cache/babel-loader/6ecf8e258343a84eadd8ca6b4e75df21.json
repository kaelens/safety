{"ast":null,"code":"// this is the public class that is used by consumers.\n// the Advisory class handles all the calculation, and this\n// class handles all the IO with the registry and cache.\nconst pacote = require('pacote');\n\nconst cacache = require('cacache');\n\nconst Advisory = require('./advisory.js');\n\nconst {\n  homedir\n} = require('os');\n\nconst jsonParse = require('json-parse-even-better-errors');\n\nconst _packument = Symbol('packument');\n\nconst _cachePut = Symbol('cachePut');\n\nconst _cacheGet = Symbol('cacheGet');\n\nconst _cacheData = Symbol('cacheData');\n\nconst _packuments = Symbol('packuments');\n\nconst _cache = Symbol('cache');\n\nconst _options = Symbol('options');\n\nconst _advisories = Symbol('advisories');\n\nconst _calculate = Symbol('calculate');\n\nclass Calculator {\n  constructor(options = {}) {\n    this[_options] = { ...options\n    };\n    this[_cache] = this[_options].cache || homedir() + '/.npm/_cacache';\n    this[_options].cache = this[_cache];\n    this[_packuments] = new Map();\n    this[_cacheData] = new Map();\n    this[_advisories] = new Map();\n  }\n\n  get cache() {\n    return this[_cache];\n  }\n\n  get options() {\n    return { ...this[_options]\n    };\n  }\n\n  async calculate(name, source) {\n    const k = `security-advisory:${name}:${source.id}`;\n    if (this[_advisories].has(k)) return this[_advisories].get(k);\n\n    const p = this[_calculate](name, source);\n\n    this[_advisories].set(k, p);\n\n    return p;\n  }\n\n  async [_calculate](name, source) {\n    const k = `security-advisory:${name}:${source.id}`;\n    const t = `metavuln:calculate:${k}`;\n    process.emit('time', t);\n    const advisory = new Advisory(name, source, this[_options]); // load packument and cached advisory\n\n    const [cached, packument] = await Promise.all([this[_cacheGet](advisory), this[_packument](name)]);\n    process.emit('time', `metavuln:load:${k}`);\n    advisory.load(cached, packument);\n    process.emit('timeEnd', `metavuln:load:${k}`);\n    if (advisory.updated) await this[_cachePut](advisory);\n\n    this[_advisories].set(k, advisory);\n\n    process.emit('timeEnd', t);\n    return advisory;\n  }\n\n  async [_cachePut](advisory) {\n    const {\n      name,\n      id\n    } = advisory;\n    const key = `security-advisory:${name}:${id}`;\n    process.emit('time', `metavuln:cache:put:${key}`);\n    const data = JSON.stringify(advisory);\n    const options = { ...this[_options]\n    };\n\n    this[_cacheData].set(key, jsonParse(data));\n\n    await cacache.put(this[_cache], key, data, options).catch(() => {});\n    process.emit('timeEnd', `metavuln:cache:put:${key}`);\n  }\n\n  async [_cacheGet](advisory) {\n    const {\n      name,\n      id\n    } = advisory;\n    const key = `security-advisory:${name}:${id}`;\n    /* istanbul ignore if - should be impossible, since we memoize the\n     * advisory object itself using the same key, just being cautious */\n\n    if (this[_cacheData].has(key)) return this[_cacheData].get(key);\n    process.emit('time', `metavuln:cache:get:${key}`);\n    const p = cacache.get(this[_cache], key, { ...this[_options]\n    }).catch(() => ({\n      data: '{}'\n    })).then(({\n      data\n    }) => {\n      data = jsonParse(data);\n      process.emit('timeEnd', `metavuln:cache:get:${key}`);\n\n      this[_cacheData].set(key, data);\n\n      return data;\n    });\n\n    this[_cacheData].set(key, p);\n\n    return p;\n  }\n\n  async [_packument](name) {\n    if (this[_packuments].has(name)) return this[_packuments].get(name);\n    process.emit('time', `metavuln:packument:${name}`);\n    const p = pacote.packument(name, { ...this[_options]\n    }).catch(er => {\n      // presumably not something from the registry.\n      // an empty packument will have an effective range of *\n      return {\n        name,\n        versions: {}\n      };\n    }).then(paku => {\n      process.emit('timeEnd', `metavuln:packument:${name}`);\n\n      this[_packuments].set(name, paku);\n\n      return paku;\n    });\n\n    this[_packuments].set(name, p);\n\n    return p;\n  }\n\n}\n\nmodule.exports = Calculator;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/@npmcli/metavuln-calculator/lib/index.js"],"names":["pacote","require","cacache","Advisory","homedir","jsonParse","_packument","Symbol","_cachePut","_cacheGet","_cacheData","_packuments","_cache","_options","_advisories","_calculate","Calculator","constructor","options","cache","Map","calculate","name","source","k","id","has","get","p","set","t","process","emit","advisory","cached","packument","Promise","all","load","updated","key","data","JSON","stringify","put","catch","then","er","versions","paku","module","exports"],"mappings":"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","sourcesContent":["// this is the public class that is used by consumers.\n// the Advisory class handles all the calculation, and this\n// class handles all the IO with the registry and cache.\nconst pacote = require('pacote')\nconst cacache = require('cacache')\nconst Advisory = require('./advisory.js')\nconst {homedir} = require('os')\nconst jsonParse = require('json-parse-even-better-errors')\n\nconst _packument = Symbol('packument')\nconst _cachePut = Symbol('cachePut')\nconst _cacheGet = Symbol('cacheGet')\nconst _cacheData = Symbol('cacheData')\nconst _packuments = Symbol('packuments')\nconst _cache = Symbol('cache')\nconst _options = Symbol('options')\nconst _advisories = Symbol('advisories')\nconst _calculate = Symbol('calculate')\n\nclass Calculator {\n  constructor (options = {}) {\n    this[_options] = { ...options }\n    this[_cache] = this[_options].cache || (homedir() + '/.npm/_cacache')\n    this[_options].cache = this[_cache]\n    this[_packuments] = new Map()\n    this[_cacheData] = new Map()\n    this[_advisories] = new Map()\n  }\n\n  get cache () {\n    return this[_cache]\n  }\n\n  get options () {\n    return { ...this[_options] }\n  }\n\n  async calculate (name, source) {\n    const k = `security-advisory:${name}:${source.id}`\n    if (this[_advisories].has(k))\n      return this[_advisories].get(k)\n\n    const p = this[_calculate](name, source)\n    this[_advisories].set(k, p)\n    return p\n  }\n\n  async [_calculate] (name, source) {\n    const k = `security-advisory:${name}:${source.id}`\n    const t = `metavuln:calculate:${k}`\n    process.emit('time', t)\n    const advisory = new Advisory(name, source, this[_options])\n    // load packument and cached advisory\n    const [cached, packument] = await Promise.all([\n      this[_cacheGet](advisory),\n      this[_packument](name),\n    ])\n    process.emit('time', `metavuln:load:${k}`)\n    advisory.load(cached, packument)\n    process.emit('timeEnd', `metavuln:load:${k}`)\n    if (advisory.updated)\n      await this[_cachePut](advisory)\n    this[_advisories].set(k, advisory)\n    process.emit('timeEnd', t)\n    return advisory\n  }\n\n  async [_cachePut] (advisory) {\n    const { name, id } = advisory\n    const key = `security-advisory:${name}:${id}`\n    process.emit('time', `metavuln:cache:put:${key}`)\n    const data = JSON.stringify(advisory)\n    const options = { ...this[_options] }\n    this[_cacheData].set(key, jsonParse(data))\n    await cacache.put(this[_cache], key, data, options).catch(() => {})\n    process.emit('timeEnd', `metavuln:cache:put:${key}`)\n  }\n\n  async [_cacheGet] (advisory) {\n    const { name, id } = advisory\n    const key = `security-advisory:${name}:${id}`\n    /* istanbul ignore if - should be impossible, since we memoize the\n     * advisory object itself using the same key, just being cautious */\n    if (this[_cacheData].has(key))\n      return this[_cacheData].get(key)\n\n    process.emit('time', `metavuln:cache:get:${key}`)\n    const p = cacache.get(this[_cache], key, { ...this[_options] })\n      .catch(() => ({ data: '{}' }))\n      .then(({ data }) => {\n        data = jsonParse(data)\n        process.emit('timeEnd', `metavuln:cache:get:${key}`)\n        this[_cacheData].set(key, data)\n        return data\n      })\n    this[_cacheData].set(key, p)\n    return p\n  }\n\n  async [_packument] (name) {\n    if (this[_packuments].has(name))\n      return this[_packuments].get(name)\n\n    process.emit('time', `metavuln:packument:${name}`)\n    const p = pacote.packument(name, { ...this[_options] })\n      .catch((er) => {\n        // presumably not something from the registry.\n        // an empty packument will have an effective range of *\n        return {\n          name,\n          versions: {},\n        }\n      })\n      .then(paku => {\n        process.emit('timeEnd', `metavuln:packument:${name}`)\n        this[_packuments].set(name, paku)\n        return paku\n      })\n    this[_packuments].set(name, p)\n    return p\n  }\n}\n\nmodule.exports = Calculator\n"]},"metadata":{},"sourceType":"script"}