{"ast":null,"code":"const Minipass = require('minipass');\n\nconst Pipeline = require('minipass-pipeline');\n\nconst libSearch = require('libnpmsearch');\n\nconst log = require('npmlog');\n\nconst formatPackageStream = require('./search/format-package-stream.js');\n\nconst packageFilter = require('./search/package-filter.js');\n\nfunction prepareIncludes(args) {\n  return args.map(s => s.toLowerCase()).filter(s => s);\n}\n\nfunction prepareExcludes(searchexclude) {\n  var exclude;\n  if (typeof searchexclude === 'string') exclude = searchexclude.split(/\\s+/);else exclude = [];\n  return exclude.map(s => s.toLowerCase()).filter(s => s);\n}\n\nconst BaseCommand = require('./base-command.js');\n\nclass Search extends BaseCommand {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description() {\n    return 'Search for pacakges';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get name() {\n    return 'search';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get params() {\n    return ['long', 'json', 'parseable', 'description'];\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get usage() {\n    return ['[search terms ...]'];\n  }\n\n  exec(args, cb) {\n    this.search(args).then(() => cb()).catch(cb);\n  }\n\n  async search(args) {\n    const opts = { ...this.npm.flatOptions,\n      ...this.npm.flatOptions.search,\n      include: prepareIncludes(args),\n      exclude: prepareExcludes(this.npm.flatOptions.search.exclude)\n    };\n    if (opts.include.length === 0) throw new Error('search must be called with arguments'); // Used later to figure out whether we had any packages go out\n\n    let anyOutput = false;\n\n    class FilterStream extends Minipass {\n      write(pkg) {\n        if (packageFilter(pkg, opts.include, opts.exclude)) super.write(pkg);\n      }\n\n    }\n\n    const filterStream = new FilterStream(); // Grab a configured output stream that will spit out packages in the\n    // desired format.\n\n    const outputStream = formatPackageStream({\n      args,\n      // --searchinclude options are not highlighted\n      ...opts\n    });\n    log.silly('search', 'searching packages');\n    const p = new Pipeline(libSearch.stream(opts.include, opts), filterStream, outputStream);\n    p.on('data', chunk => {\n      if (!anyOutput) anyOutput = true;\n      this.npm.output(chunk.toString('utf8'));\n    });\n    await p.promise();\n    if (!anyOutput && !this.npm.config.get('json') && !this.npm.config.get('parseable')) this.npm.output('No matches found for ' + args.map(JSON.stringify).join(' '));\n    log.silly('search', 'search completed');\n    log.clearProgress();\n  }\n\n}\n\nmodule.exports = Search;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/lib/search.js"],"names":["Minipass","require","Pipeline","libSearch","log","formatPackageStream","packageFilter","prepareIncludes","args","map","s","toLowerCase","filter","prepareExcludes","searchexclude","exclude","split","BaseCommand","Search","description","name","params","usage","exec","cb","search","then","catch","opts","npm","flatOptions","include","length","Error","anyOutput","FilterStream","write","pkg","filterStream","outputStream","silly","p","stream","on","chunk","output","toString","promise","config","get","JSON","stringify","join","clearProgress","module","exports"],"mappings":"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","sourcesContent":["const Minipass = require('minipass')\nconst Pipeline = require('minipass-pipeline')\nconst libSearch = require('libnpmsearch')\nconst log = require('npmlog')\n\nconst formatPackageStream = require('./search/format-package-stream.js')\nconst packageFilter = require('./search/package-filter.js')\n\nfunction prepareIncludes (args) {\n  return args\n    .map(s => s.toLowerCase())\n    .filter(s => s)\n}\n\nfunction prepareExcludes (searchexclude) {\n  var exclude\n  if (typeof searchexclude === 'string')\n    exclude = searchexclude.split(/\\s+/)\n  else\n    exclude = []\n\n  return exclude\n    .map(s => s.toLowerCase())\n    .filter(s => s)\n}\n\nconst BaseCommand = require('./base-command.js')\nclass Search extends BaseCommand {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description () {\n    return 'Search for pacakges'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'search'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params () {\n    return [\n      'long',\n      'json',\n      'parseable',\n      'description',\n    ]\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return ['[search terms ...]']\n  }\n\n  exec (args, cb) {\n    this.search(args).then(() => cb()).catch(cb)\n  }\n\n  async search (args) {\n    const opts = {\n      ...this.npm.flatOptions,\n      ...this.npm.flatOptions.search,\n      include: prepareIncludes(args),\n      exclude: prepareExcludes(this.npm.flatOptions.search.exclude),\n    }\n\n    if (opts.include.length === 0)\n      throw new Error('search must be called with arguments')\n\n    // Used later to figure out whether we had any packages go out\n    let anyOutput = false\n\n    class FilterStream extends Minipass {\n      write (pkg) {\n        if (packageFilter(pkg, opts.include, opts.exclude))\n          super.write(pkg)\n      }\n    }\n\n    const filterStream = new FilterStream()\n\n    // Grab a configured output stream that will spit out packages in the\n    // desired format.\n    const outputStream = formatPackageStream({\n      args, // --searchinclude options are not highlighted\n      ...opts,\n    })\n\n    log.silly('search', 'searching packages')\n    const p = new Pipeline(\n      libSearch.stream(opts.include, opts),\n      filterStream,\n      outputStream\n    )\n\n    p.on('data', chunk => {\n      if (!anyOutput)\n        anyOutput = true\n      this.npm.output(chunk.toString('utf8'))\n    })\n\n    await p.promise()\n    if (!anyOutput && !this.npm.config.get('json') && !this.npm.config.get('parseable'))\n      this.npm.output('No matches found for ' + (args.map(JSON.stringify).join(' ')))\n\n    log.silly('search', 'search completed')\n    log.clearProgress()\n  }\n}\nmodule.exports = Search\n"]},"metadata":{},"sourceType":"script"}