{"ast":null,"code":"/* eslint-disable camelcase */\n\n/* eslint-disable standard/no-callback-literal */\nconst fs = require('fs');\n\nconst util = require('util');\n\nconst readdir = util.promisify(fs.readdir);\n\nconst reifyFinish = require('./utils/reify-finish.js');\n\nconst log = require('npmlog');\n\nconst {\n  resolve,\n  join\n} = require('path');\n\nconst Arborist = require('@npmcli/arborist');\n\nconst runScript = require('@npmcli/run-script');\n\nconst BaseCommand = require('./base-command.js');\n\nclass Install extends BaseCommand {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description() {\n    return 'Install a package';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get name() {\n    return 'install';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get params() {\n    return ['save', 'save-exact'];\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get usage() {\n    return ['[<@scope>/]<pkg>', '[<@scope>/]<pkg>@<tag>', '[<@scope>/]<pkg>@<version>', '[<@scope>/]<pkg>@<version range>', '<alias>@npm:<name>', '<folder>', '<tarball file>', '<tarball url>', '<git:// url>', '<github username>/<github project>'];\n  }\n\n  async completion(opts) {\n    const {\n      partialWord\n    } = opts; // install can complete to a folder with a package.json, or any package.\n    // if it has a slash, then it's gotta be a folder\n    // if it starts with https?://, then just give up, because it's a url\n\n    if (/^https?:\\/\\//.test(partialWord)) {\n      // do not complete to URLs\n      return [];\n    }\n\n    if (/\\//.test(partialWord)) {\n      // Complete fully to folder if there is exactly one match and it\n      // is a folder containing a package.json file.  If that is not the\n      // case we return 0 matches, which will trigger the default bash\n      // complete.\n      const lastSlashIdx = partialWord.lastIndexOf('/');\n      const partialName = partialWord.slice(lastSlashIdx + 1);\n      const partialPath = partialWord.slice(0, lastSlashIdx) || '/';\n\n      const annotatePackageDirMatch = async sibling => {\n        const fullPath = join(partialPath, sibling);\n        if (sibling.slice(0, partialName.length) !== partialName) return null; // not name match\n\n        try {\n          const contents = await readdir(fullPath);\n          return {\n            fullPath,\n            isPackage: contents.indexOf('package.json') !== -1\n          };\n        } catch (er) {\n          return {\n            isPackage: false\n          };\n        }\n      };\n\n      try {\n        const siblings = await readdir(partialPath);\n        const matches = await Promise.all(siblings.map(async sibling => {\n          return await annotatePackageDirMatch(sibling);\n        }));\n        const match = matches.filter(el => !el || el.isPackage).pop();\n\n        if (match) {\n          // Success - only one match and it is a package dir\n          return [match.fullPath];\n        } else {\n          // no matches\n          return [];\n        }\n      } catch (er) {\n        return []; // invalid dir: no matching\n      }\n    } // Note: there used to be registry completion here,\n    // but it stopped making sense somewhere around\n    // 50,000 packages on the registry\n\n  }\n\n  exec(args, cb) {\n    this.install(args).then(() => cb()).catch(cb);\n  }\n\n  async install(args) {\n    // the /path/to/node_modules/..\n    const globalTop = resolve(this.npm.globalDir, '..');\n    const ignoreScripts = this.npm.config.get('ignore-scripts');\n    const isGlobalInstall = this.npm.config.get('global');\n    const where = isGlobalInstall ? globalTop : this.npm.prefix; // don't try to install the prefix into itself\n\n    args = args.filter(a => resolve(a) !== this.npm.prefix); // `npm i -g` => \"install this package globally\"\n\n    if (where === globalTop && !args.length) args = ['.']; // TODO: Add warnings for other deprecated flags?  or remove this one?\n\n    if (this.npm.config.get('dev')) log.warn('install', 'Usage of the `--dev` option is deprecated. Use `--include=dev` instead.');\n    const opts = { ...this.npm.flatOptions,\n      log: this.npm.log,\n      auditLevel: null,\n      path: where,\n      add: args\n    };\n    const arb = new Arborist(opts);\n    await arb.reify(opts);\n\n    if (!args.length && !isGlobalInstall && !ignoreScripts) {\n      const scriptShell = this.npm.config.get('script-shell') || undefined;\n      const scripts = ['preinstall', 'install', 'postinstall', 'prepublish', // XXX should we remove this finally??\n      'preprepare', 'prepare', 'postprepare'];\n\n      for (const event of scripts) {\n        await runScript({\n          path: where,\n          args: [],\n          scriptShell,\n          stdio: 'inherit',\n          stdioString: true,\n          banner: log.level !== 'silent',\n          event\n        });\n      }\n    }\n\n    await reifyFinish(this.npm, arb);\n  }\n\n}\n\nmodule.exports = Install;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/lib/install.js"],"names":["fs","require","util","readdir","promisify","reifyFinish","log","resolve","join","Arborist","runScript","BaseCommand","Install","description","name","params","usage","completion","opts","partialWord","test","lastSlashIdx","lastIndexOf","partialName","slice","partialPath","annotatePackageDirMatch","sibling","fullPath","length","contents","isPackage","indexOf","er","siblings","matches","Promise","all","map","match","filter","el","pop","exec","args","cb","install","then","catch","globalTop","npm","globalDir","ignoreScripts","config","get","isGlobalInstall","where","prefix","a","warn","flatOptions","auditLevel","path","add","arb","reify","scriptShell","undefined","scripts","event","stdio","stdioString","banner","level","module","exports"],"mappings":"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","sourcesContent":["/* eslint-disable camelcase */\n/* eslint-disable standard/no-callback-literal */\nconst fs = require('fs')\nconst util = require('util')\nconst readdir = util.promisify(fs.readdir)\nconst reifyFinish = require('./utils/reify-finish.js')\nconst log = require('npmlog')\nconst { resolve, join } = require('path')\nconst Arborist = require('@npmcli/arborist')\nconst runScript = require('@npmcli/run-script')\n\nconst BaseCommand = require('./base-command.js')\nclass Install extends BaseCommand {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description () {\n    return 'Install a package'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'install'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params () {\n    return [\n      'save',\n      'save-exact',\n    ]\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return [\n      '[<@scope>/]<pkg>',\n      '[<@scope>/]<pkg>@<tag>',\n      '[<@scope>/]<pkg>@<version>',\n      '[<@scope>/]<pkg>@<version range>',\n      '<alias>@npm:<name>',\n      '<folder>',\n      '<tarball file>',\n      '<tarball url>',\n      '<git:// url>',\n      '<github username>/<github project>',\n    ]\n  }\n\n  async completion (opts) {\n    const { partialWord } = opts\n    // install can complete to a folder with a package.json, or any package.\n    // if it has a slash, then it's gotta be a folder\n    // if it starts with https?://, then just give up, because it's a url\n    if (/^https?:\\/\\//.test(partialWord)) {\n      // do not complete to URLs\n      return []\n    }\n\n    if (/\\//.test(partialWord)) {\n      // Complete fully to folder if there is exactly one match and it\n      // is a folder containing a package.json file.  If that is not the\n      // case we return 0 matches, which will trigger the default bash\n      // complete.\n      const lastSlashIdx = partialWord.lastIndexOf('/')\n      const partialName = partialWord.slice(lastSlashIdx + 1)\n      const partialPath = partialWord.slice(0, lastSlashIdx) || '/'\n\n      const annotatePackageDirMatch = async (sibling) => {\n        const fullPath = join(partialPath, sibling)\n        if (sibling.slice(0, partialName.length) !== partialName)\n          return null // not name match\n\n        try {\n          const contents = await readdir(fullPath)\n          return {\n            fullPath,\n            isPackage: contents.indexOf('package.json') !== -1,\n          }\n        } catch (er) {\n          return { isPackage: false }\n        }\n      }\n\n      try {\n        const siblings = await readdir(partialPath)\n        const matches = await Promise.all(\n          siblings.map(async sibling => {\n            return await annotatePackageDirMatch(sibling)\n          })\n        )\n        const match = matches.filter(el => !el || el.isPackage).pop()\n        if (match) {\n          // Success - only one match and it is a package dir\n          return [match.fullPath]\n        } else {\n          // no matches\n          return []\n        }\n      } catch (er) {\n        return [] // invalid dir: no matching\n      }\n    }\n    // Note: there used to be registry completion here,\n    // but it stopped making sense somewhere around\n    // 50,000 packages on the registry\n  }\n\n  exec (args, cb) {\n    this.install(args).then(() => cb()).catch(cb)\n  }\n\n  async install (args) {\n    // the /path/to/node_modules/..\n    const globalTop = resolve(this.npm.globalDir, '..')\n    const ignoreScripts = this.npm.config.get('ignore-scripts')\n    const isGlobalInstall = this.npm.config.get('global')\n    const where = isGlobalInstall ? globalTop : this.npm.prefix\n\n    // don't try to install the prefix into itself\n    args = args.filter(a => resolve(a) !== this.npm.prefix)\n\n    // `npm i -g` => \"install this package globally\"\n    if (where === globalTop && !args.length)\n      args = ['.']\n\n    // TODO: Add warnings for other deprecated flags?  or remove this one?\n    if (this.npm.config.get('dev'))\n      log.warn('install', 'Usage of the `--dev` option is deprecated. Use `--include=dev` instead.')\n\n    const opts = {\n      ...this.npm.flatOptions,\n      log: this.npm.log,\n      auditLevel: null,\n      path: where,\n      add: args,\n    }\n    const arb = new Arborist(opts)\n    await arb.reify(opts)\n\n    if (!args.length && !isGlobalInstall && !ignoreScripts) {\n      const scriptShell = this.npm.config.get('script-shell') || undefined\n      const scripts = [\n        'preinstall',\n        'install',\n        'postinstall',\n        'prepublish', // XXX should we remove this finally??\n        'preprepare',\n        'prepare',\n        'postprepare',\n      ]\n      for (const event of scripts) {\n        await runScript({\n          path: where,\n          args: [],\n          scriptShell,\n          stdio: 'inherit',\n          stdioString: true,\n          banner: log.level !== 'silent',\n          event,\n        })\n      }\n    }\n    await reifyFinish(this.npm, arb)\n  }\n}\nmodule.exports = Install\n"]},"metadata":{},"sourceType":"script"}