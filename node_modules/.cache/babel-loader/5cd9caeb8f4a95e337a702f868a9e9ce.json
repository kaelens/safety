{"ast":null,"code":"// a module that manages a shrinkwrap file (npm-shrinkwrap.json or\n// package-lock.json).\n// Increment whenever the lockfile version updates\n// v1 - npm <=6\n// v2 - arborist v1, npm v7, backwards compatible with v1, add 'packages'\n// v3 will drop the 'dependencies' field, backwards comp with v2, not v1\n//\n// We cannot bump to v3 until npm v6 is out of common usage, and\n// definitely not before npm v8.\nconst lockfileVersion = 2; // for comparing nodes to yarn.lock entries\n\nconst mismatch = (a, b) => a && b && a !== b; // this.tree => the root node for the tree (ie, same path as this)\n// - Set the first time we do `this.add(node)` for a path matching this.path\n//\n// this.add(node) =>\n// - decorate the node with the metadata we have, if we have it, and it matches\n// - add to the map of nodes needing to be committed, so that subsequent\n// changes are captured when we commit that location's metadata.\n//\n// this.commit() =>\n// - commit all nodes awaiting update to their metadata entries\n// - re-generate this.data and this.yarnLock based on this.tree\n//\n// Note that between this.add() and this.commit(), `this.data` will be out of\n// date!  Always call `commit()` before relying on it.\n//\n// After calling this.commit(), any nodes not present in the tree will have\n// been removed from the shrinkwrap data as well.\n\n\nconst procLog = require('./proc-log.js');\n\nconst YarnLock = require('./yarn-lock.js');\n\nconst {\n  promisify\n} = require('util');\n\nconst rimraf = promisify(require('rimraf'));\n\nconst fs = require('fs');\n\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\nconst stat = promisify(fs.stat);\nconst readdir_ = promisify(fs.readdir);\nconst readlink = promisify(fs.readlink); // XXX remove when drop support for node v10\n\nconst lstat = promisify(fs.lstat);\n/* istanbul ignore next - version specific polyfill */\n\nconst readdir = async (path, opt) => {\n  if (!opt || !opt.withFileTypes) return readdir_(path, opt);\n  const ents = await readdir_(path, opt);\n\n  if (typeof ents[0] === 'string') {\n    return Promise.all(ents.map(async ent => {\n      return Object.assign(await lstat(path + '/' + ent), {\n        name: ent\n      });\n    }));\n  }\n\n  return ents;\n};\n\nconst {\n  resolve,\n  basename\n} = require('path');\n\nconst specFromLock = require('./spec-from-lock.js');\n\nconst versionFromTgz = require('./version-from-tgz.js');\n\nconst npa = require('npm-package-arg');\n\nconst rpj = require('read-package-json-fast');\n\nconst parseJSON = require('parse-conflict-json');\n\nconst stringify = require('json-stringify-nice');\n\nconst swKeyOrder = ['name', 'version', 'lockfileVersion', 'resolved', 'integrity', 'requires', 'packages', 'dependencies']; // used to rewrite from yarn registry to npm registry\n\nconst yarnRegRe = /^https?:\\/\\/registry.yarnpkg.com\\//;\nconst npmRegRe = /^https?:\\/\\/registry.npmjs.org\\//; // sometimes resolved: is weird or broken, or something npa can't handle\n\nconst specFromResolved = resolved => {\n  try {\n    return npa(resolved);\n  } catch (er) {\n    return {};\n  }\n};\n\nconst relpath = require('./relpath.js');\n\nconst consistentResolve = require('./consistent-resolve.js');\n\nconst maybeReadFile = file => {\n  return readFile(file, 'utf8').then(d => d, er => {\n    /* istanbul ignore else - can't test without breaking module itself */\n    if (er.code === 'ENOENT') return '';else throw er;\n  });\n};\n\nconst maybeStatFile = file => {\n  return stat(file).then(st => st.isFile(), er => {\n    /* istanbul ignore else - can't test without breaking module itself */\n    if (er.code === 'ENOENT') return null;else throw er;\n  });\n};\n\nconst pkgMetaKeys = [// note: name is included if necessary, for alias packages\n'version', 'dependencies', 'peerDependencies', 'peerDependenciesMeta', 'optionalDependencies', 'bundleDependencies', 'acceptDependencies', 'funding', 'engines', 'os', 'cpu', '_integrity', 'license', '_hasShrinkwrap', 'hasInstallScript', 'bin', 'deprecated', 'workspaces'];\nconst nodeMetaKeys = ['integrity', 'inBundle', 'hasShrinkwrap', 'hasInstallScript'];\n\nconst metaFieldFromPkg = (pkg, key) => {\n  const val = pkg[key]; // get the license type, not an object\n\n  return key === 'license' && val && typeof val === 'object' && val.type ? val.type // skip empty objects and falsey values\n  : val && !(typeof val === 'object' && !Object.keys(val).length) ? val : null;\n}; // check to make sure that there are no packages newer than the hidden lockfile\n\n\nconst assertNoNewer = async (path, data, lockTime, dir = path, seen = null) => {\n  const base = basename(dir);\n  const isNM = dir !== path && base === 'node_modules';\n  const isScope = dir !== path && !isNM && base.charAt(0) === '@';\n  const isParent = dir === path || isNM || isScope;\n  const rel = relpath(path, dir);\n\n  if (dir !== path) {\n    const dirTime = (await stat(dir)).mtime;\n    if (dirTime > lockTime) throw 'out of date, updated: ' + rel;\n    if (!isScope && !isNM && !data.packages[rel]) throw 'missing from lockfile: ' + rel;\n    seen.add(rel);\n  } else seen = new Set([rel]);\n\n  const parent = isParent ? dir : resolve(dir, 'node_modules');\n  const children = dir === path ? Promise.resolve([{\n    name: 'node_modules',\n    isDirectory: () => true\n  }]) : readdir(parent, {\n    withFileTypes: true\n  });\n  return children.catch(() => []).then(ents => Promise.all(ents.map(async ent => {\n    const child = resolve(parent, ent.name);\n    if (ent.isDirectory() && !/^\\./.test(ent.name)) await assertNoNewer(path, data, lockTime, child, seen);else if (ent.isSymbolicLink()) {\n      const target = resolve(parent, await readlink(child));\n      const tstat = await stat(target).catch(() => null);\n      seen.add(relpath(path, child));\n      if (tstat && tstat.isDirectory() && !seen.has(relpath(path, target))) await assertNoNewer(path, data, lockTime, target, seen);\n    }\n  }))).then(() => {\n    if (dir !== path) return; // assert that all the entries in the lockfile were seen\n\n    for (const loc of new Set(Object.keys(data.packages))) {\n      if (!seen.has(loc)) throw 'missing from node_modules: ' + loc;\n    }\n  });\n};\n\nconst _awaitingUpdate = Symbol('_awaitingUpdate');\n\nconst _updateWaitingNode = Symbol('_updateWaitingNode');\n\nconst _lockFromLoc = Symbol('_lockFromLoc');\n\nconst _pathToLoc = Symbol('_pathToLoc');\n\nconst _loadAll = Symbol('_loadAll');\n\nconst _metaFromLock = Symbol('_metaFromLock');\n\nconst _resolveMetaNode = Symbol('_resolveMetaNode');\n\nconst _fixDependencies = Symbol('_fixDependencies');\n\nconst _buildLegacyLockfile = Symbol('_buildLegacyLockfile');\n\nconst _filenameSet = Symbol('_filenameSet');\n\nconst _maybeRead = Symbol('_maybeRead');\n\nconst _maybeStat = Symbol('_maybeStat');\n\nclass Shrinkwrap {\n  static load(options) {\n    return new Shrinkwrap(options).load();\n  }\n\n  static get keyOrder() {\n    return swKeyOrder;\n  }\n\n  static reset(options) {\n    // still need to know if it was loaded from the disk, but don't\n    // bother reading it if we're gonna just throw it away.\n    const s = new Shrinkwrap(options);\n    s.reset();\n    return s[_maybeStat]().then(([sw, lock]) => {\n      s.filename = resolve(s.path, (s.hiddenLockfile ? 'node_modules/.package-lock' : s.shrinkwrapOnly || sw ? 'npm-shrinkwrap' : 'package-lock') + '.json');\n      s.loadedFromDisk = !!(sw || lock);\n      s.type = basename(s.filename);\n      return s;\n    });\n  }\n\n  static metaFromNode(node, path) {\n    if (node.isLink) {\n      return {\n        resolved: relpath(path, node.realpath),\n        link: true\n      };\n    }\n\n    const meta = {};\n    pkgMetaKeys.forEach(key => {\n      const val = metaFieldFromPkg(node.package, key);\n      if (val) meta[key.replace(/^_/, '')] = val;\n    }); // we only include name if different from the node path name\n\n    const pname = node.package.name;\n    if (pname && pname !== node.name) meta.name = pname;\n    if (node.isTop && node.package.devDependencies) meta.devDependencies = node.package.devDependencies;\n    nodeMetaKeys.forEach(key => {\n      if (node[key]) meta[key] = node[key];\n    });\n    const resolved = consistentResolve(node.resolved, node.path, path, true);\n    if (resolved) meta.resolved = resolved;\n    if (node.extraneous) meta.extraneous = true;else {\n      if (node.peer) meta.peer = true;\n      if (node.dev) meta.dev = true;\n      if (node.optional) meta.optional = true;\n      if (node.devOptional && !node.dev && !node.optional) meta.devOptional = true;\n    }\n    return meta;\n  }\n\n  constructor(options = {}) {\n    const {\n      path,\n      indent = 2,\n      newline = '\\n',\n      shrinkwrapOnly = false,\n      hiddenLockfile = false,\n      log = procLog\n    } = options;\n    this.log = log;\n    this[_awaitingUpdate] = new Map();\n    this.tree = null;\n    this.path = resolve(path || '.');\n    this.filename = null;\n    this.data = null;\n    this.indent = indent;\n    this.newline = newline;\n    this.loadedFromDisk = false;\n    this.type = null;\n    this.yarnLock = null;\n    this.hiddenLockfile = hiddenLockfile;\n    this.loadingError = null; // only load npm-shrinkwrap.json in dep trees, not package-lock\n\n    this.shrinkwrapOnly = shrinkwrapOnly;\n  } // check to see if a spec is present in the yarn.lock file, and if so,\n  // if we should use it, and what it should resolve to.  This is only\n  // done when we did not load a shrinkwrap from disk.  Also, decorate\n  // the options object if provided with the resolved and integrity that\n  // we expect.\n\n\n  checkYarnLock(spec, options = {}) {\n    spec = npa(spec);\n    const {\n      yarnLock,\n      loadedFromDisk\n    } = this;\n    const useYarnLock = yarnLock && !loadedFromDisk;\n    const fromYarn = useYarnLock && yarnLock.entries.get(spec.raw);\n\n    if (fromYarn && fromYarn.version) {\n      // if it's the yarn or npm default registry, use the version as\n      // our effective spec.  if it's any other kind of thing, use that.\n      const {\n        resolved,\n        version,\n        integrity\n      } = fromYarn;\n      const isYarnReg = spec.registry && yarnRegRe.test(resolved);\n      const isnpmReg = spec.registry && !isYarnReg && npmRegRe.test(resolved);\n      const isReg = isnpmReg || isYarnReg; // don't use the simple version if the \"registry\" url is\n      // something else entirely!\n\n      const tgz = isReg && versionFromTgz(spec.name, resolved) || {};\n      const yspec = tgz.name === spec.name && tgz.version === version ? version : isReg && tgz.name && tgz.version ? `npm:${tgz.name}@${tgz.version}` : resolved;\n\n      if (yspec) {\n        options.resolved = resolved.replace(yarnRegRe, 'https://registry.npmjs.org/');\n        options.integrity = integrity;\n        return npa(`${spec.name}@${yspec}`);\n      }\n    }\n\n    return spec;\n  } // throw away the shrinkwrap data so we can start fresh\n  // still worth doing a load() first so we know which files to write.\n\n\n  reset() {\n    this.tree = null;\n    this[_awaitingUpdate] = new Map();\n    this.data = {\n      lockfileVersion,\n      requires: true,\n      packages: {},\n      dependencies: {}\n    };\n  }\n\n  [_filenameSet]() {\n    return this.shrinkwrapOnly ? [this.path + '/npm-shrinkwrap.json'] : this.hiddenLockfile ? [null, this.path + '/node_modules/.package-lock.json'] : [this.path + '/npm-shrinkwrap.json', this.path + '/package-lock.json', this.path + '/yarn.lock'];\n  }\n\n  [_maybeRead]() {\n    return Promise.all(this[_filenameSet]().map(fn => fn && maybeReadFile(fn)));\n  }\n\n  [_maybeStat]() {\n    // throw away yarn, we only care about lock or shrinkwrap when checking\n    // this way, since we're not actually loading the full lock metadata\n    return Promise.all(this[_filenameSet]().slice(0, 2).map(fn => fn && maybeStatFile(fn)));\n  }\n\n  load() {\n    // we don't need to load package-lock.json except for top of tree nodes,\n    // only npm-shrinkwrap.json.\n    return this[_maybeRead]().then(([sw, lock, yarn]) => {\n      const data = sw || lock || ''; // use shrinkwrap only for deps, otherwise prefer package-lock\n      // and ignore npm-shrinkwrap if both are present.\n      // TODO: emit a warning here or something if both are present.\n\n      this.filename = resolve(this.path, (this.hiddenLockfile ? 'node_modules/.package-lock' : this.shrinkwrapOnly || sw ? 'npm-shrinkwrap' : 'package-lock') + '.json');\n      this.type = basename(this.filename);\n      this.loadedFromDisk = !!data;\n\n      if (yarn) {\n        this.yarnLock = new YarnLock(); // ignore invalid yarn data.  we'll likely clobber it later anyway.\n\n        try {\n          this.yarnLock.parse(yarn);\n        } catch (_) {}\n      }\n\n      return data ? parseJSON(data) : {};\n    }).then(async data => {\n      // don't use detect-indent, just pick the first line.\n      // if the file starts with {\" then we have an indent of '', ie, none\n      // which will default to 2 at save time.\n      const {\n        [Symbol.for('indent')]: indent,\n        [Symbol.for('newline')]: newline\n      } = data;\n      this.indent = indent !== undefined ? indent : this.indent;\n      this.newline = newline !== undefined ? newline : this.newline;\n      if (!this.hiddenLockfile || !data.packages) return data; // add a few ms just to account for jitter\n\n      const lockTime = +(await stat(this.filename)).mtime + 10;\n      await assertNoNewer(this.path, data, lockTime); // all good!  hidden lockfile is the newest thing in here.\n\n      return data;\n    }).catch(er => {\n      const rel = relpath(this.path, this.filename);\n      this.log.verbose('shrinkwrap', `failed to load ${rel}`, er);\n      this.loadingError = er;\n      this.loadedFromDisk = false;\n      this.ancientLockfile = false;\n      return {};\n    }).then(lock => {\n      this.data = { ...lock,\n        lockfileVersion,\n        requires: true,\n        packages: lock.packages || {},\n        ...(this.hiddenLockfile ? {} : {\n          dependencies: lock.dependencies || {}\n        })\n      };\n      this.originalLockfileVersion = lock.lockfileVersion;\n      this.ancientLockfile = this.loadedFromDisk && !(lock.lockfileVersion >= 2) && !lock.requires; // load old lockfile deps into the packages listing\n\n      if (lock.dependencies && !lock.packages) {\n        return rpj(this.path + '/package.json').then(pkg => pkg, er => ({})).then(pkg => {\n          this[_loadAll]('', null, this.data);\n\n          this[_fixDependencies](pkg);\n        });\n      }\n    }).then(() => this);\n  }\n\n  [_loadAll](location, name, lock) {\n    // migrate a v1 package lock to the new format.\n    const meta = this[_metaFromLock](location, name, lock); // dependencies nested under a link are actually under the link target\n\n\n    if (meta.link) location = meta.resolved;\n\n    if (lock.dependencies) {\n      for (const [name, dep] of Object.entries(lock.dependencies)) {\n        const loc = location + (location ? '/' : '') + 'node_modules/' + name;\n\n        this[_loadAll](loc, name, dep);\n      }\n    }\n  } // v1 lockfiles track the optional/dev flags, but they don't tell us\n  // which thing had what kind of dep on what other thing, so we need\n  // to correct that now, or every link will be considered prod\n\n\n  [_fixDependencies](pkg) {\n    // we need the root package.json because legacy shrinkwraps just\n    // have requires:true at the root level, which is even less useful\n    // than merging all dep types into one object.\n    const root = this.data.packages[''];\n    pkgMetaKeys.forEach(key => {\n      const val = metaFieldFromPkg(pkg, key);\n      const k = key.replace(/^_/, '');\n      if (val) root[k] = val;\n    });\n\n    for (const [loc, meta] of Object.entries(this.data.packages)) {\n      if (!meta.requires || !loc) continue; // resolve each require to a meta entry\n      // if this node isn't optional, but the dep is, then it's an optionalDep\n      // likewise for dev deps.\n      // This isn't perfect, but it's a pretty good approximation, and at\n      // least gets us out of having all 'prod' edges, which throws off the\n      // buildIdealTree process\n\n      for (const [name, spec] of Object.entries(meta.requires)) {\n        const dep = this[_resolveMetaNode](loc, name); // this overwrites the false value set above\n\n\n        const depType = dep && dep.optional && !meta.optional ? 'optionalDependencies' :\n        /* istanbul ignore next - dev deps are only for the root level */\n        dep && dep.dev && !meta.dev ? 'devDependencies' // also land here if the dep just isn't in the tree, which maybe\n        // should be an error, since it means that the shrinkwrap is\n        // invalid, but we can't do much better without any info.\n        : 'dependencies';\n        meta[depType] = meta[depType] || {};\n        meta[depType][name] = spec;\n      }\n\n      delete meta.requires;\n    }\n  }\n\n  [_resolveMetaNode](loc, name) {\n    for (let path = loc; true; path = path.replace(/(^|\\/)[^/]*$/, '')) {\n      const check = `${path}${path ? '/' : ''}node_modules/${name}`;\n      if (this.data.packages[check]) return this.data.packages[check];\n      if (!path) break;\n    }\n\n    return null;\n  }\n\n  [_lockFromLoc](lock, path, i = 0) {\n    if (!lock) return null;\n    if (path[i] === '') i++;\n    if (i >= path.length) return lock;\n    if (!lock.dependencies) return null;\n    return this[_lockFromLoc](lock.dependencies[path[i]], path, i + 1);\n  } // pass in a path relative to the root path, or an absolute path,\n  // get back a /-normalized location based on root path.\n\n\n  [_pathToLoc](path) {\n    return relpath(this.path, resolve(this.path, path));\n  }\n\n  delete(nodePath) {\n    if (!this.data) throw new Error('run load() before getting or setting data');\n\n    const location = this[_pathToLoc](nodePath);\n\n    this[_awaitingUpdate].delete(location);\n\n    delete this.data.packages[location];\n    const path = location.split(/(?:^|\\/)node_modules\\//);\n    const name = path.pop();\n\n    const pLock = this[_lockFromLoc](this.data, path);\n\n    if (pLock && pLock.dependencies) delete pLock.dependencies[name];\n  }\n\n  get(nodePath) {\n    if (!this.data) throw new Error('run load() before getting or setting data');\n\n    const location = this[_pathToLoc](nodePath);\n\n    if (this[_awaitingUpdate].has(location)) this[_updateWaitingNode](location); // first try to get from the newer spot, which we know has\n    // all the things we need.\n\n    if (this.data.packages[location]) return this.data.packages[location]; // otherwise, fall back to the legacy metadata, and hope for the best\n    // get the node in the shrinkwrap corresponding to this spot\n\n    const path = location.split(/(?:^|\\/)node_modules\\//);\n    const name = path[path.length - 1];\n\n    const lock = this[_lockFromLoc](this.data, path);\n\n    return this[_metaFromLock](location, name, lock);\n  }\n\n  [_metaFromLock](location, name, lock) {\n    // This function tries as hard as it can to figure out the metadata\n    // from a lockfile which may be outdated or incomplete.  Since v1\n    // lockfiles used the \"version\" field to contain a variety of\n    // different possible types of data, this gets a little complicated.\n    if (!lock) return {}; // try to figure out a npm-package-arg spec from the lockfile entry\n    // This will return null if we could not get anything valid out of it.\n\n    const spec = specFromLock(name, lock, this.path);\n\n    if (spec.type === 'directory') {\n      // the \"version\" was a file: url to a non-tarball path\n      // this is a symlink dep.  We don't store much metadata\n      // about symlinks, just the target.\n      const target = relpath(this.path, spec.fetchSpec);\n      this.data.packages[location] = {\n        link: true,\n        resolved: target\n      }; // also save the link target, omitting version since we don't know\n      // what it is, but we know it isn't a link to itself!\n\n      if (!this.data.packages[target]) this[_metaFromLock](target, name, { ...lock,\n        version: null\n      });\n      return this.data.packages[location];\n    }\n\n    const meta = {}; // when calling loadAll we'll change these into proper dep objects\n\n    if (lock.requires && typeof lock.requires === 'object') meta.requires = lock.requires;\n    if (lock.optional) meta.optional = true;\n    if (lock.dev) meta.dev = true; // the root will typically have a name from the root project's\n    // package.json file.\n\n    if (location === '') meta.name = lock.name; // if we have integrity, save it now.\n\n    if (lock.integrity) meta.integrity = lock.integrity;\n\n    if (lock.version && !lock.integrity) {\n      // this is usually going to be a git url or symlink, but it could\n      // also be a registry dependency that did not have integrity at\n      // the time it was saved.\n      // Symlinks were already handled above, so that leaves git.\n      //\n      // For git, always save the full SSH url.  we'll actually fetch the\n      // tgz most of the time, since it's faster, but it won't work for\n      // private repos, and we can't get back to the ssh from the tgz,\n      // so we store the ssh instead.\n      // For unknown git hosts, just resolve to the raw spec in lock.version\n      if (spec.type === 'git') {\n        meta.resolved = consistentResolve(spec, this.path, this.path); // return early because there is nothing else we can do with this\n\n        return this.data.packages[location] = meta;\n      } else if (spec.registry) {\n        // registry dep that didn't save integrity.  grab the version, and\n        // fall through to pick up the resolved and potentially name.\n        meta.version = lock.version;\n      } // only other possible case is a tarball without integrity.\n      // fall through to do what we can with the filename later.\n\n    } // at this point, we know that the spec is either a registry dep\n    // (ie, version, because locking, which means a resolved url),\n    // or a remote dep, or file: url.  Remote deps and file urls\n    // have a fetchSpec equal to the fully resolved thing.\n    // Registry deps, we take what's in the lockfile.\n\n\n    if (lock.resolved || spec.type && !spec.registry) {\n      if (spec.registry) meta.resolved = lock.resolved;else if (spec.type === 'file') meta.resolved = consistentResolve(spec, this.path, this.path, true);else if (spec.fetchSpec) meta.resolved = spec.fetchSpec;\n    } // at this point, if still we don't have a version, do our best to\n    // infer it from the tarball url/file.  This works a surprising\n    // amount of the time, even though it's not guaranteed.\n\n\n    if (!meta.version) {\n      if (spec.type === 'file' || spec.type === 'remote') {\n        const fromTgz = versionFromTgz(spec.name, spec.fetchSpec) || versionFromTgz(spec.name, meta.resolved);\n\n        if (fromTgz) {\n          meta.version = fromTgz.version;\n          if (fromTgz.name !== name) meta.name = fromTgz.name;\n        }\n      } else if (spec.type === 'alias') {\n        meta.name = spec.subSpec.name;\n        meta.version = spec.subSpec.fetchSpec;\n      } else if (spec.type === 'version') meta.version = spec.fetchSpec; // ok, I did my best!  good luck!\n\n    }\n\n    if (lock.bundled) meta.inBundle = true; // save it for next time\n\n    return this.data.packages[location] = meta;\n  }\n\n  add(node) {\n    if (!this.data) throw new Error('run load() before getting or setting data'); // will be actually updated on read\n\n    const loc = relpath(this.path, node.path);\n    if (node.path === this.path) this.tree = node; // if we have metadata about this node, and it's a match, then\n    // try to decorate it.\n\n    if (node.resolved === null || node.integrity === null) {\n      const {\n        resolved,\n        integrity,\n        hasShrinkwrap\n      } = this.get(node.path);\n      const pathFixed = !resolved ? null : !/^file:/.test(resolved) ? resolved // resolve onto the metadata path\n      : `file:${resolve(this.path, resolved.substr(5))}`; // if we have one, only set the other if it matches\n      // otherwise it could be for a completely different thing.\n\n      const resolvedOk = !resolved || !node.resolved || node.resolved === pathFixed;\n      const integrityOk = !integrity || !node.integrity || node.integrity === integrity;\n\n      if ((resolved || integrity) && resolvedOk && integrityOk) {\n        node.resolved = node.resolved || pathFixed || null;\n        node.integrity = node.integrity || integrity || null;\n        node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || false;\n      } else {\n        // try to read off the package or node itself\n        const {\n          resolved,\n          integrity,\n          hasShrinkwrap\n        } = Shrinkwrap.metaFromNode(node, this.path);\n        node.resolved = node.resolved || resolved || null;\n        node.integrity = node.integrity || integrity || null;\n        node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || false;\n      }\n    }\n\n    this[_awaitingUpdate].set(loc, node);\n  }\n\n  addEdge(edge) {\n    if (!this.yarnLock || !edge.valid) return;\n    const {\n      to: node\n    } = edge; // if it's already set up, nothing to do\n\n    if (node.resolved !== null && node.integrity !== null) return; // if the yarn lock is empty, nothing to do\n\n    if (!this.yarnLock.entries || !this.yarnLock.entries.size) return; // we relativize the path here because that's how it shows up in the lock\n    // XXX how is this different from pathFixed above??\n\n    const pathFixed = !node.resolved ? null : !/file:/.test(node.resolved) ? node.resolved : consistentResolve(node.resolved, node.path, this.path, true);\n    const spec = npa(`${node.name}@${edge.spec}`);\n    const entry = this.yarnLock.entries.get(`${node.name}@${edge.spec}`);\n    if (!entry || mismatch(node.version, entry.version) || mismatch(node.integrity, entry.integrity) || mismatch(pathFixed, entry.resolved)) return;\n    if (entry.resolved && yarnRegRe.test(entry.resolved) && spec.registry) entry.resolved = entry.resolved.replace(yarnRegRe, 'https://registry.npmjs.org/');\n    node.integrity = node.integrity || entry.integrity || null;\n    node.resolved = node.resolved || consistentResolve(entry.resolved, this.path, node.path) || null;\n\n    this[_awaitingUpdate].set(relpath(this.path, node.path), node);\n  }\n\n  [_updateWaitingNode](loc) {\n    const node = this[_awaitingUpdate].get(loc);\n\n    this[_awaitingUpdate].delete(loc);\n\n    this.data.packages[loc] = Shrinkwrap.metaFromNode(node, this.path);\n  }\n\n  commit() {\n    if (this.tree) {\n      if (this.yarnLock) this.yarnLock.fromTree(this.tree);\n      const root = Shrinkwrap.metaFromNode(this.tree.target || this.tree, this.path);\n      this.data.packages = {};\n      if (Object.keys(root).length) this.data.packages[''] = root;\n\n      for (const node of this.tree.root.inventory.values()) {\n        // only way this.tree is not root is if the root is a link to it\n        if (node === this.tree || node.isRoot || node.location === '') continue;\n        const loc = relpath(this.path, node.path);\n        this.data.packages[loc] = Shrinkwrap.metaFromNode(node, this.path);\n      }\n    } else if (this[_awaitingUpdate].size > 0) {\n      for (const loc of this[_awaitingUpdate].keys()) this[_updateWaitingNode](loc);\n    } // hidden lockfiles don't include legacy metadata or a root entry\n\n\n    if (this.hiddenLockfile) {\n      delete this.data.packages[''];\n      delete this.data.dependencies;\n    } else if (this.tree) this[_buildLegacyLockfile](this.tree, this.data);\n\n    return this.data;\n  }\n\n  [_buildLegacyLockfile](node, lock, path = []) {\n    if (node === this.tree) {\n      // the root node\n      lock.name = node.package.name || node.name;\n      if (node.version) lock.version = node.version;\n    } // npm v6 and before tracked 'from', meaning \"the request that led\n    // to this package being installed\".  However, that's inherently\n    // racey and non-deterministic in a world where deps are deduped\n    // ahead of fetch time.  In order to maintain backwards compatibility\n    // with v6 in the lockfile, we do this trick where we pick a valid\n    // dep link out of the edgesIn set.  Choose the edge with the fewest\n    // number of `node_modules` sections in the requestor path, and then\n    // lexically sort afterwards.\n\n\n    const edge = [...node.edgesIn].filter(e => e.valid).sort((a, b) => {\n      const aloc = a.from.location.split('node_modules');\n      const bloc = b.from.location.split('node_modules');\n      /* istanbul ignore next - sort calling order is indeterminate */\n\n      return aloc.length > bloc.length ? 1 : bloc.length > aloc.length ? -1 : aloc[aloc.length - 1].localeCompare(bloc[bloc.length - 1]);\n    })[0];\n    const res = consistentResolve(node.resolved, this.path, this.path, true);\n    const rSpec = specFromResolved(res); // if we don't have anything (ie, it's extraneous) then use the resolved\n    // value as if that was where we got it from, since at least it's true.\n    // if we don't have either, just an empty object so nothing matches below.\n    // This will effectively just save the version and resolved, as if it's\n    // a standard version/range dep, which is a reasonable default.\n\n    const spec = !edge ? rSpec : npa.resolve(node.name, edge.spec, edge.from.realpath);\n    if (node.target) lock.version = `file:${relpath(this.path, node.realpath)}`;else if (spec && (spec.type === 'file' || spec.type === 'remote')) lock.version = spec.saveSpec;else if (spec && spec.type === 'git' || rSpec.type === 'git') {\n      lock.version = node.resolved;\n      /* istanbul ignore else - don't think there are any cases where a git\n       * spec (or indeed, ANY npa spec) doesn't have a .raw member */\n\n      if (spec.raw) lock.from = spec.raw;\n    } else if (!node.isRoot && node.package && node.package.name && node.package.name !== node.name) lock.version = `npm:${node.package.name}@${node.version}`;else if (node.package && node.version) lock.version = node.version;\n    if (node.inDepBundle) lock.bundled = true; // when we didn't resolve to git, file, or dir, and didn't request\n    // git, file, dir, or remote, then the resolved value is necessary.\n\n    if (node.resolved && !node.target && rSpec.type !== 'git' && rSpec.type !== 'file' && rSpec.type !== 'directory' && spec.type !== 'directory' && spec.type !== 'git' && spec.type !== 'file' && spec.type !== 'remote') lock.resolved = node.resolved;\n    if (node.integrity) lock.integrity = node.integrity;\n    if (node.extraneous) lock.extraneous = true;else if (!node.isLink) {\n      if (node.peer) lock.peer = true;\n      if (node.devOptional && !node.dev && !node.optional) lock.devOptional = true;\n      if (node.dev) lock.dev = true;\n      if (node.optional) lock.optional = true;\n    }\n    const depender = node.target || node;\n\n    if (depender.edgesOut.size > 0) {\n      if (node !== this.tree) {\n        lock.requires = [...depender.edgesOut.entries()].reduce((set, [k, v]) => {\n          // omit peer deps from legacy lockfile requires field, because\n          // npm v6 doesn't handle peer deps, and this triggers some bad\n          // behavior if the dep can't be found in the dependencies list.\n          const {\n            spec,\n            peer\n          } = v;\n          if (peer) return set;\n\n          if (spec.startsWith('file:')) {\n            // turn absolute file: paths into relative paths from the node\n            // this especially shows up with workspace edges when the root\n            // node is also a workspace in the set.\n            const p = resolve(node.realpath, spec.substr('file:'.length));\n            set[k] = `file:${relpath(node.realpath, p)}`;\n          } else set[k] = spec;\n\n          return set;\n        }, {});\n      } else lock.requires = true;\n    } // now we walk the children, putting them in the 'dependencies' object\n\n\n    const {\n      children\n    } = node.target || node;\n    if (!children.size) delete lock.dependencies;else {\n      const kidPath = [...path, node.realpath];\n      const dependencies = {}; // skip any that are already in the descent path, so cyclical link\n      // dependencies don't blow up with ELOOP.\n\n      let found = false;\n\n      for (const [name, kid] of children.entries()) {\n        if (path.includes(kid.realpath)) continue;\n        dependencies[name] = this[_buildLegacyLockfile](kid, {}, kidPath);\n        found = true;\n      }\n\n      if (found) lock.dependencies = dependencies;\n    }\n    return lock;\n  }\n\n  save(options = {}) {\n    if (!this.data) throw new Error('run load() before saving data');\n    const {\n      format = true\n    } = options;\n    const defaultIndent = this.indent || 2;\n    const indent = format === true ? defaultIndent : format || 0;\n    const eol = format ? this.newline || '\\n' : '';\n    const data = this.commit();\n    const json = stringify(data, swKeyOrder, indent).replace(/\\n/g, eol);\n    return Promise.all([writeFile(this.filename, json).catch(er => {\n      if (this.hiddenLockfile) {\n        // well, we did our best.\n        // if we reify, and there's nothing there, then it might be lacking\n        // a node_modules folder, but then the lockfile is not important.\n        // Remove the file, so that in case there WERE deps, but we just\n        // failed to update the file for some reason, it's not out of sync.\n        return rimraf(this.filename);\n      }\n\n      throw er;\n    }), this.yarnLock && this.yarnLock.entries.size && writeFile(this.path + '/yarn.lock', this.yarnLock.toString())]);\n  }\n\n}\n\nmodule.exports = Shrinkwrap;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/@npmcli/arborist/lib/shrinkwrap.js"],"names":["lockfileVersion","mismatch","a","b","procLog","require","YarnLock","promisify","rimraf","fs","readFile","writeFile","stat","readdir_","readdir","readlink","lstat","path","opt","withFileTypes","ents","Promise","all","map","ent","Object","assign","name","resolve","basename","specFromLock","versionFromTgz","npa","rpj","parseJSON","stringify","swKeyOrder","yarnRegRe","npmRegRe","specFromResolved","resolved","er","relpath","consistentResolve","maybeReadFile","file","then","d","code","maybeStatFile","st","isFile","pkgMetaKeys","nodeMetaKeys","metaFieldFromPkg","pkg","key","val","type","keys","length","assertNoNewer","data","lockTime","dir","seen","base","isNM","isScope","charAt","isParent","rel","dirTime","mtime","packages","add","Set","parent","children","isDirectory","catch","child","test","isSymbolicLink","target","tstat","has","loc","_awaitingUpdate","Symbol","_updateWaitingNode","_lockFromLoc","_pathToLoc","_loadAll","_metaFromLock","_resolveMetaNode","_fixDependencies","_buildLegacyLockfile","_filenameSet","_maybeRead","_maybeStat","Shrinkwrap","load","options","keyOrder","reset","s","sw","lock","filename","hiddenLockfile","shrinkwrapOnly","loadedFromDisk","metaFromNode","node","isLink","realpath","link","meta","forEach","package","replace","pname","isTop","devDependencies","extraneous","peer","dev","optional","devOptional","constructor","indent","newline","log","Map","tree","yarnLock","loadingError","checkYarnLock","spec","useYarnLock","fromYarn","entries","get","raw","version","integrity","isYarnReg","registry","isnpmReg","isReg","tgz","yspec","requires","dependencies","fn","slice","yarn","parse","_","for","undefined","verbose","ancientLockfile","originalLockfileVersion","location","dep","root","k","depType","check","i","delete","nodePath","Error","split","pop","pLock","fetchSpec","fromTgz","subSpec","bundled","inBundle","hasShrinkwrap","pathFixed","substr","resolvedOk","integrityOk","set","addEdge","edge","valid","to","size","entry","commit","fromTree","inventory","values","isRoot","edgesIn","filter","e","sort","aloc","from","bloc","localeCompare","res","rSpec","saveSpec","inDepBundle","depender","edgesOut","reduce","v","startsWith","p","kidPath","found","kid","includes","save","format","defaultIndent","eol","json","toString","module","exports"],"mappings":"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","sourcesContent":["// a module that manages a shrinkwrap file (npm-shrinkwrap.json or\n// package-lock.json).\n\n// Increment whenever the lockfile version updates\n// v1 - npm <=6\n// v2 - arborist v1, npm v7, backwards compatible with v1, add 'packages'\n// v3 will drop the 'dependencies' field, backwards comp with v2, not v1\n//\n// We cannot bump to v3 until npm v6 is out of common usage, and\n// definitely not before npm v8.\n\nconst lockfileVersion = 2\n\n// for comparing nodes to yarn.lock entries\nconst mismatch = (a, b) => a && b && a !== b\n\n// this.tree => the root node for the tree (ie, same path as this)\n// - Set the first time we do `this.add(node)` for a path matching this.path\n//\n// this.add(node) =>\n// - decorate the node with the metadata we have, if we have it, and it matches\n// - add to the map of nodes needing to be committed, so that subsequent\n// changes are captured when we commit that location's metadata.\n//\n// this.commit() =>\n// - commit all nodes awaiting update to their metadata entries\n// - re-generate this.data and this.yarnLock based on this.tree\n//\n// Note that between this.add() and this.commit(), `this.data` will be out of\n// date!  Always call `commit()` before relying on it.\n//\n// After calling this.commit(), any nodes not present in the tree will have\n// been removed from the shrinkwrap data as well.\n\nconst procLog = require('./proc-log.js')\nconst YarnLock = require('./yarn-lock.js')\nconst {promisify} = require('util')\nconst rimraf = promisify(require('rimraf'))\nconst fs = require('fs')\nconst readFile = promisify(fs.readFile)\nconst writeFile = promisify(fs.writeFile)\nconst stat = promisify(fs.stat)\nconst readdir_ = promisify(fs.readdir)\nconst readlink = promisify(fs.readlink)\n\n// XXX remove when drop support for node v10\nconst lstat = promisify(fs.lstat)\n/* istanbul ignore next - version specific polyfill */\nconst readdir = async (path, opt) => {\n  if (!opt || !opt.withFileTypes)\n    return readdir_(path, opt)\n  const ents = await readdir_(path, opt)\n  if (typeof ents[0] === 'string') {\n    return Promise.all(ents.map(async ent => {\n      return Object.assign(await lstat(path + '/' + ent), { name: ent })\n    }))\n  }\n  return ents\n}\n\nconst { resolve, basename } = require('path')\nconst specFromLock = require('./spec-from-lock.js')\nconst versionFromTgz = require('./version-from-tgz.js')\nconst npa = require('npm-package-arg')\nconst rpj = require('read-package-json-fast')\nconst parseJSON = require('parse-conflict-json')\n\nconst stringify = require('json-stringify-nice')\nconst swKeyOrder = [\n  'name',\n  'version',\n  'lockfileVersion',\n  'resolved',\n  'integrity',\n  'requires',\n  'packages',\n  'dependencies',\n]\n\n// used to rewrite from yarn registry to npm registry\nconst yarnRegRe = /^https?:\\/\\/registry.yarnpkg.com\\//\nconst npmRegRe = /^https?:\\/\\/registry.npmjs.org\\//\n\n// sometimes resolved: is weird or broken, or something npa can't handle\nconst specFromResolved = resolved => {\n  try {\n    return npa(resolved)\n  } catch (er) {\n    return {}\n  }\n}\n\nconst relpath = require('./relpath.js')\n\nconst consistentResolve = require('./consistent-resolve.js')\n\nconst maybeReadFile = file => {\n  return readFile(file, 'utf8').then(d => d, er => {\n    /* istanbul ignore else - can't test without breaking module itself */\n    if (er.code === 'ENOENT')\n      return ''\n    else\n      throw er\n  })\n}\n\nconst maybeStatFile = file => {\n  return stat(file).then(st => st.isFile(), er => {\n    /* istanbul ignore else - can't test without breaking module itself */\n    if (er.code === 'ENOENT')\n      return null\n    else\n      throw er\n  })\n}\n\nconst pkgMetaKeys = [\n  // note: name is included if necessary, for alias packages\n  'version',\n  'dependencies',\n  'peerDependencies',\n  'peerDependenciesMeta',\n  'optionalDependencies',\n  'bundleDependencies',\n  'acceptDependencies',\n  'funding',\n  'engines',\n  'os',\n  'cpu',\n  '_integrity',\n  'license',\n  '_hasShrinkwrap',\n  'hasInstallScript',\n  'bin',\n  'deprecated',\n  'workspaces',\n]\n\nconst nodeMetaKeys = [\n  'integrity',\n  'inBundle',\n  'hasShrinkwrap',\n  'hasInstallScript',\n]\n\nconst metaFieldFromPkg = (pkg, key) => {\n  const val = pkg[key]\n  // get the license type, not an object\n  return (key === 'license' && val && typeof val === 'object' && val.type)\n    ? val.type\n    // skip empty objects and falsey values\n    : (val && !(typeof val === 'object' && !Object.keys(val).length)) ? val\n    : null\n}\n\n// check to make sure that there are no packages newer than the hidden lockfile\nconst assertNoNewer = async (path, data, lockTime, dir = path, seen = null) => {\n  const base = basename(dir)\n  const isNM = dir !== path && base === 'node_modules'\n  const isScope = dir !== path && !isNM && base.charAt(0) === '@'\n  const isParent = dir === path || isNM || isScope\n\n  const rel = relpath(path, dir)\n  if (dir !== path) {\n    const dirTime = (await stat(dir)).mtime\n    if (dirTime > lockTime)\n      throw 'out of date, updated: ' + rel\n    if (!isScope && !isNM && !data.packages[rel])\n      throw 'missing from lockfile: ' + rel\n    seen.add(rel)\n  } else\n    seen = new Set([rel])\n\n  const parent = isParent ? dir : resolve(dir, 'node_modules')\n  const children = dir === path\n    ? Promise.resolve([{name: 'node_modules', isDirectory: () => true }])\n    : readdir(parent, { withFileTypes: true })\n\n  return children.catch(() => [])\n    .then(ents => Promise.all(ents.map(async ent => {\n      const child = resolve(parent, ent.name)\n      if (ent.isDirectory() && !/^\\./.test(ent.name))\n        await assertNoNewer(path, data, lockTime, child, seen)\n      else if (ent.isSymbolicLink()) {\n        const target = resolve(parent, await readlink(child))\n        const tstat = await stat(target).catch(() => null)\n        seen.add(relpath(path, child))\n        if (tstat && tstat.isDirectory() && !seen.has(relpath(path, target)))\n          await assertNoNewer(path, data, lockTime, target, seen)\n      }\n    })))\n    .then(() => {\n      if (dir !== path)\n        return\n\n      // assert that all the entries in the lockfile were seen\n      for (const loc of new Set(Object.keys(data.packages))) {\n        if (!seen.has(loc))\n          throw 'missing from node_modules: ' + loc\n      }\n    })\n}\n\nconst _awaitingUpdate = Symbol('_awaitingUpdate')\nconst _updateWaitingNode = Symbol('_updateWaitingNode')\nconst _lockFromLoc = Symbol('_lockFromLoc')\nconst _pathToLoc = Symbol('_pathToLoc')\nconst _loadAll = Symbol('_loadAll')\nconst _metaFromLock = Symbol('_metaFromLock')\nconst _resolveMetaNode = Symbol('_resolveMetaNode')\nconst _fixDependencies = Symbol('_fixDependencies')\nconst _buildLegacyLockfile = Symbol('_buildLegacyLockfile')\nconst _filenameSet = Symbol('_filenameSet')\nconst _maybeRead = Symbol('_maybeRead')\nconst _maybeStat = Symbol('_maybeStat')\nclass Shrinkwrap {\n  static load (options) {\n    return new Shrinkwrap(options).load()\n  }\n\n  static get keyOrder () {\n    return swKeyOrder\n  }\n\n  static reset (options) {\n    // still need to know if it was loaded from the disk, but don't\n    // bother reading it if we're gonna just throw it away.\n    const s = new Shrinkwrap(options)\n    s.reset()\n\n    return s[_maybeStat]().then(([sw, lock]) => {\n      s.filename = resolve(s.path,\n        (s.hiddenLockfile ? 'node_modules/.package-lock'\n        : s.shrinkwrapOnly || sw ? 'npm-shrinkwrap'\n        : 'package-lock') + '.json')\n      s.loadedFromDisk = !!(sw || lock)\n      s.type = basename(s.filename)\n      return s\n    })\n  }\n\n  static metaFromNode (node, path) {\n    if (node.isLink) {\n      return {\n        resolved: relpath(path, node.realpath),\n        link: true,\n      }\n    }\n\n    const meta = {}\n    pkgMetaKeys.forEach(key => {\n      const val = metaFieldFromPkg(node.package, key)\n      if (val)\n        meta[key.replace(/^_/, '')] = val\n    })\n    // we only include name if different from the node path name\n    const pname = node.package.name\n    if (pname && pname !== node.name)\n      meta.name = pname\n\n    if (node.isTop && node.package.devDependencies)\n      meta.devDependencies = node.package.devDependencies\n\n    nodeMetaKeys.forEach(key => {\n      if (node[key])\n        meta[key] = node[key]\n    })\n\n    const resolved = consistentResolve(node.resolved, node.path, path, true)\n    if (resolved)\n      meta.resolved = resolved\n\n    if (node.extraneous)\n      meta.extraneous = true\n    else {\n      if (node.peer)\n        meta.peer = true\n      if (node.dev)\n        meta.dev = true\n      if (node.optional)\n        meta.optional = true\n      if (node.devOptional && !node.dev && !node.optional)\n        meta.devOptional = true\n    }\n    return meta\n  }\n\n  constructor (options = {}) {\n    const {\n      path,\n      indent = 2,\n      newline = '\\n',\n      shrinkwrapOnly = false,\n      hiddenLockfile = false,\n      log = procLog,\n    } = options\n\n    this.log = log\n    this[_awaitingUpdate] = new Map()\n    this.tree = null\n    this.path = resolve(path || '.')\n    this.filename = null\n    this.data = null\n    this.indent = indent\n    this.newline = newline\n    this.loadedFromDisk = false\n    this.type = null\n    this.yarnLock = null\n    this.hiddenLockfile = hiddenLockfile\n    this.loadingError = null\n    // only load npm-shrinkwrap.json in dep trees, not package-lock\n    this.shrinkwrapOnly = shrinkwrapOnly\n  }\n\n  // check to see if a spec is present in the yarn.lock file, and if so,\n  // if we should use it, and what it should resolve to.  This is only\n  // done when we did not load a shrinkwrap from disk.  Also, decorate\n  // the options object if provided with the resolved and integrity that\n  // we expect.\n  checkYarnLock (spec, options = {}) {\n    spec = npa(spec)\n    const { yarnLock, loadedFromDisk } = this\n    const useYarnLock = yarnLock && !loadedFromDisk\n    const fromYarn = useYarnLock && yarnLock.entries.get(spec.raw)\n    if (fromYarn && fromYarn.version) {\n      // if it's the yarn or npm default registry, use the version as\n      // our effective spec.  if it's any other kind of thing, use that.\n      const {resolved, version, integrity} = fromYarn\n      const isYarnReg = spec.registry && yarnRegRe.test(resolved)\n      const isnpmReg = spec.registry && !isYarnReg && npmRegRe.test(resolved)\n      const isReg = isnpmReg || isYarnReg\n      // don't use the simple version if the \"registry\" url is\n      // something else entirely!\n      const tgz = isReg && versionFromTgz(spec.name, resolved) || {}\n      const yspec = tgz.name === spec.name && tgz.version === version ? version\n        : isReg && tgz.name && tgz.version ? `npm:${tgz.name}@${tgz.version}`\n        : resolved\n      if (yspec) {\n        options.resolved = resolved.replace(yarnRegRe, 'https://registry.npmjs.org/')\n        options.integrity = integrity\n        return npa(`${spec.name}@${yspec}`)\n      }\n    }\n    return spec\n  }\n\n  // throw away the shrinkwrap data so we can start fresh\n  // still worth doing a load() first so we know which files to write.\n  reset () {\n    this.tree = null\n    this[_awaitingUpdate] = new Map()\n    this.data = {\n      lockfileVersion,\n      requires: true,\n      packages: {},\n      dependencies: {},\n    }\n  }\n\n  [_filenameSet] () {\n    return this.shrinkwrapOnly ? [\n      this.path + '/npm-shrinkwrap.json',\n    ] : this.hiddenLockfile ? [\n      null,\n      this.path + '/node_modules/.package-lock.json',\n    ] : [\n      this.path + '/npm-shrinkwrap.json',\n      this.path + '/package-lock.json',\n      this.path + '/yarn.lock',\n    ]\n  }\n\n  [_maybeRead] () {\n    return Promise.all(this[_filenameSet]().map(fn => fn && maybeReadFile(fn)))\n  }\n\n  [_maybeStat] () {\n    // throw away yarn, we only care about lock or shrinkwrap when checking\n    // this way, since we're not actually loading the full lock metadata\n    return Promise.all(this[_filenameSet]().slice(0, 2)\n      .map(fn => fn && maybeStatFile(fn)))\n  }\n\n  load () {\n    // we don't need to load package-lock.json except for top of tree nodes,\n    // only npm-shrinkwrap.json.\n    return this[_maybeRead]().then(([sw, lock, yarn]) => {\n      const data = sw || lock || ''\n\n      // use shrinkwrap only for deps, otherwise prefer package-lock\n      // and ignore npm-shrinkwrap if both are present.\n      // TODO: emit a warning here or something if both are present.\n      this.filename = resolve(this.path,\n        (this.hiddenLockfile ? 'node_modules/.package-lock'\n        : this.shrinkwrapOnly || sw ? 'npm-shrinkwrap'\n        : 'package-lock') + '.json')\n\n      this.type = basename(this.filename)\n      this.loadedFromDisk = !!data\n\n      if (yarn) {\n        this.yarnLock = new YarnLock()\n        // ignore invalid yarn data.  we'll likely clobber it later anyway.\n        try {\n          this.yarnLock.parse(yarn)\n        } catch (_) {}\n      }\n\n      return data ? parseJSON(data) : {}\n    }).then(async data => {\n      // don't use detect-indent, just pick the first line.\n      // if the file starts with {\" then we have an indent of '', ie, none\n      // which will default to 2 at save time.\n      const {\n        [Symbol.for('indent')]: indent,\n        [Symbol.for('newline')]: newline,\n      } = data\n      this.indent = indent !== undefined ? indent : this.indent\n      this.newline = newline !== undefined ? newline : this.newline\n\n      if (!this.hiddenLockfile || !data.packages)\n        return data\n\n      // add a few ms just to account for jitter\n      const lockTime = +(await stat(this.filename)).mtime + 10\n      await assertNoNewer(this.path, data, lockTime)\n\n      // all good!  hidden lockfile is the newest thing in here.\n      return data\n    }).catch(er => {\n      const rel = relpath(this.path, this.filename)\n      this.log.verbose('shrinkwrap', `failed to load ${rel}`, er)\n      this.loadingError = er\n      this.loadedFromDisk = false\n      this.ancientLockfile = false\n      return {}\n    }).then(lock => {\n      this.data = {\n        ...lock,\n        lockfileVersion,\n        requires: true,\n        packages: lock.packages || {},\n        ...(this.hiddenLockfile ? {} : {dependencies: lock.dependencies || {}}),\n      }\n      this.originalLockfileVersion = lock.lockfileVersion\n      this.ancientLockfile = this.loadedFromDisk &&\n        !(lock.lockfileVersion >= 2) && !lock.requires\n\n      // load old lockfile deps into the packages listing\n      if (lock.dependencies && !lock.packages) {\n        return rpj(this.path + '/package.json').then(pkg => pkg, er => ({}))\n          .then(pkg => {\n            this[_loadAll]('', null, this.data)\n            this[_fixDependencies](pkg)\n          })\n      }\n    })\n      .then(() => this)\n  }\n\n  [_loadAll] (location, name, lock) {\n    // migrate a v1 package lock to the new format.\n    const meta = this[_metaFromLock](location, name, lock)\n    // dependencies nested under a link are actually under the link target\n    if (meta.link)\n      location = meta.resolved\n    if (lock.dependencies) {\n      for (const [name, dep] of Object.entries(lock.dependencies)) {\n        const loc = location + (location ? '/' : '') + 'node_modules/' + name\n        this[_loadAll](loc, name, dep)\n      }\n    }\n  }\n\n  // v1 lockfiles track the optional/dev flags, but they don't tell us\n  // which thing had what kind of dep on what other thing, so we need\n  // to correct that now, or every link will be considered prod\n  [_fixDependencies] (pkg) {\n    // we need the root package.json because legacy shrinkwraps just\n    // have requires:true at the root level, which is even less useful\n    // than merging all dep types into one object.\n    const root = this.data.packages['']\n    pkgMetaKeys.forEach(key => {\n      const val = metaFieldFromPkg(pkg, key)\n      const k = key.replace(/^_/, '')\n      if (val)\n        root[k] = val\n    })\n\n    for (const [loc, meta] of Object.entries(this.data.packages)) {\n      if (!meta.requires || !loc)\n        continue\n\n      // resolve each require to a meta entry\n      // if this node isn't optional, but the dep is, then it's an optionalDep\n      // likewise for dev deps.\n      // This isn't perfect, but it's a pretty good approximation, and at\n      // least gets us out of having all 'prod' edges, which throws off the\n      // buildIdealTree process\n      for (const [name, spec] of Object.entries(meta.requires)) {\n        const dep = this[_resolveMetaNode](loc, name)\n        // this overwrites the false value set above\n        const depType = dep && dep.optional && !meta.optional\n          ? 'optionalDependencies'\n          : /* istanbul ignore next - dev deps are only for the root level */\n          dep && dep.dev && !meta.dev ? 'devDependencies'\n          // also land here if the dep just isn't in the tree, which maybe\n          // should be an error, since it means that the shrinkwrap is\n          // invalid, but we can't do much better without any info.\n          : 'dependencies'\n        meta[depType] = meta[depType] || {}\n        meta[depType][name] = spec\n      }\n      delete meta.requires\n    }\n  }\n\n  [_resolveMetaNode] (loc, name) {\n    for (let path = loc; true; path = path.replace(/(^|\\/)[^/]*$/, '')) {\n      const check = `${path}${path ? '/' : ''}node_modules/${name}`\n      if (this.data.packages[check])\n        return this.data.packages[check]\n\n      if (!path)\n        break\n    }\n    return null\n  }\n\n  [_lockFromLoc] (lock, path, i = 0) {\n    if (!lock)\n      return null\n\n    if (path[i] === '')\n      i++\n\n    if (i >= path.length)\n      return lock\n\n    if (!lock.dependencies)\n      return null\n\n    return this[_lockFromLoc](lock.dependencies[path[i]], path, i + 1)\n  }\n\n  // pass in a path relative to the root path, or an absolute path,\n  // get back a /-normalized location based on root path.\n  [_pathToLoc] (path) {\n    return relpath(this.path, resolve(this.path, path))\n  }\n\n  delete (nodePath) {\n    if (!this.data)\n      throw new Error('run load() before getting or setting data')\n    const location = this[_pathToLoc](nodePath)\n    this[_awaitingUpdate].delete(location)\n\n    delete this.data.packages[location]\n    const path = location.split(/(?:^|\\/)node_modules\\//)\n    const name = path.pop()\n    const pLock = this[_lockFromLoc](this.data, path)\n    if (pLock && pLock.dependencies)\n      delete pLock.dependencies[name]\n  }\n\n  get (nodePath) {\n    if (!this.data)\n      throw new Error('run load() before getting or setting data')\n\n    const location = this[_pathToLoc](nodePath)\n    if (this[_awaitingUpdate].has(location))\n      this[_updateWaitingNode](location)\n\n    // first try to get from the newer spot, which we know has\n    // all the things we need.\n    if (this.data.packages[location])\n      return this.data.packages[location]\n\n    // otherwise, fall back to the legacy metadata, and hope for the best\n    // get the node in the shrinkwrap corresponding to this spot\n    const path = location.split(/(?:^|\\/)node_modules\\//)\n    const name = path[path.length - 1]\n    const lock = this[_lockFromLoc](this.data, path)\n\n    return this[_metaFromLock](location, name, lock)\n  }\n\n  [_metaFromLock] (location, name, lock) {\n    // This function tries as hard as it can to figure out the metadata\n    // from a lockfile which may be outdated or incomplete.  Since v1\n    // lockfiles used the \"version\" field to contain a variety of\n    // different possible types of data, this gets a little complicated.\n    if (!lock)\n      return {}\n\n    // try to figure out a npm-package-arg spec from the lockfile entry\n    // This will return null if we could not get anything valid out of it.\n    const spec = specFromLock(name, lock, this.path)\n\n    if (spec.type === 'directory') {\n      // the \"version\" was a file: url to a non-tarball path\n      // this is a symlink dep.  We don't store much metadata\n      // about symlinks, just the target.\n      const target = relpath(this.path, spec.fetchSpec)\n      this.data.packages[location] = {\n        link: true,\n        resolved: target,\n      }\n      // also save the link target, omitting version since we don't know\n      // what it is, but we know it isn't a link to itself!\n      if (!this.data.packages[target])\n        this[_metaFromLock](target, name, { ...lock, version: null })\n      return this.data.packages[location]\n    }\n\n    const meta = {}\n    // when calling loadAll we'll change these into proper dep objects\n    if (lock.requires && typeof lock.requires === 'object')\n      meta.requires = lock.requires\n\n    if (lock.optional)\n      meta.optional = true\n    if (lock.dev)\n      meta.dev = true\n\n    // the root will typically have a name from the root project's\n    // package.json file.\n    if (location === '')\n      meta.name = lock.name\n\n    // if we have integrity, save it now.\n    if (lock.integrity)\n      meta.integrity = lock.integrity\n\n    if (lock.version && !lock.integrity) {\n      // this is usually going to be a git url or symlink, but it could\n      // also be a registry dependency that did not have integrity at\n      // the time it was saved.\n      // Symlinks were already handled above, so that leaves git.\n      //\n      // For git, always save the full SSH url.  we'll actually fetch the\n      // tgz most of the time, since it's faster, but it won't work for\n      // private repos, and we can't get back to the ssh from the tgz,\n      // so we store the ssh instead.\n      // For unknown git hosts, just resolve to the raw spec in lock.version\n      if (spec.type === 'git') {\n        meta.resolved = consistentResolve(spec, this.path, this.path)\n\n        // return early because there is nothing else we can do with this\n        return this.data.packages[location] = meta\n      } else if (spec.registry) {\n        // registry dep that didn't save integrity.  grab the version, and\n        // fall through to pick up the resolved and potentially name.\n        meta.version = lock.version\n      }\n      // only other possible case is a tarball without integrity.\n      // fall through to do what we can with the filename later.\n    }\n\n    // at this point, we know that the spec is either a registry dep\n    // (ie, version, because locking, which means a resolved url),\n    // or a remote dep, or file: url.  Remote deps and file urls\n    // have a fetchSpec equal to the fully resolved thing.\n    // Registry deps, we take what's in the lockfile.\n    if (lock.resolved || (spec.type && !spec.registry)) {\n      if (spec.registry)\n        meta.resolved = lock.resolved\n      else if (spec.type === 'file')\n        meta.resolved = consistentResolve(spec, this.path, this.path, true)\n      else if (spec.fetchSpec)\n        meta.resolved = spec.fetchSpec\n    }\n\n    // at this point, if still we don't have a version, do our best to\n    // infer it from the tarball url/file.  This works a surprising\n    // amount of the time, even though it's not guaranteed.\n    if (!meta.version) {\n      if (spec.type === 'file' || spec.type === 'remote') {\n        const fromTgz = versionFromTgz(spec.name, spec.fetchSpec) ||\n          versionFromTgz(spec.name, meta.resolved)\n        if (fromTgz) {\n          meta.version = fromTgz.version\n          if (fromTgz.name !== name)\n            meta.name = fromTgz.name\n        }\n      } else if (spec.type === 'alias') {\n        meta.name = spec.subSpec.name\n        meta.version = spec.subSpec.fetchSpec\n      } else if (spec.type === 'version')\n        meta.version = spec.fetchSpec\n      // ok, I did my best!  good luck!\n    }\n\n    if (lock.bundled)\n      meta.inBundle = true\n\n    // save it for next time\n    return this.data.packages[location] = meta\n  }\n\n  add (node) {\n    if (!this.data)\n      throw new Error('run load() before getting or setting data')\n\n    // will be actually updated on read\n    const loc = relpath(this.path, node.path)\n    if (node.path === this.path)\n      this.tree = node\n\n    // if we have metadata about this node, and it's a match, then\n    // try to decorate it.\n    if (node.resolved === null || node.integrity === null) {\n      const {\n        resolved,\n        integrity,\n        hasShrinkwrap,\n      } = this.get(node.path)\n\n      const pathFixed = !resolved ? null\n        : !/^file:/.test(resolved) ? resolved\n        // resolve onto the metadata path\n        : `file:${resolve(this.path, resolved.substr(5))}`\n\n      // if we have one, only set the other if it matches\n      // otherwise it could be for a completely different thing.\n      const resolvedOk = !resolved || !node.resolved ||\n        node.resolved === pathFixed\n      const integrityOk = !integrity || !node.integrity ||\n        node.integrity === integrity\n\n      if ((resolved || integrity) && resolvedOk && integrityOk) {\n        node.resolved = node.resolved || pathFixed || null\n        node.integrity = node.integrity || integrity || null\n        node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || false\n      } else {\n        // try to read off the package or node itself\n        const {\n          resolved,\n          integrity,\n          hasShrinkwrap,\n        } = Shrinkwrap.metaFromNode(node, this.path)\n        node.resolved = node.resolved || resolved || null\n        node.integrity = node.integrity || integrity || null\n        node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || false\n      }\n    }\n    this[_awaitingUpdate].set(loc, node)\n  }\n\n  addEdge (edge) {\n    if (!this.yarnLock || !edge.valid)\n      return\n\n    const { to: node } = edge\n\n    // if it's already set up, nothing to do\n    if (node.resolved !== null && node.integrity !== null)\n      return\n\n    // if the yarn lock is empty, nothing to do\n    if (!this.yarnLock.entries || !this.yarnLock.entries.size)\n      return\n\n    // we relativize the path here because that's how it shows up in the lock\n    // XXX how is this different from pathFixed above??\n    const pathFixed = !node.resolved ? null\n      : !/file:/.test(node.resolved) ? node.resolved\n      : consistentResolve(node.resolved, node.path, this.path, true)\n\n    const spec = npa(`${node.name}@${edge.spec}`)\n    const entry = this.yarnLock.entries.get(`${node.name}@${edge.spec}`)\n\n    if (!entry ||\n        mismatch(node.version, entry.version) ||\n        mismatch(node.integrity, entry.integrity) ||\n        mismatch(pathFixed, entry.resolved))\n      return\n\n    if (entry.resolved && yarnRegRe.test(entry.resolved) && spec.registry)\n      entry.resolved = entry.resolved.replace(yarnRegRe, 'https://registry.npmjs.org/')\n\n    node.integrity = node.integrity || entry.integrity || null\n    node.resolved = node.resolved ||\n      consistentResolve(entry.resolved, this.path, node.path) || null\n\n    this[_awaitingUpdate].set(relpath(this.path, node.path), node)\n  }\n\n  [_updateWaitingNode] (loc) {\n    const node = this[_awaitingUpdate].get(loc)\n    this[_awaitingUpdate].delete(loc)\n    this.data.packages[loc] = Shrinkwrap.metaFromNode(node, this.path)\n  }\n\n  commit () {\n    if (this.tree) {\n      if (this.yarnLock)\n        this.yarnLock.fromTree(this.tree)\n      const root = Shrinkwrap.metaFromNode(this.tree.target || this.tree, this.path)\n      this.data.packages = {}\n      if (Object.keys(root).length)\n        this.data.packages[''] = root\n      for (const node of this.tree.root.inventory.values()) {\n        // only way this.tree is not root is if the root is a link to it\n        if (node === this.tree || node.isRoot || node.location === '')\n          continue\n        const loc = relpath(this.path, node.path)\n        this.data.packages[loc] = Shrinkwrap.metaFromNode(node, this.path)\n      }\n    } else if (this[_awaitingUpdate].size > 0) {\n      for (const loc of this[_awaitingUpdate].keys())\n        this[_updateWaitingNode](loc)\n    }\n\n    // hidden lockfiles don't include legacy metadata or a root entry\n    if (this.hiddenLockfile) {\n      delete this.data.packages['']\n      delete this.data.dependencies\n    } else if (this.tree)\n      this[_buildLegacyLockfile](this.tree, this.data)\n\n    return this.data\n  }\n\n  [_buildLegacyLockfile] (node, lock, path = []) {\n    if (node === this.tree) {\n      // the root node\n      lock.name = node.package.name || node.name\n      if (node.version)\n        lock.version = node.version\n    }\n\n    // npm v6 and before tracked 'from', meaning \"the request that led\n    // to this package being installed\".  However, that's inherently\n    // racey and non-deterministic in a world where deps are deduped\n    // ahead of fetch time.  In order to maintain backwards compatibility\n    // with v6 in the lockfile, we do this trick where we pick a valid\n    // dep link out of the edgesIn set.  Choose the edge with the fewest\n    // number of `node_modules` sections in the requestor path, and then\n    // lexically sort afterwards.\n    const edge = [...node.edgesIn].filter(e => e.valid).sort((a, b) => {\n      const aloc = a.from.location.split('node_modules')\n      const bloc = b.from.location.split('node_modules')\n      /* istanbul ignore next - sort calling order is indeterminate */\n      return aloc.length > bloc.length ? 1\n        : bloc.length > aloc.length ? -1\n        : aloc[aloc.length - 1].localeCompare(bloc[bloc.length - 1])\n    })[0]\n\n    const res = consistentResolve(node.resolved, this.path, this.path, true)\n    const rSpec = specFromResolved(res)\n\n    // if we don't have anything (ie, it's extraneous) then use the resolved\n    // value as if that was where we got it from, since at least it's true.\n    // if we don't have either, just an empty object so nothing matches below.\n    // This will effectively just save the version and resolved, as if it's\n    // a standard version/range dep, which is a reasonable default.\n    const spec = !edge ? rSpec\n      : npa.resolve(node.name, edge.spec, edge.from.realpath)\n\n    if (node.target)\n      lock.version = `file:${relpath(this.path, node.realpath)}`\n    else if (spec && (spec.type === 'file' || spec.type === 'remote'))\n      lock.version = spec.saveSpec\n    else if (spec && spec.type === 'git' || rSpec.type === 'git') {\n      lock.version = node.resolved\n      /* istanbul ignore else - don't think there are any cases where a git\n       * spec (or indeed, ANY npa spec) doesn't have a .raw member */\n      if (spec.raw)\n        lock.from = spec.raw\n    } else if (!node.isRoot &&\n        node.package &&\n        node.package.name &&\n        node.package.name !== node.name)\n      lock.version = `npm:${node.package.name}@${node.version}`\n    else if (node.package && node.version)\n      lock.version = node.version\n\n    if (node.inDepBundle)\n      lock.bundled = true\n\n    // when we didn't resolve to git, file, or dir, and didn't request\n    // git, file, dir, or remote, then the resolved value is necessary.\n    if (node.resolved &&\n        !node.target &&\n        rSpec.type !== 'git' &&\n        rSpec.type !== 'file' &&\n        rSpec.type !== 'directory' &&\n        spec.type !== 'directory' &&\n        spec.type !== 'git' &&\n        spec.type !== 'file' &&\n        spec.type !== 'remote')\n      lock.resolved = node.resolved\n\n    if (node.integrity)\n      lock.integrity = node.integrity\n\n    if (node.extraneous)\n      lock.extraneous = true\n    else if (!node.isLink) {\n      if (node.peer)\n        lock.peer = true\n\n      if (node.devOptional && !node.dev && !node.optional)\n        lock.devOptional = true\n\n      if (node.dev)\n        lock.dev = true\n\n      if (node.optional)\n        lock.optional = true\n    }\n\n    const depender = node.target || node\n    if (depender.edgesOut.size > 0) {\n      if (node !== this.tree) {\n        lock.requires = [...depender.edgesOut.entries()].reduce((set, [k, v]) => {\n          // omit peer deps from legacy lockfile requires field, because\n          // npm v6 doesn't handle peer deps, and this triggers some bad\n          // behavior if the dep can't be found in the dependencies list.\n          const { spec, peer } = v\n          if (peer)\n            return set\n          if (spec.startsWith('file:')) {\n            // turn absolute file: paths into relative paths from the node\n            // this especially shows up with workspace edges when the root\n            // node is also a workspace in the set.\n            const p = resolve(node.realpath, spec.substr('file:'.length))\n            set[k] = `file:${relpath(node.realpath, p)}`\n          } else\n            set[k] = spec\n          return set\n        }, {})\n      } else\n        lock.requires = true\n    }\n\n    // now we walk the children, putting them in the 'dependencies' object\n    const {children} = node.target || node\n    if (!children.size)\n      delete lock.dependencies\n    else {\n      const kidPath = [...path, node.realpath]\n      const dependencies = {}\n      // skip any that are already in the descent path, so cyclical link\n      // dependencies don't blow up with ELOOP.\n      let found = false\n      for (const [name, kid] of children.entries()) {\n        if (path.includes(kid.realpath))\n          continue\n        dependencies[name] = this[_buildLegacyLockfile](kid, {}, kidPath)\n        found = true\n      }\n      if (found)\n        lock.dependencies = dependencies\n    }\n    return lock\n  }\n\n  save (options = {}) {\n    if (!this.data)\n      throw new Error('run load() before saving data')\n\n    const { format = true } = options\n    const defaultIndent = this.indent || 2\n    const indent = format === true ? defaultIndent\n      : format || 0\n    const eol = format ? this.newline || '\\n' : ''\n    const data = this.commit()\n    const json = stringify(data, swKeyOrder, indent).replace(/\\n/g, eol)\n    return Promise.all([\n      writeFile(this.filename, json).catch(er => {\n        if (this.hiddenLockfile) {\n          // well, we did our best.\n          // if we reify, and there's nothing there, then it might be lacking\n          // a node_modules folder, but then the lockfile is not important.\n          // Remove the file, so that in case there WERE deps, but we just\n          // failed to update the file for some reason, it's not out of sync.\n          return rimraf(this.filename)\n        }\n        throw er\n      }),\n      this.yarnLock && this.yarnLock.entries.size &&\n        writeFile(this.path + '/yarn.lock', this.yarnLock.toString()),\n    ])\n  }\n}\n\nmodule.exports = Shrinkwrap\n"]},"metadata":{},"sourceType":"script"}