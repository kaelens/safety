{"ast":null,"code":"// parse a yarn lock file\n// basic format\n//\n// <request spec>[, <request spec> ...]:\n//   <key> <value>\n//   <subkey>:\n//     <key> <value>\n//\n// Assume that any key or value might be quoted, though that's only done\n// in practice if certain chars are in the string.  Quoting unnecessarily\n// does not cause problems for yarn, so that's what we do when we write\n// it back.\n//\n// The data format would support nested objects, but at this time, it\n// appears that yarn does not use that for anything, so in the interest\n// of a simpler parser algorithm, this implementation only supports a\n// single layer of sub objects.\n//\n// This doesn't deterministically define the shape of the tree, and so\n// cannot be used (on its own) for Arborist.loadVirtual.\n// But it can give us resolved, integrity, and version, which is useful\n// for Arborist.loadActual and for building the ideal tree.\n//\n// At the very least, when a yarn.lock file is present, we update it\n// along the way, and save it back in Shrinkwrap.save()\n//\n// NIHing this rather than using @yarnpkg/lockfile because that module\n// is an impenetrable 10kloc of webpack flow output, which is overkill\n// for something relatively simple and tailored to Arborist's use case.\nconst consistentResolve = require('./consistent-resolve.js');\n\nconst {\n  dirname\n} = require('path');\n\nconst {\n  breadth\n} = require('treeverse'); // sort a key/value object into a string of JSON stringified keys and vals\n\n\nconst sortKV = obj => Object.keys(obj).sort((a, b) => a.localeCompare(b)).map(k => `    ${JSON.stringify(k)} ${JSON.stringify(obj[k])}`).join('\\n'); // for checking against previous entries\n\n\nconst match = (p, n) => p.integrity && n.integrity ? p.integrity === n.integrity : p.resolved && n.resolved ? p.resolved === n.resolved : p.version && n.version ? p.version === n.version : true;\n\nconst prefix = `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n# yarn lockfile v1\n\n\n`;\nconst nullSymbol = Symbol('null');\n\nclass YarnLock {\n  static parse(data) {\n    return new YarnLock().parse(data);\n  }\n\n  static fromTree(tree) {\n    return new YarnLock().fromTree(tree);\n  }\n\n  constructor() {\n    this.entries = null;\n    this.endCurrent();\n  }\n\n  endCurrent() {\n    this.current = null;\n    this.subkey = nullSymbol;\n  }\n\n  parse(data) {\n    const ENTRY_START = /^[^\\s].*:$/;\n    const SUBKEY = /^ {2}[^\\s]+:$/;\n    const SUBVAL = /^ {4}[^\\s]+ .+$/;\n    const METADATA = /^ {2}[^\\s]+ .+$/;\n    this.entries = new Map();\n    this.current = null;\n    const linere = /([^\\r\\n]*)\\r?\\n/gm;\n    let match;\n    let lineNum = 0;\n    if (!/\\n$/.test(data)) data += '\\n';\n\n    while (match = linere.exec(data)) {\n      const line = match[1];\n      lineNum++;\n      if (line.charAt(0) === '#') continue;\n\n      if (line === '') {\n        this.endCurrent();\n        continue;\n      }\n\n      if (ENTRY_START.test(line)) {\n        this.endCurrent();\n        const specs = this.splitQuoted(line.slice(0, -1), /, */);\n        this.current = new YarnLockEntry(specs);\n        specs.forEach(spec => this.entries.set(spec, this.current));\n        continue;\n      }\n\n      if (SUBKEY.test(line)) {\n        this.subkey = line.slice(2, -1);\n        this.current[this.subkey] = {};\n        continue;\n      }\n\n      if (SUBVAL.test(line) && this.current && this.current[this.subkey]) {\n        const subval = this.splitQuoted(line.trimLeft(), ' ');\n\n        if (subval.length === 2) {\n          this.current[this.subkey][subval[0]] = subval[1];\n          continue;\n        }\n      } // any other metadata\n\n\n      if (METADATA.test(line) && this.current) {\n        const metadata = this.splitQuoted(line.trimLeft(), ' ');\n\n        if (metadata.length === 2) {\n          // strip off the legacy shasum hashes\n          if (metadata[0] === 'resolved') metadata[1] = metadata[1].replace(/#.*/, '');\n          this.current[metadata[0]] = metadata[1];\n          continue;\n        }\n      }\n\n      throw Object.assign(new Error('invalid or corrupted yarn.lock file'), {\n        position: match.index,\n        content: match[0],\n        line: lineNum\n      });\n    }\n\n    this.endCurrent();\n    return this;\n  }\n\n  splitQuoted(str, delim) {\n    // a,\"b,c\",d\"e,f => ['a','\"b','c\"','d\"e','f'] => ['a','b,c','d\"e','f']\n    const split = str.split(delim);\n    const out = [];\n    let o = 0;\n\n    for (let i = 0; i < split.length; i++) {\n      const chunk = split[i];\n      if (/^\".*\"$/.test(chunk)) out[o++] = chunk.trim().slice(1, -1);else if (/^\"/.test(chunk)) {\n        let collect = chunk.trimLeft().slice(1);\n\n        while (++i < split.length) {\n          const n = split[i]; // something that is not a slash, followed by an even number\n          // of slashes then a \" then end => ending on an unescaped \"\n\n          if (/[^\\\\](\\\\\\\\)*\"$/.test(n)) {\n            collect += n.trimRight().slice(0, -1);\n            break;\n          } else collect += n;\n        }\n\n        out[o++] = collect;\n      } else out[o++] = chunk.trim();\n    }\n\n    return out;\n  }\n\n  toString() {\n    return prefix + [...new Set([...this.entries.values()])].map(e => e.toString()).sort((a, b) => a.localeCompare(b)).join('\\n\\n') + '\\n';\n  }\n\n  fromTree(tree) {\n    this.entries = new Map(); // walk the tree in a deterministic order, breadth-first, alphabetical\n\n    breadth({\n      tree,\n      visit: node => this.addEntryFromNode(node),\n      getChildren: node => [...node.children.values(), ...node.fsChildren].sort((a, b) => a.depth - b.depth || a.name.localeCompare(b.name))\n    });\n    return this;\n  }\n\n  addEntryFromNode(node) {\n    const specs = [...node.edgesIn].map(e => `${node.name}@${e.spec}`).sort((a, b) => a.localeCompare(b)); // Note:\n    // yarn will do excessive duplication in a case like this:\n    // root -> (x@1.x, y@1.x, z@1.x)\n    // y@1.x -> (x@1.1, z@2.x)\n    // z@1.x -> ()\n    // z@2.x -> (x@1.x)\n    //\n    // where x@1.2 exists, because the \"x@1.x\" spec will *always* resolve\n    // to x@1.2, which doesn't work for y's dep on x@1.1, so you'll get this:\n    //\n    // root\n    // +-- x@1.2.0\n    // +-- y\n    // |   +-- x@1.1.0\n    // |   +-- z@2\n    // |       +-- x@1.2.0\n    // +-- z@1\n    //\n    // instead of this more deduped tree that arborist builds by default:\n    //\n    // root\n    // +-- x@1.2.0 (dep is x@1.x, from root)\n    // +-- y\n    // |   +-- x@1.1.0\n    // |   +-- z@2 (dep on x@1.x deduped to x@1.1.0 under y)\n    // +-- z@1\n    //\n    // In order to not create an invalid yarn.lock file with conflicting\n    // entries, AND not tell yarn to create an invalid tree, we need to\n    // ignore the x@1.x spec coming from z, since it's already in the entries.\n    //\n    // So, if the integrity and resolved don't match a previous entry, skip it.\n    // We call this method on shallower nodes first, so this is fine.\n\n    const n = this.entryDataFromNode(node);\n    let priorEntry = null;\n    const newSpecs = [];\n\n    for (const s of specs) {\n      const prev = this.entries.get(s); // no previous entry for this spec at all, so it's new\n\n      if (!prev) {\n        // if we saw a match already, then assign this spec to it as well\n        if (priorEntry) priorEntry.addSpec(s);else newSpecs.push(s);\n        continue;\n      }\n\n      const m = match(prev, n); // there was a prior entry, but a different thing.  skip this one\n\n      if (!m) continue; // previous matches, but first time seeing it, so already has this spec.\n      // go ahead and add all the previously unseen specs, though\n\n      if (!priorEntry) {\n        priorEntry = prev;\n\n        for (const s of newSpecs) {\n          priorEntry.addSpec(s);\n          this.entries.set(s, priorEntry);\n        }\n\n        newSpecs.length = 0;\n        continue;\n      } // have a prior entry matching n, and matching the prev we just saw\n      // add the spec to it\n\n\n      priorEntry.addSpec(s);\n      this.entries.set(s, priorEntry);\n    } // if we never found a matching prior, then this is a whole new thing\n\n\n    if (!priorEntry) {\n      const entry = Object.assign(new YarnLockEntry(newSpecs), n);\n\n      for (const s of newSpecs) this.entries.set(s, entry);\n    } else {\n      // pick up any new info that we got for this node, so that we can\n      // decorate with integrity/resolved/etc.\n      Object.assign(priorEntry, n);\n    }\n  }\n\n  entryDataFromNode(node) {\n    const n = {};\n    if (node.package.dependencies) n.dependencies = node.package.dependencies;\n    if (node.package.optionalDependencies) n.optionalDependencies = node.package.optionalDependencies;\n    if (node.version) n.version = node.version;\n\n    if (node.resolved) {\n      n.resolved = consistentResolve(node.resolved, node.isLink ? dirname(node.path) : node.path, node.root.path, true);\n    }\n\n    if (node.integrity) n.integrity = node.integrity;\n    return n;\n  }\n\n  static get Entry() {\n    return YarnLockEntry;\n  }\n\n}\n\nconst _specs = Symbol('_specs');\n\nclass YarnLockEntry {\n  constructor(specs) {\n    this[_specs] = new Set(specs);\n    this.resolved = null;\n    this.version = null;\n    this.integrity = null;\n    this.dependencies = null;\n    this.optionalDependencies = null;\n  }\n\n  toString() {\n    // sort objects to the bottom, then alphabetical\n    return ([...this[_specs]].sort((a, b) => a.localeCompare(b)).map(JSON.stringify).join(', ') + ':\\n' + Object.getOwnPropertyNames(this).filter(prop => this[prop] !== null).sort((a, b) =>\n    /* istanbul ignore next - sort call order is unpredictable */\n    typeof this[a] === 'object' === (typeof this[b] === 'object') ? a.localeCompare(b) : typeof this[a] === 'object' ? 1 : -1).map(prop => typeof this[prop] !== 'object' ? `  ${JSON.stringify(prop)} ${JSON.stringify(this[prop])}\\n` : Object.keys(this[prop]).length === 0 ? '' : `  ${prop}:\\n` + sortKV(this[prop]) + '\\n').join('')).trim();\n  }\n\n  addSpec(spec) {\n    this[_specs].add(spec);\n  }\n\n}\n\nmodule.exports = YarnLock;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/@npmcli/arborist/lib/yarn-lock.js"],"names":["consistentResolve","require","dirname","breadth","sortKV","obj","Object","keys","sort","a","b","localeCompare","map","k","JSON","stringify","join","match","p","n","integrity","resolved","version","prefix","nullSymbol","Symbol","YarnLock","parse","data","fromTree","tree","constructor","entries","endCurrent","current","subkey","ENTRY_START","SUBKEY","SUBVAL","METADATA","Map","linere","lineNum","test","exec","line","charAt","specs","splitQuoted","slice","YarnLockEntry","forEach","spec","set","subval","trimLeft","length","metadata","replace","assign","Error","position","index","content","str","delim","split","out","o","i","chunk","trim","collect","trimRight","toString","Set","values","e","visit","node","addEntryFromNode","getChildren","children","fsChildren","depth","name","edgesIn","entryDataFromNode","priorEntry","newSpecs","s","prev","get","addSpec","push","m","entry","package","dependencies","optionalDependencies","isLink","path","root","Entry","_specs","getOwnPropertyNames","filter","prop","add","module","exports"],"mappings":"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","sourcesContent":["// parse a yarn lock file\n// basic format\n//\n// <request spec>[, <request spec> ...]:\n//   <key> <value>\n//   <subkey>:\n//     <key> <value>\n//\n// Assume that any key or value might be quoted, though that's only done\n// in practice if certain chars are in the string.  Quoting unnecessarily\n// does not cause problems for yarn, so that's what we do when we write\n// it back.\n//\n// The data format would support nested objects, but at this time, it\n// appears that yarn does not use that for anything, so in the interest\n// of a simpler parser algorithm, this implementation only supports a\n// single layer of sub objects.\n//\n// This doesn't deterministically define the shape of the tree, and so\n// cannot be used (on its own) for Arborist.loadVirtual.\n// But it can give us resolved, integrity, and version, which is useful\n// for Arborist.loadActual and for building the ideal tree.\n//\n// At the very least, when a yarn.lock file is present, we update it\n// along the way, and save it back in Shrinkwrap.save()\n//\n// NIHing this rather than using @yarnpkg/lockfile because that module\n// is an impenetrable 10kloc of webpack flow output, which is overkill\n// for something relatively simple and tailored to Arborist's use case.\n\nconst consistentResolve = require('./consistent-resolve.js')\nconst {dirname} = require('path')\nconst {breadth} = require('treeverse')\n\n// sort a key/value object into a string of JSON stringified keys and vals\nconst sortKV = obj => Object.keys(obj)\n  .sort((a, b) => a.localeCompare(b))\n  .map(k => `    ${JSON.stringify(k)} ${JSON.stringify(obj[k])}`)\n  .join('\\n')\n\n// for checking against previous entries\nconst match = (p, n) =>\n  p.integrity && n.integrity ? p.integrity === n.integrity\n  : p.resolved && n.resolved ? p.resolved === n.resolved\n  : p.version && n.version ? p.version === n.version\n  : true\n\nconst prefix =\n`# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n# yarn lockfile v1\n\n\n`\n\nconst nullSymbol = Symbol('null')\nclass YarnLock {\n  static parse (data) {\n    return new YarnLock().parse(data)\n  }\n\n  static fromTree (tree) {\n    return new YarnLock().fromTree(tree)\n  }\n\n  constructor () {\n    this.entries = null\n    this.endCurrent()\n  }\n\n  endCurrent () {\n    this.current = null\n    this.subkey = nullSymbol\n  }\n\n  parse (data) {\n    const ENTRY_START = /^[^\\s].*:$/\n    const SUBKEY = /^ {2}[^\\s]+:$/\n    const SUBVAL = /^ {4}[^\\s]+ .+$/\n    const METADATA = /^ {2}[^\\s]+ .+$/\n    this.entries = new Map()\n    this.current = null\n    const linere = /([^\\r\\n]*)\\r?\\n/gm\n    let match\n    let lineNum = 0\n    if (!/\\n$/.test(data))\n      data += '\\n'\n    while (match = linere.exec(data)) {\n      const line = match[1]\n      lineNum++\n      if (line.charAt(0) === '#')\n        continue\n      if (line === '') {\n        this.endCurrent()\n        continue\n      }\n      if (ENTRY_START.test(line)) {\n        this.endCurrent()\n        const specs = this.splitQuoted(line.slice(0, -1), /, */)\n        this.current = new YarnLockEntry(specs)\n        specs.forEach(spec => this.entries.set(spec, this.current))\n        continue\n      }\n      if (SUBKEY.test(line)) {\n        this.subkey = line.slice(2, -1)\n        this.current[this.subkey] = {}\n        continue\n      }\n      if (SUBVAL.test(line) && this.current && this.current[this.subkey]) {\n        const subval = this.splitQuoted(line.trimLeft(), ' ')\n        if (subval.length === 2) {\n          this.current[this.subkey][subval[0]] = subval[1]\n          continue\n        }\n      }\n      // any other metadata\n      if (METADATA.test(line) && this.current) {\n        const metadata = this.splitQuoted(line.trimLeft(), ' ')\n        if (metadata.length === 2) {\n          // strip off the legacy shasum hashes\n          if (metadata[0] === 'resolved')\n            metadata[1] = metadata[1].replace(/#.*/, '')\n          this.current[metadata[0]] = metadata[1]\n          continue\n        }\n      }\n\n      throw Object.assign(new Error('invalid or corrupted yarn.lock file'), {\n        position: match.index,\n        content: match[0],\n        line: lineNum,\n      })\n    }\n    this.endCurrent()\n    return this\n  }\n\n  splitQuoted (str, delim) {\n    // a,\"b,c\",d\"e,f => ['a','\"b','c\"','d\"e','f'] => ['a','b,c','d\"e','f']\n    const split = str.split(delim)\n    const out = []\n    let o = 0\n    for (let i = 0; i < split.length; i++) {\n      const chunk = split[i]\n      if (/^\".*\"$/.test(chunk))\n        out[o++] = chunk.trim().slice(1, -1)\n      else if (/^\"/.test(chunk)) {\n        let collect = chunk.trimLeft().slice(1)\n        while (++i < split.length) {\n          const n = split[i]\n          // something that is not a slash, followed by an even number\n          // of slashes then a \" then end => ending on an unescaped \"\n          if (/[^\\\\](\\\\\\\\)*\"$/.test(n)) {\n            collect += n.trimRight().slice(0, -1)\n            break\n          } else\n            collect += n\n        }\n        out[o++] = collect\n      } else\n        out[o++] = chunk.trim()\n    }\n    return out\n  }\n\n  toString () {\n    return prefix + [...new Set([...this.entries.values()])]\n      .map(e => e.toString())\n      .sort((a, b) => a.localeCompare(b)).join('\\n\\n') + '\\n'\n  }\n\n  fromTree (tree) {\n    this.entries = new Map()\n    // walk the tree in a deterministic order, breadth-first, alphabetical\n    breadth({\n      tree,\n      visit: node => this.addEntryFromNode(node),\n      getChildren: node => [...node.children.values(), ...node.fsChildren]\n        .sort((a, b) => a.depth - b.depth || a.name.localeCompare(b.name)),\n    })\n    return this\n  }\n\n  addEntryFromNode (node) {\n    const specs = [...node.edgesIn]\n      .map(e => `${node.name}@${e.spec}`)\n      .sort((a, b) => a.localeCompare(b))\n\n    // Note:\n    // yarn will do excessive duplication in a case like this:\n    // root -> (x@1.x, y@1.x, z@1.x)\n    // y@1.x -> (x@1.1, z@2.x)\n    // z@1.x -> ()\n    // z@2.x -> (x@1.x)\n    //\n    // where x@1.2 exists, because the \"x@1.x\" spec will *always* resolve\n    // to x@1.2, which doesn't work for y's dep on x@1.1, so you'll get this:\n    //\n    // root\n    // +-- x@1.2.0\n    // +-- y\n    // |   +-- x@1.1.0\n    // |   +-- z@2\n    // |       +-- x@1.2.0\n    // +-- z@1\n    //\n    // instead of this more deduped tree that arborist builds by default:\n    //\n    // root\n    // +-- x@1.2.0 (dep is x@1.x, from root)\n    // +-- y\n    // |   +-- x@1.1.0\n    // |   +-- z@2 (dep on x@1.x deduped to x@1.1.0 under y)\n    // +-- z@1\n    //\n    // In order to not create an invalid yarn.lock file with conflicting\n    // entries, AND not tell yarn to create an invalid tree, we need to\n    // ignore the x@1.x spec coming from z, since it's already in the entries.\n    //\n    // So, if the integrity and resolved don't match a previous entry, skip it.\n    // We call this method on shallower nodes first, so this is fine.\n    const n = this.entryDataFromNode(node)\n    let priorEntry = null\n    const newSpecs = []\n    for (const s of specs) {\n      const prev = this.entries.get(s)\n      // no previous entry for this spec at all, so it's new\n      if (!prev) {\n        // if we saw a match already, then assign this spec to it as well\n        if (priorEntry)\n          priorEntry.addSpec(s)\n        else\n          newSpecs.push(s)\n        continue\n      }\n\n      const m = match(prev, n)\n      // there was a prior entry, but a different thing.  skip this one\n      if (!m)\n        continue\n\n      // previous matches, but first time seeing it, so already has this spec.\n      // go ahead and add all the previously unseen specs, though\n      if (!priorEntry) {\n        priorEntry = prev\n        for (const s of newSpecs) {\n          priorEntry.addSpec(s)\n          this.entries.set(s, priorEntry)\n        }\n        newSpecs.length = 0\n        continue\n      }\n\n      // have a prior entry matching n, and matching the prev we just saw\n      // add the spec to it\n      priorEntry.addSpec(s)\n      this.entries.set(s, priorEntry)\n    }\n\n    // if we never found a matching prior, then this is a whole new thing\n    if (!priorEntry) {\n      const entry = Object.assign(new YarnLockEntry(newSpecs), n)\n      for (const s of newSpecs)\n        this.entries.set(s, entry)\n    } else {\n      // pick up any new info that we got for this node, so that we can\n      // decorate with integrity/resolved/etc.\n      Object.assign(priorEntry, n)\n    }\n  }\n\n  entryDataFromNode (node) {\n    const n = {}\n    if (node.package.dependencies)\n      n.dependencies = node.package.dependencies\n    if (node.package.optionalDependencies)\n      n.optionalDependencies = node.package.optionalDependencies\n    if (node.version)\n      n.version = node.version\n    if (node.resolved) {\n      n.resolved = consistentResolve(\n        node.resolved,\n        node.isLink ? dirname(node.path) : node.path,\n        node.root.path,\n        true\n      )\n    }\n    if (node.integrity)\n      n.integrity = node.integrity\n\n    return n\n  }\n\n  static get Entry () {\n    return YarnLockEntry\n  }\n}\n\nconst _specs = Symbol('_specs')\nclass YarnLockEntry {\n  constructor (specs) {\n    this[_specs] = new Set(specs)\n    this.resolved = null\n    this.version = null\n    this.integrity = null\n    this.dependencies = null\n    this.optionalDependencies = null\n  }\n\n  toString () {\n    // sort objects to the bottom, then alphabetical\n    return ([...this[_specs]]\n      .sort((a, b) => a.localeCompare(b))\n      .map(JSON.stringify).join(', ') +\n      ':\\n' +\n      Object.getOwnPropertyNames(this)\n        .filter(prop => this[prop] !== null)\n        .sort(\n          (a, b) =>\n          /* istanbul ignore next - sort call order is unpredictable */\n            (typeof this[a] === 'object') === (typeof this[b] === 'object')\n              ? a.localeCompare(b)\n              : typeof this[a] === 'object' ? 1 : -1)\n        .map(prop =>\n          typeof this[prop] !== 'object'\n            ? `  ${JSON.stringify(prop)} ${JSON.stringify(this[prop])}\\n`\n            : Object.keys(this[prop]).length === 0 ? ''\n            : `  ${prop}:\\n` + sortKV(this[prop]) + '\\n')\n        .join('')).trim()\n  }\n\n  addSpec (spec) {\n    this[_specs].add(spec)\n  }\n}\n\nmodule.exports = YarnLock\n"]},"metadata":{},"sourceType":"script"}