{"ast":null,"code":"'use strict';\n\nconst npa = require('npm-package-arg');\n\nconst npmFetch = require('npm-registry-fetch');\n\nconst semver = require('semver');\n\nconst {\n  URL\n} = require('url');\n\nconst unpublish = async (spec, opts) => {\n  spec = npa(spec); // spec is used to pick the appropriate registry/auth combo.\n\n  opts = {\n    force: false,\n    ...opts,\n    spec\n  };\n\n  try {\n    const pkgUri = spec.escapedName;\n    const pkg = await npmFetch.json(pkgUri, { ...opts,\n      query: {\n        write: true\n      }\n    });\n    const version = spec.rawSpec;\n    const allVersions = pkg.versions || {};\n    const versionData = allVersions[version];\n    const rawSpecs = !spec.rawSpec || spec.rawSpec === '*';\n    const onlyVersion = Object.keys(allVersions).length === 1;\n    const noVersions = !Object.keys(allVersions).length; // if missing specific version,\n    // assumed unpublished\n\n    if (!versionData && !rawSpecs && !noVersions) return true; // unpublish all versions of a package:\n    // - no specs supplied \"npm unpublish foo\"\n    // - all specs (\"*\") \"npm unpublish foo@*\"\n    // - there was only one version\n    // - has no versions field on packument\n\n    if (rawSpecs || onlyVersion || noVersions) {\n      await npmFetch(`${pkgUri}/-rev/${pkg._rev}`, { ...opts,\n        method: 'DELETE',\n        ignoreBody: true\n      });\n      return true;\n    } else {\n      const dist = allVersions[version].dist;\n      delete allVersions[version];\n      const latestVer = pkg['dist-tags'].latest; // deleting dist tags associated to version\n\n      Object.keys(pkg['dist-tags']).forEach(tag => {\n        if (pkg['dist-tags'][tag] === version) delete pkg['dist-tags'][tag];\n      });\n\n      if (latestVer === version) {\n        pkg['dist-tags'].latest = Object.keys(allVersions).sort(semver.compareLoose).pop();\n      }\n\n      delete pkg._revisions;\n      delete pkg._attachments; // Update packument with removed versions\n\n      await npmFetch(`${pkgUri}/-rev/${pkg._rev}`, { ...opts,\n        method: 'PUT',\n        body: pkg,\n        ignoreBody: true\n      }); // Remove the tarball itself\n\n      const {\n        _rev\n      } = await npmFetch.json(pkgUri, { ...opts,\n        query: {\n          write: true\n        }\n      });\n      const tarballUrl = new URL(dist.tarball).pathname.substr(1);\n      await npmFetch(`${tarballUrl}/-rev/${_rev}`, { ...opts,\n        method: 'DELETE',\n        ignoreBody: true\n      });\n      return true;\n    }\n  } catch (err) {\n    if (err.code !== 'E404') throw err;\n    return true;\n  }\n};\n\nmodule.exports = unpublish;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/libnpmpublish/unpublish.js"],"names":["npa","require","npmFetch","semver","URL","unpublish","spec","opts","force","pkgUri","escapedName","pkg","json","query","write","version","rawSpec","allVersions","versions","versionData","rawSpecs","onlyVersion","Object","keys","length","noVersions","_rev","method","ignoreBody","dist","latestVer","latest","forEach","tag","sort","compareLoose","pop","_revisions","_attachments","body","tarballUrl","tarball","pathname","substr","err","code","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,GAAG,GAAGC,OAAO,CAAC,iBAAD,CAAnB;;AACA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,oBAAD,CAAxB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAUH,OAAO,CAAC,KAAD,CAAvB;;AAEA,MAAMI,SAAS,GAAG,OAAOC,IAAP,EAAaC,IAAb,KAAsB;AACtCD,EAAAA,IAAI,GAAGN,GAAG,CAACM,IAAD,CAAV,CADsC,CAEtC;;AACAC,EAAAA,IAAI,GAAG;AACLC,IAAAA,KAAK,EAAE,KADF;AAEL,OAAGD,IAFE;AAGLD,IAAAA;AAHK,GAAP;;AAMA,MAAI;AACF,UAAMG,MAAM,GAAGH,IAAI,CAACI,WAApB;AACA,UAAMC,GAAG,GAAG,MAAMT,QAAQ,CAACU,IAAT,CAAcH,MAAd,EAAsB,EACtC,GAAGF,IADmC;AAEtCM,MAAAA,KAAK,EAAE;AAAEC,QAAAA,KAAK,EAAE;AAAT;AAF+B,KAAtB,CAAlB;AAKA,UAAMC,OAAO,GAAGT,IAAI,CAACU,OAArB;AACA,UAAMC,WAAW,GAAGN,GAAG,CAACO,QAAJ,IAAgB,EAApC;AACA,UAAMC,WAAW,GAAGF,WAAW,CAACF,OAAD,CAA/B;AAEA,UAAMK,QAAQ,GAAI,CAACd,IAAI,CAACU,OAAN,IAAiBV,IAAI,CAACU,OAAL,KAAiB,GAApD;AACA,UAAMK,WAAW,GAAGC,MAAM,CAACC,IAAP,CAAYN,WAAZ,EAAyBO,MAAzB,KAAoC,CAAxD;AACA,UAAMC,UAAU,GAAG,CAACH,MAAM,CAACC,IAAP,CAAYN,WAAZ,EAAyBO,MAA7C,CAbE,CAeF;AACA;;AACA,QAAI,CAACL,WAAD,IAAgB,CAACC,QAAjB,IAA6B,CAACK,UAAlC,EACE,OAAO,IAAP,CAlBA,CAoBF;AACA;AACA;AACA;AACA;;AACA,QAAIL,QAAQ,IAAIC,WAAZ,IAA2BI,UAA/B,EAA2C;AACzC,YAAMvB,QAAQ,CAAE,GAAEO,MAAO,SAAQE,GAAG,CAACe,IAAK,EAA5B,EAA+B,EAC3C,GAAGnB,IADwC;AAE3CoB,QAAAA,MAAM,EAAE,QAFmC;AAG3CC,QAAAA,UAAU,EAAE;AAH+B,OAA/B,CAAd;AAKA,aAAO,IAAP;AACD,KAPD,MAOO;AACL,YAAMC,IAAI,GAAGZ,WAAW,CAACF,OAAD,CAAX,CAAqBc,IAAlC;AACA,aAAOZ,WAAW,CAACF,OAAD,CAAlB;AAEA,YAAMe,SAAS,GAAGnB,GAAG,CAAC,WAAD,CAAH,CAAiBoB,MAAnC,CAJK,CAML;;AACAT,MAAAA,MAAM,CAACC,IAAP,CAAYZ,GAAG,CAAC,WAAD,CAAf,EAA8BqB,OAA9B,CAAsCC,GAAG,IAAI;AAC3C,YAAItB,GAAG,CAAC,WAAD,CAAH,CAAiBsB,GAAjB,MAA0BlB,OAA9B,EACE,OAAOJ,GAAG,CAAC,WAAD,CAAH,CAAiBsB,GAAjB,CAAP;AACH,OAHD;;AAKA,UAAIH,SAAS,KAAKf,OAAlB,EAA2B;AACzBJ,QAAAA,GAAG,CAAC,WAAD,CAAH,CAAiBoB,MAAjB,GAA0BT,MAAM,CAACC,IAAP,CACxBN,WADwB,EAExBiB,IAFwB,CAEnB/B,MAAM,CAACgC,YAFY,EAEEC,GAFF,EAA1B;AAGD;;AAED,aAAOzB,GAAG,CAAC0B,UAAX;AACA,aAAO1B,GAAG,CAAC2B,YAAX,CAnBK,CAqBL;;AACA,YAAMpC,QAAQ,CAAE,GAAEO,MAAO,SAAQE,GAAG,CAACe,IAAK,EAA5B,EAA+B,EAC3C,GAAGnB,IADwC;AAE3CoB,QAAAA,MAAM,EAAE,KAFmC;AAG3CY,QAAAA,IAAI,EAAE5B,GAHqC;AAI3CiB,QAAAA,UAAU,EAAE;AAJ+B,OAA/B,CAAd,CAtBK,CA6BL;;AACA,YAAM;AAAEF,QAAAA;AAAF,UAAW,MAAMxB,QAAQ,CAACU,IAAT,CAAcH,MAAd,EAAsB,EAC3C,GAAGF,IADwC;AAE3CM,QAAAA,KAAK,EAAE;AAAEC,UAAAA,KAAK,EAAE;AAAT;AAFoC,OAAtB,CAAvB;AAIA,YAAM0B,UAAU,GAAG,IAAIpC,GAAJ,CAAQyB,IAAI,CAACY,OAAb,EAAsBC,QAAtB,CAA+BC,MAA/B,CAAsC,CAAtC,CAAnB;AACA,YAAMzC,QAAQ,CAAE,GAAEsC,UAAW,SAAQd,IAAK,EAA5B,EAA+B,EAC3C,GAAGnB,IADwC;AAE3CoB,QAAAA,MAAM,EAAE,QAFmC;AAG3CC,QAAAA,UAAU,EAAE;AAH+B,OAA/B,CAAd;AAKA,aAAO,IAAP;AACD;AACF,GA1ED,CA0EE,OAAOgB,GAAP,EAAY;AACZ,QAAIA,GAAG,CAACC,IAAJ,KAAa,MAAjB,EACE,MAAMD,GAAN;AAEF,WAAO,IAAP;AACD;AACF,CAzFD;;AA2FAE,MAAM,CAACC,OAAP,GAAiB1C,SAAjB","sourcesContent":["'use strict'\n\nconst npa = require('npm-package-arg')\nconst npmFetch = require('npm-registry-fetch')\nconst semver = require('semver')\nconst { URL } = require('url')\n\nconst unpublish = async (spec, opts) => {\n  spec = npa(spec)\n  // spec is used to pick the appropriate registry/auth combo.\n  opts = {\n    force: false,\n    ...opts,\n    spec,\n  }\n\n  try {\n    const pkgUri = spec.escapedName\n    const pkg = await npmFetch.json(pkgUri, {\n      ...opts,\n      query: { write: true },\n    })\n\n    const version = spec.rawSpec\n    const allVersions = pkg.versions || {}\n    const versionData = allVersions[version]\n\n    const rawSpecs = (!spec.rawSpec || spec.rawSpec === '*')\n    const onlyVersion = Object.keys(allVersions).length === 1\n    const noVersions = !Object.keys(allVersions).length\n\n    // if missing specific version,\n    // assumed unpublished\n    if (!versionData && !rawSpecs && !noVersions)\n      return true\n\n    // unpublish all versions of a package:\n    // - no specs supplied \"npm unpublish foo\"\n    // - all specs (\"*\") \"npm unpublish foo@*\"\n    // - there was only one version\n    // - has no versions field on packument\n    if (rawSpecs || onlyVersion || noVersions) {\n      await npmFetch(`${pkgUri}/-rev/${pkg._rev}`, {\n        ...opts,\n        method: 'DELETE',\n        ignoreBody: true,\n      })\n      return true\n    } else {\n      const dist = allVersions[version].dist\n      delete allVersions[version]\n\n      const latestVer = pkg['dist-tags'].latest\n\n      // deleting dist tags associated to version\n      Object.keys(pkg['dist-tags']).forEach(tag => {\n        if (pkg['dist-tags'][tag] === version)\n          delete pkg['dist-tags'][tag]\n      })\n\n      if (latestVer === version) {\n        pkg['dist-tags'].latest = Object.keys(\n          allVersions\n        ).sort(semver.compareLoose).pop()\n      }\n\n      delete pkg._revisions\n      delete pkg._attachments\n\n      // Update packument with removed versions\n      await npmFetch(`${pkgUri}/-rev/${pkg._rev}`, {\n        ...opts,\n        method: 'PUT',\n        body: pkg,\n        ignoreBody: true,\n      })\n\n      // Remove the tarball itself\n      const { _rev } = await npmFetch.json(pkgUri, {\n        ...opts,\n        query: { write: true },\n      })\n      const tarballUrl = new URL(dist.tarball).pathname.substr(1)\n      await npmFetch(`${tarballUrl}/-rev/${_rev}`, {\n        ...opts,\n        method: 'DELETE',\n        ignoreBody: true,\n      })\n      return true\n    }\n  } catch (err) {\n    if (err.code !== 'E404')\n      throw err\n\n    return true\n  }\n}\n\nmodule.exports = unpublish\n"]},"metadata":{},"sourceType":"script"}