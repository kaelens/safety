{"ast":null,"code":"const utils = require('./utils');\n\nclass Cell {\n  /**\n   * A representation of a cell within the table.\n   * Implementations must have `init` and `draw` methods,\n   * as well as `colSpan`, `rowSpan`, `desiredHeight` and `desiredWidth` properties.\n   * @param options\n   * @constructor\n   */\n  constructor(options) {\n    this.setOptions(options);\n    /**\n     * Each cell will have it's `x` and `y` values set by the `layout-manager` prior to\n     * `init` being called;\n     * @type {Number}\n     */\n\n    this.x = null;\n    this.y = null;\n  }\n\n  setOptions(options) {\n    if (['boolean', 'number', 'string'].indexOf(typeof options) !== -1) {\n      options = {\n        content: '' + options\n      };\n    }\n\n    options = options || {};\n    this.options = options;\n    let content = options.content;\n\n    if (['boolean', 'number', 'string'].indexOf(typeof content) !== -1) {\n      this.content = String(content);\n    } else if (!content) {\n      this.content = '';\n    } else {\n      throw new Error('Content needs to be a primitive, got: ' + typeof content);\n    }\n\n    this.colSpan = options.colSpan || 1;\n    this.rowSpan = options.rowSpan || 1;\n  }\n\n  mergeTableOptions(tableOptions, cells) {\n    this.cells = cells;\n    let optionsChars = this.options.chars || {};\n    let tableChars = tableOptions.chars;\n    let chars = this.chars = {};\n    CHAR_NAMES.forEach(function (name) {\n      setOption(optionsChars, tableChars, name, chars);\n    });\n    this.truncate = this.options.truncate || tableOptions.truncate;\n    let style = this.options.style = this.options.style || {};\n    let tableStyle = tableOptions.style;\n    setOption(style, tableStyle, 'padding-left', this);\n    setOption(style, tableStyle, 'padding-right', this);\n    this.head = style.head || tableStyle.head;\n    this.border = style.border || tableStyle.border;\n    let fixedWidth = tableOptions.colWidths[this.x];\n\n    if (tableOptions.wordWrap && fixedWidth) {\n      fixedWidth -= this.paddingLeft + this.paddingRight;\n\n      if (this.colSpan) {\n        let i = 1;\n\n        while (i < this.colSpan) {\n          fixedWidth += tableOptions.colWidths[this.x + i];\n          i++;\n        }\n      }\n\n      this.lines = utils.colorizeLines(utils.wordWrap(fixedWidth, this.content));\n    } else {\n      this.lines = utils.colorizeLines(this.content.split('\\n'));\n    }\n\n    this.desiredWidth = utils.strlen(this.content) + this.paddingLeft + this.paddingRight;\n    this.desiredHeight = this.lines.length;\n  }\n  /**\n   * Initializes the Cells data structure.\n   *\n   * @param tableOptions - A fully populated set of tableOptions.\n   * In addition to the standard default values, tableOptions must have fully populated the\n   * `colWidths` and `rowWidths` arrays. Those arrays must have lengths equal to the number\n   * of columns or rows (respectively) in this table, and each array item must be a Number.\n   *\n   */\n\n\n  init(tableOptions) {\n    let x = this.x;\n    let y = this.y;\n    this.widths = tableOptions.colWidths.slice(x, x + this.colSpan);\n    this.heights = tableOptions.rowHeights.slice(y, y + this.rowSpan);\n    this.width = this.widths.reduce(sumPlusOne, -1);\n    this.height = this.heights.reduce(sumPlusOne, -1);\n    this.hAlign = this.options.hAlign || tableOptions.colAligns[x];\n    this.vAlign = this.options.vAlign || tableOptions.rowAligns[y];\n    this.drawRight = x + this.colSpan == tableOptions.colWidths.length;\n  }\n  /**\n   * Draws the given line of the cell.\n   * This default implementation defers to methods `drawTop`, `drawBottom`, `drawLine` and `drawEmpty`.\n   * @param lineNum - can be `top`, `bottom` or a numerical line number.\n   * @param spanningCell - will be a number if being called from a RowSpanCell, and will represent how\n   * many rows below it's being called from. Otherwise it's undefined.\n   * @returns {String} The representation of this line.\n   */\n\n\n  draw(lineNum, spanningCell) {\n    if (lineNum == 'top') return this.drawTop(this.drawRight);\n    if (lineNum == 'bottom') return this.drawBottom(this.drawRight);\n    let padLen = Math.max(this.height - this.lines.length, 0);\n    let padTop;\n\n    switch (this.vAlign) {\n      case 'center':\n        padTop = Math.ceil(padLen / 2);\n        break;\n\n      case 'bottom':\n        padTop = padLen;\n        break;\n\n      default:\n        padTop = 0;\n    }\n\n    if (lineNum < padTop || lineNum >= padTop + this.lines.length) {\n      return this.drawEmpty(this.drawRight, spanningCell);\n    }\n\n    let forceTruncation = this.lines.length > this.height && lineNum + 1 >= this.height;\n    return this.drawLine(lineNum - padTop, this.drawRight, forceTruncation, spanningCell);\n  }\n  /**\n   * Renders the top line of the cell.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @returns {String}\n   */\n\n\n  drawTop(drawRight) {\n    let content = [];\n\n    if (this.cells) {\n      //TODO: cells should always exist - some tests don't fill it in though\n      this.widths.forEach(function (width, index) {\n        content.push(this._topLeftChar(index));\n        content.push(utils.repeat(this.chars[this.y == 0 ? 'top' : 'mid'], width));\n      }, this);\n    } else {\n      content.push(this._topLeftChar(0));\n      content.push(utils.repeat(this.chars[this.y == 0 ? 'top' : 'mid'], this.width));\n    }\n\n    if (drawRight) {\n      content.push(this.chars[this.y == 0 ? 'topRight' : 'rightMid']);\n    }\n\n    return this.wrapWithStyleColors('border', content.join(''));\n  }\n\n  _topLeftChar(offset) {\n    let x = this.x + offset;\n    let leftChar;\n\n    if (this.y == 0) {\n      leftChar = x == 0 ? 'topLeft' : offset == 0 ? 'topMid' : 'top';\n    } else {\n      if (x == 0) {\n        leftChar = 'leftMid';\n      } else {\n        leftChar = offset == 0 ? 'midMid' : 'bottomMid';\n\n        if (this.cells) {\n          //TODO: cells should always exist - some tests don't fill it in though\n          let spanAbove = this.cells[this.y - 1][x] instanceof Cell.ColSpanCell;\n\n          if (spanAbove) {\n            leftChar = offset == 0 ? 'topMid' : 'mid';\n          }\n\n          if (offset == 0) {\n            let i = 1;\n\n            while (this.cells[this.y][x - i] instanceof Cell.ColSpanCell) {\n              i++;\n            }\n\n            if (this.cells[this.y][x - i] instanceof Cell.RowSpanCell) {\n              leftChar = 'leftMid';\n            }\n          }\n        }\n      }\n    }\n\n    return this.chars[leftChar];\n  }\n\n  wrapWithStyleColors(styleProperty, content) {\n    if (this[styleProperty] && this[styleProperty].length) {\n      try {\n        let colors = require('colors/safe');\n\n        for (let i = this[styleProperty].length - 1; i >= 0; i--) {\n          colors = colors[this[styleProperty][i]];\n        }\n\n        return colors(content);\n      } catch (e) {\n        return content;\n      }\n    } else {\n      return content;\n    }\n  }\n  /**\n   * Renders a line of text.\n   * @param lineNum - Which line of text to render. This is not necessarily the line within the cell.\n   * There may be top-padding above the first line of text.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @param forceTruncationSymbol - `true` if the rendered text should end with the truncation symbol even\n   * if the text fits. This is used when the cell is vertically truncated. If `false` the text should\n   * only include the truncation symbol if the text will not fit horizontally within the cell width.\n   * @param spanningCell - a number of if being called from a RowSpanCell. (how many rows below). otherwise undefined.\n   * @returns {String}\n   */\n\n\n  drawLine(lineNum, drawRight, forceTruncationSymbol, spanningCell) {\n    let left = this.chars[this.x == 0 ? 'left' : 'middle'];\n\n    if (this.x && spanningCell && this.cells) {\n      let cellLeft = this.cells[this.y + spanningCell][this.x - 1];\n\n      while (cellLeft instanceof ColSpanCell) {\n        cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];\n      }\n\n      if (!(cellLeft instanceof RowSpanCell)) {\n        left = this.chars['rightMid'];\n      }\n    }\n\n    let leftPadding = utils.repeat(' ', this.paddingLeft);\n    let right = drawRight ? this.chars['right'] : '';\n    let rightPadding = utils.repeat(' ', this.paddingRight);\n    let line = this.lines[lineNum];\n    let len = this.width - (this.paddingLeft + this.paddingRight);\n    if (forceTruncationSymbol) line += this.truncate || '…';\n    let content = utils.truncate(line, len, this.truncate);\n    content = utils.pad(content, len, ' ', this.hAlign);\n    content = leftPadding + content + rightPadding;\n    return this.stylizeLine(left, content, right);\n  }\n\n  stylizeLine(left, content, right) {\n    left = this.wrapWithStyleColors('border', left);\n    right = this.wrapWithStyleColors('border', right);\n\n    if (this.y === 0) {\n      content = this.wrapWithStyleColors('head', content);\n    }\n\n    return left + content + right;\n  }\n  /**\n   * Renders the bottom line of the cell.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @returns {String}\n   */\n\n\n  drawBottom(drawRight) {\n    let left = this.chars[this.x == 0 ? 'bottomLeft' : 'bottomMid'];\n    let content = utils.repeat(this.chars.bottom, this.width);\n    let right = drawRight ? this.chars['bottomRight'] : '';\n    return this.wrapWithStyleColors('border', left + content + right);\n  }\n  /**\n   * Renders a blank line of text within the cell. Used for top and/or bottom padding.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @param spanningCell - a number of if being called from a RowSpanCell. (how many rows below). otherwise undefined.\n   * @returns {String}\n   */\n\n\n  drawEmpty(drawRight, spanningCell) {\n    let left = this.chars[this.x == 0 ? 'left' : 'middle'];\n\n    if (this.x && spanningCell && this.cells) {\n      let cellLeft = this.cells[this.y + spanningCell][this.x - 1];\n\n      while (cellLeft instanceof ColSpanCell) {\n        cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];\n      }\n\n      if (!(cellLeft instanceof RowSpanCell)) {\n        left = this.chars['rightMid'];\n      }\n    }\n\n    let right = drawRight ? this.chars['right'] : '';\n    let content = utils.repeat(' ', this.width);\n    return this.stylizeLine(left, content, right);\n  }\n\n}\n\nclass ColSpanCell {\n  /**\n   * A Cell that doesn't do anything. It just draws empty lines.\n   * Used as a placeholder in column spanning.\n   * @constructor\n   */\n  constructor() {}\n\n  draw() {\n    return '';\n  }\n\n  init() {}\n\n  mergeTableOptions() {}\n\n}\n\nclass RowSpanCell {\n  /**\n   * A placeholder Cell for a Cell that spans multiple rows.\n   * It delegates rendering to the original cell, but adds the appropriate offset.\n   * @param originalCell\n   * @constructor\n   */\n  constructor(originalCell) {\n    this.originalCell = originalCell;\n  }\n\n  init(tableOptions) {\n    let y = this.y;\n    let originalY = this.originalCell.y;\n    this.cellOffset = y - originalY;\n    this.offset = findDimension(tableOptions.rowHeights, originalY, this.cellOffset);\n  }\n\n  draw(lineNum) {\n    if (lineNum == 'top') {\n      return this.originalCell.draw(this.offset, this.cellOffset);\n    }\n\n    if (lineNum == 'bottom') {\n      return this.originalCell.draw('bottom');\n    }\n\n    return this.originalCell.draw(this.offset + 1 + lineNum);\n  }\n\n  mergeTableOptions() {}\n\n} // HELPER FUNCTIONS\n\n\nfunction setOption(objA, objB, nameB, targetObj) {\n  let nameA = nameB.split('-');\n\n  if (nameA.length > 1) {\n    nameA[1] = nameA[1].charAt(0).toUpperCase() + nameA[1].substr(1);\n    nameA = nameA.join('');\n    targetObj[nameA] = objA[nameA] || objA[nameB] || objB[nameA] || objB[nameB];\n  } else {\n    targetObj[nameB] = objA[nameB] || objB[nameB];\n  }\n}\n\nfunction findDimension(dimensionTable, startingIndex, span) {\n  let ret = dimensionTable[startingIndex];\n\n  for (let i = 1; i < span; i++) {\n    ret += 1 + dimensionTable[startingIndex + i];\n  }\n\n  return ret;\n}\n\nfunction sumPlusOne(a, b) {\n  return a + b + 1;\n}\n\nlet CHAR_NAMES = ['top', 'top-mid', 'top-left', 'top-right', 'bottom', 'bottom-mid', 'bottom-left', 'bottom-right', 'left', 'left-mid', 'mid', 'mid-mid', 'right', 'right-mid', 'middle'];\nmodule.exports = Cell;\nmodule.exports.ColSpanCell = ColSpanCell;\nmodule.exports.RowSpanCell = RowSpanCell;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/cli-table3/src/cell.js"],"names":["utils","require","Cell","constructor","options","setOptions","x","y","indexOf","content","String","Error","colSpan","rowSpan","mergeTableOptions","tableOptions","cells","optionsChars","chars","tableChars","CHAR_NAMES","forEach","name","setOption","truncate","style","tableStyle","head","border","fixedWidth","colWidths","wordWrap","paddingLeft","paddingRight","i","lines","colorizeLines","split","desiredWidth","strlen","desiredHeight","length","init","widths","slice","heights","rowHeights","width","reduce","sumPlusOne","height","hAlign","colAligns","vAlign","rowAligns","drawRight","draw","lineNum","spanningCell","drawTop","drawBottom","padLen","Math","max","padTop","ceil","drawEmpty","forceTruncation","drawLine","index","push","_topLeftChar","repeat","wrapWithStyleColors","join","offset","leftChar","spanAbove","ColSpanCell","RowSpanCell","styleProperty","colors","e","forceTruncationSymbol","left","cellLeft","leftPadding","right","rightPadding","line","len","pad","stylizeLine","bottom","originalCell","originalY","cellOffset","findDimension","objA","objB","nameB","targetObj","nameA","charAt","toUpperCase","substr","dimensionTable","startingIndex","span","ret","a","b","module","exports"],"mappings":"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","sourcesContent":["const utils = require('./utils');\n\nclass Cell {\n  /**\n   * A representation of a cell within the table.\n   * Implementations must have `init` and `draw` methods,\n   * as well as `colSpan`, `rowSpan`, `desiredHeight` and `desiredWidth` properties.\n   * @param options\n   * @constructor\n   */\n  constructor(options) {\n    this.setOptions(options);\n\n    /**\n     * Each cell will have it's `x` and `y` values set by the `layout-manager` prior to\n     * `init` being called;\n     * @type {Number}\n     */\n    this.x = null;\n    this.y = null;\n  }\n\n  setOptions(options) {\n    if (['boolean', 'number', 'string'].indexOf(typeof options) !== -1) {\n      options = { content: '' + options };\n    }\n    options = options || {};\n    this.options = options;\n    let content = options.content;\n    if (['boolean', 'number', 'string'].indexOf(typeof content) !== -1) {\n      this.content = String(content);\n    } else if (!content) {\n      this.content = '';\n    } else {\n      throw new Error('Content needs to be a primitive, got: ' + typeof content);\n    }\n    this.colSpan = options.colSpan || 1;\n    this.rowSpan = options.rowSpan || 1;\n  }\n\n  mergeTableOptions(tableOptions, cells) {\n    this.cells = cells;\n\n    let optionsChars = this.options.chars || {};\n    let tableChars = tableOptions.chars;\n    let chars = (this.chars = {});\n    CHAR_NAMES.forEach(function (name) {\n      setOption(optionsChars, tableChars, name, chars);\n    });\n\n    this.truncate = this.options.truncate || tableOptions.truncate;\n\n    let style = (this.options.style = this.options.style || {});\n    let tableStyle = tableOptions.style;\n    setOption(style, tableStyle, 'padding-left', this);\n    setOption(style, tableStyle, 'padding-right', this);\n    this.head = style.head || tableStyle.head;\n    this.border = style.border || tableStyle.border;\n\n    let fixedWidth = tableOptions.colWidths[this.x];\n    if (tableOptions.wordWrap && fixedWidth) {\n      fixedWidth -= this.paddingLeft + this.paddingRight;\n      if (this.colSpan) {\n        let i = 1;\n        while (i < this.colSpan) {\n          fixedWidth += tableOptions.colWidths[this.x + i];\n          i++;\n        }\n      }\n      this.lines = utils.colorizeLines(utils.wordWrap(fixedWidth, this.content));\n    } else {\n      this.lines = utils.colorizeLines(this.content.split('\\n'));\n    }\n\n    this.desiredWidth = utils.strlen(this.content) + this.paddingLeft + this.paddingRight;\n    this.desiredHeight = this.lines.length;\n  }\n\n  /**\n   * Initializes the Cells data structure.\n   *\n   * @param tableOptions - A fully populated set of tableOptions.\n   * In addition to the standard default values, tableOptions must have fully populated the\n   * `colWidths` and `rowWidths` arrays. Those arrays must have lengths equal to the number\n   * of columns or rows (respectively) in this table, and each array item must be a Number.\n   *\n   */\n  init(tableOptions) {\n    let x = this.x;\n    let y = this.y;\n    this.widths = tableOptions.colWidths.slice(x, x + this.colSpan);\n    this.heights = tableOptions.rowHeights.slice(y, y + this.rowSpan);\n    this.width = this.widths.reduce(sumPlusOne, -1);\n    this.height = this.heights.reduce(sumPlusOne, -1);\n\n    this.hAlign = this.options.hAlign || tableOptions.colAligns[x];\n    this.vAlign = this.options.vAlign || tableOptions.rowAligns[y];\n\n    this.drawRight = x + this.colSpan == tableOptions.colWidths.length;\n  }\n\n  /**\n   * Draws the given line of the cell.\n   * This default implementation defers to methods `drawTop`, `drawBottom`, `drawLine` and `drawEmpty`.\n   * @param lineNum - can be `top`, `bottom` or a numerical line number.\n   * @param spanningCell - will be a number if being called from a RowSpanCell, and will represent how\n   * many rows below it's being called from. Otherwise it's undefined.\n   * @returns {String} The representation of this line.\n   */\n  draw(lineNum, spanningCell) {\n    if (lineNum == 'top') return this.drawTop(this.drawRight);\n    if (lineNum == 'bottom') return this.drawBottom(this.drawRight);\n    let padLen = Math.max(this.height - this.lines.length, 0);\n    let padTop;\n    switch (this.vAlign) {\n      case 'center':\n        padTop = Math.ceil(padLen / 2);\n        break;\n      case 'bottom':\n        padTop = padLen;\n        break;\n      default:\n        padTop = 0;\n    }\n    if (lineNum < padTop || lineNum >= padTop + this.lines.length) {\n      return this.drawEmpty(this.drawRight, spanningCell);\n    }\n    let forceTruncation = this.lines.length > this.height && lineNum + 1 >= this.height;\n    return this.drawLine(lineNum - padTop, this.drawRight, forceTruncation, spanningCell);\n  }\n\n  /**\n   * Renders the top line of the cell.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @returns {String}\n   */\n  drawTop(drawRight) {\n    let content = [];\n    if (this.cells) {\n      //TODO: cells should always exist - some tests don't fill it in though\n      this.widths.forEach(function (width, index) {\n        content.push(this._topLeftChar(index));\n        content.push(utils.repeat(this.chars[this.y == 0 ? 'top' : 'mid'], width));\n      }, this);\n    } else {\n      content.push(this._topLeftChar(0));\n      content.push(utils.repeat(this.chars[this.y == 0 ? 'top' : 'mid'], this.width));\n    }\n    if (drawRight) {\n      content.push(this.chars[this.y == 0 ? 'topRight' : 'rightMid']);\n    }\n    return this.wrapWithStyleColors('border', content.join(''));\n  }\n\n  _topLeftChar(offset) {\n    let x = this.x + offset;\n    let leftChar;\n    if (this.y == 0) {\n      leftChar = x == 0 ? 'topLeft' : offset == 0 ? 'topMid' : 'top';\n    } else {\n      if (x == 0) {\n        leftChar = 'leftMid';\n      } else {\n        leftChar = offset == 0 ? 'midMid' : 'bottomMid';\n        if (this.cells) {\n          //TODO: cells should always exist - some tests don't fill it in though\n          let spanAbove = this.cells[this.y - 1][x] instanceof Cell.ColSpanCell;\n          if (spanAbove) {\n            leftChar = offset == 0 ? 'topMid' : 'mid';\n          }\n          if (offset == 0) {\n            let i = 1;\n            while (this.cells[this.y][x - i] instanceof Cell.ColSpanCell) {\n              i++;\n            }\n            if (this.cells[this.y][x - i] instanceof Cell.RowSpanCell) {\n              leftChar = 'leftMid';\n            }\n          }\n        }\n      }\n    }\n    return this.chars[leftChar];\n  }\n\n  wrapWithStyleColors(styleProperty, content) {\n    if (this[styleProperty] && this[styleProperty].length) {\n      try {\n        let colors = require('colors/safe');\n        for (let i = this[styleProperty].length - 1; i >= 0; i--) {\n          colors = colors[this[styleProperty][i]];\n        }\n        return colors(content);\n      } catch (e) {\n        return content;\n      }\n    } else {\n      return content;\n    }\n  }\n\n  /**\n   * Renders a line of text.\n   * @param lineNum - Which line of text to render. This is not necessarily the line within the cell.\n   * There may be top-padding above the first line of text.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @param forceTruncationSymbol - `true` if the rendered text should end with the truncation symbol even\n   * if the text fits. This is used when the cell is vertically truncated. If `false` the text should\n   * only include the truncation symbol if the text will not fit horizontally within the cell width.\n   * @param spanningCell - a number of if being called from a RowSpanCell. (how many rows below). otherwise undefined.\n   * @returns {String}\n   */\n  drawLine(lineNum, drawRight, forceTruncationSymbol, spanningCell) {\n    let left = this.chars[this.x == 0 ? 'left' : 'middle'];\n    if (this.x && spanningCell && this.cells) {\n      let cellLeft = this.cells[this.y + spanningCell][this.x - 1];\n      while (cellLeft instanceof ColSpanCell) {\n        cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];\n      }\n      if (!(cellLeft instanceof RowSpanCell)) {\n        left = this.chars['rightMid'];\n      }\n    }\n    let leftPadding = utils.repeat(' ', this.paddingLeft);\n    let right = drawRight ? this.chars['right'] : '';\n    let rightPadding = utils.repeat(' ', this.paddingRight);\n    let line = this.lines[lineNum];\n    let len = this.width - (this.paddingLeft + this.paddingRight);\n    if (forceTruncationSymbol) line += this.truncate || '…';\n    let content = utils.truncate(line, len, this.truncate);\n    content = utils.pad(content, len, ' ', this.hAlign);\n    content = leftPadding + content + rightPadding;\n    return this.stylizeLine(left, content, right);\n  }\n\n  stylizeLine(left, content, right) {\n    left = this.wrapWithStyleColors('border', left);\n    right = this.wrapWithStyleColors('border', right);\n    if (this.y === 0) {\n      content = this.wrapWithStyleColors('head', content);\n    }\n    return left + content + right;\n  }\n\n  /**\n   * Renders the bottom line of the cell.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @returns {String}\n   */\n  drawBottom(drawRight) {\n    let left = this.chars[this.x == 0 ? 'bottomLeft' : 'bottomMid'];\n    let content = utils.repeat(this.chars.bottom, this.width);\n    let right = drawRight ? this.chars['bottomRight'] : '';\n    return this.wrapWithStyleColors('border', left + content + right);\n  }\n\n  /**\n   * Renders a blank line of text within the cell. Used for top and/or bottom padding.\n   * @param drawRight - true if this method should render the right edge of the cell.\n   * @param spanningCell - a number of if being called from a RowSpanCell. (how many rows below). otherwise undefined.\n   * @returns {String}\n   */\n  drawEmpty(drawRight, spanningCell) {\n    let left = this.chars[this.x == 0 ? 'left' : 'middle'];\n    if (this.x && spanningCell && this.cells) {\n      let cellLeft = this.cells[this.y + spanningCell][this.x - 1];\n      while (cellLeft instanceof ColSpanCell) {\n        cellLeft = this.cells[cellLeft.y][cellLeft.x - 1];\n      }\n      if (!(cellLeft instanceof RowSpanCell)) {\n        left = this.chars['rightMid'];\n      }\n    }\n    let right = drawRight ? this.chars['right'] : '';\n    let content = utils.repeat(' ', this.width);\n    return this.stylizeLine(left, content, right);\n  }\n}\n\nclass ColSpanCell {\n  /**\n   * A Cell that doesn't do anything. It just draws empty lines.\n   * Used as a placeholder in column spanning.\n   * @constructor\n   */\n  constructor() {}\n\n  draw() {\n    return '';\n  }\n\n  init() {}\n\n  mergeTableOptions() {}\n}\n\nclass RowSpanCell {\n  /**\n   * A placeholder Cell for a Cell that spans multiple rows.\n   * It delegates rendering to the original cell, but adds the appropriate offset.\n   * @param originalCell\n   * @constructor\n   */\n  constructor(originalCell) {\n    this.originalCell = originalCell;\n  }\n\n  init(tableOptions) {\n    let y = this.y;\n    let originalY = this.originalCell.y;\n    this.cellOffset = y - originalY;\n    this.offset = findDimension(tableOptions.rowHeights, originalY, this.cellOffset);\n  }\n\n  draw(lineNum) {\n    if (lineNum == 'top') {\n      return this.originalCell.draw(this.offset, this.cellOffset);\n    }\n    if (lineNum == 'bottom') {\n      return this.originalCell.draw('bottom');\n    }\n    return this.originalCell.draw(this.offset + 1 + lineNum);\n  }\n\n  mergeTableOptions() {}\n}\n\n// HELPER FUNCTIONS\nfunction setOption(objA, objB, nameB, targetObj) {\n  let nameA = nameB.split('-');\n  if (nameA.length > 1) {\n    nameA[1] = nameA[1].charAt(0).toUpperCase() + nameA[1].substr(1);\n    nameA = nameA.join('');\n    targetObj[nameA] = objA[nameA] || objA[nameB] || objB[nameA] || objB[nameB];\n  } else {\n    targetObj[nameB] = objA[nameB] || objB[nameB];\n  }\n}\n\nfunction findDimension(dimensionTable, startingIndex, span) {\n  let ret = dimensionTable[startingIndex];\n  for (let i = 1; i < span; i++) {\n    ret += 1 + dimensionTable[startingIndex + i];\n  }\n  return ret;\n}\n\nfunction sumPlusOne(a, b) {\n  return a + b + 1;\n}\n\nlet CHAR_NAMES = [\n  'top',\n  'top-mid',\n  'top-left',\n  'top-right',\n  'bottom',\n  'bottom-mid',\n  'bottom-left',\n  'bottom-right',\n  'left',\n  'left-mid',\n  'mid',\n  'mid-mid',\n  'right',\n  'right-mid',\n  'middle',\n];\nmodule.exports = Cell;\nmodule.exports.ColSpanCell = ColSpanCell;\nmodule.exports.RowSpanCell = RowSpanCell;\n"]},"metadata":{},"sourceType":"script"}