{"ast":null,"code":"const hash = require('./hash.js');\n\nconst semver = require('semver');\n\nconst semverOpt = {\n  includePrerelease: true,\n  loose: true\n};\n\nconst getDepSpec = require('./get-dep-spec.js'); // any fields that we don't want in the cache need to be hidden\n\n\nconst _source = Symbol('source');\n\nconst _packument = Symbol('packument');\n\nconst _versionVulnMemo = Symbol('versionVulnMemo');\n\nconst _updated = Symbol('updated');\n\nconst _options = Symbol('options');\n\nconst _specVulnMemo = Symbol('specVulnMemo');\n\nconst _testVersion = Symbol('testVersion');\n\nconst _testVersions = Symbol('testVersions');\n\nconst _calculateRange = Symbol('calculateRange');\n\nconst _markVulnerable = Symbol('markVulnerable');\n\nconst _testSpec = Symbol('testSpec');\n\nclass Advisory {\n  constructor(name, source, options = {}) {\n    this.source = source.id;\n    this[_source] = source;\n    this[_options] = options;\n    this.name = name;\n    if (!source.name) source.name = name;\n    this.dependency = source.name;\n\n    if (this.type === 'advisory') {\n      this.title = source.title;\n      this.url = source.url;\n    } else {\n      this.title = `Depends on vulnerable versions of ${source.name}`;\n      this.url = null;\n    }\n\n    this.severity = source.severity || 'high';\n    this.versions = [];\n    this.vulnerableVersions = []; // advisories have the range, metavulns do not\n    // if an advisory doesn't specify range, assume all are vulnerable\n\n    this.range = this.type === 'advisory' ? source.vulnerable_versions || '*' : null;\n    this.id = hash(this);\n    this[_packument] = null; // memoized list of which versions are vulnerable\n\n    this[_versionVulnMemo] = new Map(); // memoized list of which dependency specs are vulnerable\n\n    this[_specVulnMemo] = new Map();\n    this[_updated] = false;\n  } // true if we updated from what we had in cache\n\n\n  get updated() {\n    return this[_updated];\n  }\n\n  get type() {\n    return this.dependency === this.name ? 'advisory' : 'metavuln';\n  }\n\n  get packument() {\n    return this[_packument];\n  } // load up the data from a cache entry and a fetched packument\n\n\n  load(cached, packument) {\n    // basic data integrity gutcheck\n    if (!cached || typeof cached !== 'object') throw new TypeError('invalid cached data, expected object');\n    if (!packument || typeof packument !== 'object') throw new TypeError('invalid packument data, expected object');\n\n    if (cached.id && cached.id !== this.id) {\n      throw Object.assign(new Error('loading from incorrect cache entry'), {\n        expected: this.id,\n        actual: cached.id\n      });\n    }\n\n    if (packument.name !== this.name) {\n      throw Object.assign(new Error('loading from incorrect packument'), {\n        expected: this.name,\n        actual: packument.name\n      });\n    }\n\n    if (this[_packument]) throw new Error('advisory object already loaded'); // if we have a range from the initialization, and the cached\n    // data has a *different* range, then we know we have to recalc.\n    // just don't use the cached data, so we will definitely not match later\n\n    if (!this.range || cached.range && cached.range === this.range) Object.assign(this, cached);\n    this[_packument] = packument;\n    const pakuVersions = Object.keys(packument.versions);\n    const allVersions = new Set([...pakuVersions, ...this.versions]);\n    const versionsAdded = [];\n    const versionsRemoved = [];\n\n    for (const v of allVersions) {\n      if (!this.versions.includes(v)) {\n        versionsAdded.push(v);\n        this.versions.push(v);\n      } else if (!pakuVersions.includes(v)) versionsRemoved.push(v);\n    } // strip out any removed versions from our lists, and sort by semver\n\n\n    this.versions = semver.sort(this.versions.filter(v => !versionsRemoved.includes(v)), semverOpt); // if no changes, then just return what we got from cache\n    // versions added or removed always means we changed\n    // otherwise, advisories change if the range changes, and\n    // metavulns change if the source was updated\n\n    const unchanged = this.type === 'advisory' ? this.range && this.range === cached.range : !this[_source].updated; // if the underlying source changed, by an advisory updating the\n    // range, or a source advisory being updated, then we have to re-check\n    // otherwise, only recheck the new ones.\n\n    this.vulnerableVersions = !unchanged ? [] : semver.sort(this.vulnerableVersions.filter(v => !versionsRemoved.includes(v)), semverOpt);\n\n    if (unchanged && !versionsAdded.length && !versionsRemoved.length) {\n      // nothing added or removed, nothing to do here.  use the cached copy.\n      return this;\n    }\n\n    this[_updated] = true; // test any versions newly added\n\n    if (!unchanged || versionsAdded.length) this[_testVersions](unchanged ? versionsAdded : this.versions);\n    this.vulnerableVersions = semver.sort(this.vulnerableVersions, semverOpt); // metavulns have to calculate their range, since cache is invalidated\n    // advisories just get their range from the advisory above\n\n    if (this.type === 'metavuln') this[_calculateRange]();\n    return this;\n  }\n\n  [_calculateRange]() {\n    // calling semver.simplifyRange with a massive list of versions, and those\n    // versions all concatenated with `||` is a geometric CPU explosion!\n    // we can try to be a *little* smarter up front by doing x-y for all\n    // contiguous version sets in the list\n    const ranges = [];\n    this.versions = semver.sort(this.versions);\n    this.vulnerableVersions = semver.sort(this.vulnerableVersions);\n\n    for (let v = 0, vulnVer = 0; v < this.versions.length; v++) {\n      // figure out the vulnerable subrange\n      const vr = [this.versions[v]];\n\n      while (v < this.versions.length) {\n        if (this.versions[v] !== this.vulnerableVersions[vulnVer]) {\n          // we don't test prerelease versions, so just skip past it\n          if (/-/.test(this.versions[v])) {\n            v++;\n            continue;\n          }\n\n          break;\n        }\n\n        if (vr.length > 1) vr[1] = this.versions[v];else vr.push(this.versions[v]);\n        v++;\n        vulnVer++;\n      } // it'll either be just the first version, which means no overlap,\n      // or the start and end versions, which might be the same version\n\n\n      if (vr.length > 1) {\n        const tail = this.versions[this.versions.length - 1];\n        ranges.push(vr[1] === tail ? `>=${vr[0]}` : vr[0] === vr[1] ? vr[0] : vr.join(' - '));\n      }\n    }\n\n    const metavuln = ranges.join(' || ').trim();\n    this.range = !metavuln ? '<0.0.0-0' : semver.simplifyRange(this.versions, metavuln, semverOpt);\n  } // returns true if marked as vulnerable, false if ok\n  // spec is a dependency specifier, for metavuln cases\n  // where the version might not be in the packument.  if\n  // we have the packument and spec is not provided, then\n  // we use the dependency version from the manifest.\n\n\n  testVersion(version, spec = null) {\n    const sv = String(version);\n    if (this[_versionVulnMemo].has(sv)) return this[_versionVulnMemo].get(sv);\n\n    const result = this[_testVersion](version, spec);\n\n    if (result) this[_markVulnerable](version);\n\n    this[_versionVulnMemo].set(sv, !!result);\n\n    return result;\n  }\n\n  [_markVulnerable](version) {\n    const sv = String(version);\n    if (!this.vulnerableVersions.includes(sv)) this.vulnerableVersions.push(sv);\n  }\n\n  [_testVersion](version, spec) {\n    const sv = String(version);\n    if (this.vulnerableVersions.includes(sv)) return true;\n\n    if (this.type === 'advisory') {\n      // advisory, just test range\n      return semver.satisfies(version, this.range, semverOpt);\n    } // check the dependency of this version on the vulnerable dep\n    // if we got a version that's not in the packument, fall back on\n    // the spec provided, if possible.\n\n\n    const mani = this[_packument].versions[version] || {\n      dependencies: {\n        [this.dependency]: spec\n      }\n    };\n    if (!spec) spec = getDepSpec(mani, this.dependency); // no dep, no vuln\n\n    if (spec === null) return false;\n\n    if (!semver.validRange(spec, semverOpt)) {\n      // not a semver range, nothing we can hope to do about it\n      return true;\n    }\n\n    const bd = mani.bundleDependencies;\n    const bundled = bd && bd.includes(this[_source].name); // XXX if bundled, then semver.intersects() means vulnerable\n    // else, pick a manifest and see if it can't be avoided\n    // try to pick a version of the dep that isn't vulnerable\n\n    const avoid = this[_source].range;\n    if (bundled) return semver.intersects(spec, avoid, semverOpt);\n    return this[_source].testSpec(spec);\n  }\n\n  testSpec(spec) {\n    // testing all the versions is a bit costly, and the spec tends to stay\n    // consistent across multiple versions, so memoize this as well, in case\n    // we're testing lots of versions.\n    const memo = this[_specVulnMemo];\n    if (memo.has(spec)) return memo.get(spec);\n\n    const res = this[_testSpec](spec);\n\n    memo.set(spec, res);\n    return res;\n  }\n\n  [_testSpec](spec) {\n    for (const v of this.versions) {\n      const satisfies = semver.satisfies(v, spec);\n      if (!satisfies) continue;\n      if (!this.testVersion(v)) return false;\n    } // either vulnerable, or not installable because nothing satisfied\n    // either way, best avoided.\n\n\n    return true;\n  }\n\n  [_testVersions](versions) {\n    if (!versions.length) return; // set of lists of versions\n\n    const versionSets = new Set();\n    versions = semver.sort(versions.map(v => semver.parse(v, semverOpt))); // start out with the versions grouped by major and minor\n\n    let last = versions[0].major + '.' + versions[0].minor;\n    let list = [];\n    versionSets.add(list);\n\n    for (const v of versions) {\n      const k = v.major + '.' + v.minor;\n\n      if (k !== last) {\n        last = k;\n        list = [];\n        versionSets.add(list);\n      }\n\n      list.push(v);\n    }\n\n    for (const list of versionSets) {\n      // it's common to have version lists like:\n      // 1.0.0\n      // 1.0.1-alpha.0\n      // 1.0.1-alpha.1\n      // ...\n      // 1.0.1-alpha.999\n      // 1.0.1\n      // 1.0.2-alpha.0\n      // ...\n      // 1.0.2-alpha.99\n      // 1.0.2\n      // with a huge number of prerelease versions that are not installable\n      // anyway.\n      // If mid has a prerelease tag, and list[0] does not, then walk it\n      // back until we hit a non-prerelease version\n      // If mid has a prerelease tag, and list[list.length-1] does not,\n      // then walk it forward until we hit a version without a prerelease tag\n      // Similarly, if the head/tail is a prerelease, but there is a non-pr\n      // version in the list, then start there instead.\n      let h = 0;\n      const origHeadVuln = this.testVersion(list[h]);\n\n      while (h < list.length && /-/.test(String(list[h]))) h++; // don't filter out the whole list!  they might all be pr's\n\n\n      if (h === list.length) h = 0;else if (origHeadVuln) {\n        // if the original was vulnerable, assume so are all of these\n        for (let hh = 0; hh < h; hh++) this[_markVulnerable](list[hh]);\n      }\n      let t = list.length - 1;\n      const origTailVuln = this.testVersion(list[t]);\n\n      while (t > h && /-/.test(String(list[t]))) t--; // don't filter out the whole list!  might all be pr's\n\n\n      if (t === h) t = list.length - 1;else if (origTailVuln) {\n        // if original tail was vulnerable, assume these are as well\n        for (let tt = list.length - 1; tt > t; tt--) this[_markVulnerable](list[tt]);\n      }\n      const headVuln = h === 0 ? origHeadVuln : this.testVersion(list[h]);\n      const tailVuln = t === list.length - 1 ? origTailVuln : this.testVersion(list[t]); // if head and tail both vulnerable, whole list is thrown out\n\n      if (headVuln && tailVuln) {\n        for (let v = h; v < t; v++) this[_markVulnerable](list[v]);\n\n        continue;\n      } // if length is 2 or 1, then we marked them all already\n\n\n      if (t < h + 2) continue;\n      const mid = Math.floor(list.length / 2);\n      const pre = list.slice(0, mid);\n      const post = list.slice(mid); // if the parent list wasn't prereleases, then drop pr tags\n      // from end of the pre list, and beginning of the post list,\n      // marking as vulnerable if the midpoint item we picked is.\n\n      if (!/-/.test(String(pre[0]))) {\n        const midVuln = this.testVersion(pre[pre.length - 1]);\n\n        while (/-/.test(String(pre[pre.length - 1]))) {\n          const v = pre.pop();\n          if (midVuln) this[_markVulnerable](v);\n        }\n      }\n\n      if (!/-/.test(String(post[post.length - 1]))) {\n        const midVuln = this.testVersion(post[0]);\n\n        while (/-/.test(String(post[0]))) {\n          const v = post.shift();\n          if (midVuln) this[_markVulnerable](v);\n        }\n      }\n\n      versionSets.add(pre);\n      versionSets.add(post);\n    }\n  }\n\n}\n\nmodule.exports = Advisory;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/@npmcli/metavuln-calculator/lib/advisory.js"],"names":["hash","require","semver","semverOpt","includePrerelease","loose","getDepSpec","_source","Symbol","_packument","_versionVulnMemo","_updated","_options","_specVulnMemo","_testVersion","_testVersions","_calculateRange","_markVulnerable","_testSpec","Advisory","constructor","name","source","options","id","dependency","type","title","url","severity","versions","vulnerableVersions","range","vulnerable_versions","Map","updated","packument","load","cached","TypeError","Object","assign","Error","expected","actual","pakuVersions","keys","allVersions","Set","versionsAdded","versionsRemoved","v","includes","push","sort","filter","unchanged","length","ranges","vulnVer","vr","test","tail","join","metavuln","trim","simplifyRange","testVersion","version","spec","sv","String","has","get","result","set","satisfies","mani","dependencies","validRange","bd","bundleDependencies","bundled","avoid","intersects","testSpec","memo","res","versionSets","map","parse","last","major","minor","list","add","k","h","origHeadVuln","hh","t","origTailVuln","tt","headVuln","tailVuln","mid","Math","floor","pre","slice","post","midVuln","pop","shift","module","exports"],"mappings":"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","sourcesContent":["const hash = require('./hash.js')\nconst semver = require('semver')\nconst semverOpt = { includePrerelease: true, loose: true }\nconst getDepSpec = require('./get-dep-spec.js')\n\n// any fields that we don't want in the cache need to be hidden\nconst _source = Symbol('source')\nconst _packument = Symbol('packument')\nconst _versionVulnMemo = Symbol('versionVulnMemo')\nconst _updated = Symbol('updated')\nconst _options = Symbol('options')\nconst _specVulnMemo = Symbol('specVulnMemo')\nconst _testVersion = Symbol('testVersion')\nconst _testVersions = Symbol('testVersions')\nconst _calculateRange = Symbol('calculateRange')\nconst _markVulnerable = Symbol('markVulnerable')\nconst _testSpec = Symbol('testSpec')\n\nclass Advisory {\n  constructor (name, source, options = {}) {\n    this.source = source.id\n    this[_source] = source\n    this[_options] = options\n    this.name = name\n    if (!source.name)\n      source.name = name\n\n    this.dependency = source.name\n\n    if (this.type === 'advisory') {\n      this.title = source.title\n      this.url = source.url\n    } else {\n      this.title = `Depends on vulnerable versions of ${source.name}`\n      this.url = null\n    }\n\n    this.severity = source.severity || 'high'\n    this.versions = []\n    this.vulnerableVersions = []\n\n    // advisories have the range, metavulns do not\n    // if an advisory doesn't specify range, assume all are vulnerable\n    this.range = this.type === 'advisory' ? source.vulnerable_versions || '*'\n      : null\n\n    this.id = hash(this)\n\n    this[_packument] = null\n    // memoized list of which versions are vulnerable\n    this[_versionVulnMemo] = new Map()\n    // memoized list of which dependency specs are vulnerable\n    this[_specVulnMemo] = new Map()\n    this[_updated] = false\n  }\n\n  // true if we updated from what we had in cache\n  get updated () {\n    return this[_updated]\n  }\n\n  get type () {\n    return this.dependency === this.name ? 'advisory' : 'metavuln'\n  }\n\n  get packument () {\n    return this[_packument]\n  }\n\n  // load up the data from a cache entry and a fetched packument\n  load (cached, packument) {\n    // basic data integrity gutcheck\n    if (!cached || typeof cached !== 'object')\n      throw new TypeError('invalid cached data, expected object')\n\n    if (!packument || typeof packument !== 'object')\n      throw new TypeError('invalid packument data, expected object')\n\n    if (cached.id && cached.id !== this.id) {\n      throw Object.assign(new Error('loading from incorrect cache entry'), {\n        expected: this.id,\n        actual: cached.id,\n      })\n    }\n    if (packument.name !== this.name) {\n      throw Object.assign(new Error('loading from incorrect packument'), {\n        expected: this.name,\n        actual: packument.name,\n      })\n    }\n    if (this[_packument])\n      throw new Error('advisory object already loaded')\n\n    // if we have a range from the initialization, and the cached\n    // data has a *different* range, then we know we have to recalc.\n    // just don't use the cached data, so we will definitely not match later\n    if (!this.range || cached.range && cached.range === this.range)\n      Object.assign(this, cached)\n\n    this[_packument] = packument\n\n    const pakuVersions = Object.keys(packument.versions)\n    const allVersions = new Set([...pakuVersions, ...this.versions])\n    const versionsAdded = []\n    const versionsRemoved = []\n    for (const v of allVersions) {\n      if (!this.versions.includes(v)) {\n        versionsAdded.push(v)\n        this.versions.push(v)\n      } else if (!pakuVersions.includes(v))\n        versionsRemoved.push(v)\n    }\n\n    // strip out any removed versions from our lists, and sort by semver\n    this.versions = semver.sort(this.versions.filter(v =>\n      !versionsRemoved.includes(v)), semverOpt)\n\n    // if no changes, then just return what we got from cache\n    // versions added or removed always means we changed\n    // otherwise, advisories change if the range changes, and\n    // metavulns change if the source was updated\n    const unchanged = this.type === 'advisory'\n      ? this.range && this.range === cached.range\n      : !this[_source].updated\n\n    // if the underlying source changed, by an advisory updating the\n    // range, or a source advisory being updated, then we have to re-check\n    // otherwise, only recheck the new ones.\n    this.vulnerableVersions = !unchanged ? []\n      : semver.sort(this.vulnerableVersions.filter(v =>\n        !versionsRemoved.includes(v)), semverOpt)\n\n    if (unchanged && !versionsAdded.length && !versionsRemoved.length) {\n      // nothing added or removed, nothing to do here.  use the cached copy.\n      return this\n    }\n\n    this[_updated] = true\n\n    // test any versions newly added\n    if (!unchanged || versionsAdded.length)\n      this[_testVersions](unchanged ? versionsAdded : this.versions)\n    this.vulnerableVersions = semver.sort(this.vulnerableVersions, semverOpt)\n\n    // metavulns have to calculate their range, since cache is invalidated\n    // advisories just get their range from the advisory above\n    if (this.type === 'metavuln')\n      this[_calculateRange]()\n\n    return this\n  }\n\n  [_calculateRange] () {\n    // calling semver.simplifyRange with a massive list of versions, and those\n    // versions all concatenated with `||` is a geometric CPU explosion!\n    // we can try to be a *little* smarter up front by doing x-y for all\n    // contiguous version sets in the list\n    const ranges = []\n    this.versions = semver.sort(this.versions)\n    this.vulnerableVersions = semver.sort(this.vulnerableVersions)\n    for (let v = 0, vulnVer = 0; v < this.versions.length; v++) {\n      // figure out the vulnerable subrange\n      const vr = [this.versions[v]]\n      while (v < this.versions.length) {\n        if (this.versions[v] !== this.vulnerableVersions[vulnVer]) {\n          // we don't test prerelease versions, so just skip past it\n          if (/-/.test(this.versions[v])) {\n            v++\n            continue\n          }\n          break\n        }\n        if (vr.length > 1)\n          vr[1] = this.versions[v]\n        else\n          vr.push(this.versions[v])\n        v++\n        vulnVer++\n      }\n      // it'll either be just the first version, which means no overlap,\n      // or the start and end versions, which might be the same version\n      if (vr.length > 1) {\n        const tail = this.versions[this.versions.length - 1]\n        ranges.push(vr[1] === tail ? `>=${vr[0]}`\n          : vr[0] === vr[1] ? vr[0]\n          : vr.join(' - '))\n      }\n    }\n    const metavuln = ranges.join(' || ').trim()\n    this.range = !metavuln ? '<0.0.0-0'\n      : semver.simplifyRange(this.versions, metavuln, semverOpt)\n  }\n\n  // returns true if marked as vulnerable, false if ok\n  // spec is a dependency specifier, for metavuln cases\n  // where the version might not be in the packument.  if\n  // we have the packument and spec is not provided, then\n  // we use the dependency version from the manifest.\n  testVersion (version, spec = null) {\n    const sv = String(version)\n    if (this[_versionVulnMemo].has(sv))\n      return this[_versionVulnMemo].get(sv)\n\n    const result = this[_testVersion](version, spec)\n    if (result)\n      this[_markVulnerable](version)\n    this[_versionVulnMemo].set(sv, !!result)\n    return result\n  }\n\n  [_markVulnerable] (version) {\n    const sv = String(version)\n    if (!this.vulnerableVersions.includes(sv))\n      this.vulnerableVersions.push(sv)\n  }\n\n  [_testVersion] (version, spec) {\n    const sv = String(version)\n    if (this.vulnerableVersions.includes(sv))\n      return true\n\n    if (this.type === 'advisory') {\n      // advisory, just test range\n      return semver.satisfies(version, this.range, semverOpt)\n    }\n\n    // check the dependency of this version on the vulnerable dep\n    // if we got a version that's not in the packument, fall back on\n    // the spec provided, if possible.\n    const mani = this[_packument].versions[version] || {\n      dependencies: {\n        [this.dependency]: spec,\n      },\n    }\n\n    if (!spec)\n      spec = getDepSpec(mani, this.dependency)\n\n    // no dep, no vuln\n    if (spec === null)\n      return false\n\n    if (!semver.validRange(spec, semverOpt)) {\n      // not a semver range, nothing we can hope to do about it\n      return true\n    }\n\n    const bd = mani.bundleDependencies\n    const bundled = bd && bd.includes(this[_source].name)\n    // XXX if bundled, then semver.intersects() means vulnerable\n    // else, pick a manifest and see if it can't be avoided\n    // try to pick a version of the dep that isn't vulnerable\n    const avoid = this[_source].range\n\n    if (bundled)\n      return semver.intersects(spec, avoid, semverOpt)\n\n    return this[_source].testSpec(spec)\n  }\n\n  testSpec (spec) {\n    // testing all the versions is a bit costly, and the spec tends to stay\n    // consistent across multiple versions, so memoize this as well, in case\n    // we're testing lots of versions.\n    const memo = this[_specVulnMemo]\n    if (memo.has(spec))\n      return memo.get(spec)\n\n    const res = this[_testSpec](spec)\n    memo.set(spec, res)\n    return res\n  }\n\n  [_testSpec] (spec) {\n    for (const v of this.versions) {\n      const satisfies = semver.satisfies(v, spec)\n      if (!satisfies)\n        continue\n      if (!this.testVersion(v))\n        return false\n    }\n    // either vulnerable, or not installable because nothing satisfied\n    // either way, best avoided.\n    return true\n  }\n\n  [_testVersions] (versions) {\n    if (!versions.length)\n      return\n\n    // set of lists of versions\n    const versionSets = new Set()\n    versions = semver.sort(versions.map(v => semver.parse(v, semverOpt)))\n\n    // start out with the versions grouped by major and minor\n    let last = versions[0].major + '.' + versions[0].minor\n    let list = []\n    versionSets.add(list)\n    for (const v of versions) {\n      const k = v.major + '.' + v.minor\n      if (k !== last) {\n        last = k\n        list = []\n        versionSets.add(list)\n      }\n      list.push(v)\n    }\n\n    for (const list of versionSets) {\n      // it's common to have version lists like:\n      // 1.0.0\n      // 1.0.1-alpha.0\n      // 1.0.1-alpha.1\n      // ...\n      // 1.0.1-alpha.999\n      // 1.0.1\n      // 1.0.2-alpha.0\n      // ...\n      // 1.0.2-alpha.99\n      // 1.0.2\n      // with a huge number of prerelease versions that are not installable\n      // anyway.\n      // If mid has a prerelease tag, and list[0] does not, then walk it\n      // back until we hit a non-prerelease version\n      // If mid has a prerelease tag, and list[list.length-1] does not,\n      // then walk it forward until we hit a version without a prerelease tag\n      // Similarly, if the head/tail is a prerelease, but there is a non-pr\n      // version in the list, then start there instead.\n      let h = 0\n      const origHeadVuln = this.testVersion(list[h])\n      while (h < list.length && /-/.test(String(list[h])))\n        h++\n\n      // don't filter out the whole list!  they might all be pr's\n      if (h === list.length)\n        h = 0\n      else if (origHeadVuln) {\n        // if the original was vulnerable, assume so are all of these\n        for (let hh = 0; hh < h; hh++)\n          this[_markVulnerable](list[hh])\n      }\n\n      let t = list.length - 1\n      const origTailVuln = this.testVersion(list[t])\n      while (t > h && /-/.test(String(list[t])))\n        t--\n\n      // don't filter out the whole list!  might all be pr's\n      if (t === h)\n        t = list.length - 1\n      else if (origTailVuln) {\n        // if original tail was vulnerable, assume these are as well\n        for (let tt = list.length - 1; tt > t; tt--)\n          this[_markVulnerable](list[tt])\n      }\n\n      const headVuln = h === 0 ? origHeadVuln\n        : this.testVersion(list[h])\n\n      const tailVuln = t === list.length - 1 ? origTailVuln\n        : this.testVersion(list[t])\n\n      // if head and tail both vulnerable, whole list is thrown out\n      if (headVuln && tailVuln) {\n        for (let v = h; v < t; v++)\n          this[_markVulnerable](list[v])\n        continue\n      }\n\n      // if length is 2 or 1, then we marked them all already\n      if (t < h + 2)\n        continue\n\n      const mid = Math.floor(list.length / 2)\n      const pre = list.slice(0, mid)\n      const post = list.slice(mid)\n\n      // if the parent list wasn't prereleases, then drop pr tags\n      // from end of the pre list, and beginning of the post list,\n      // marking as vulnerable if the midpoint item we picked is.\n      if (!/-/.test(String(pre[0]))) {\n        const midVuln = this.testVersion(pre[pre.length - 1])\n        while (/-/.test(String(pre[pre.length - 1]))) {\n          const v = pre.pop()\n          if (midVuln)\n            this[_markVulnerable](v)\n        }\n      }\n\n      if (!/-/.test(String(post[post.length - 1]))) {\n        const midVuln = this.testVersion(post[0])\n        while (/-/.test(String(post[0]))) {\n          const v = post.shift()\n          if (midVuln)\n            this[_markVulnerable](v)\n        }\n      }\n\n      versionSets.add(pre)\n      versionSets.add(post)\n    }\n  }\n}\n\nmodule.exports = Advisory\n"]},"metadata":{},"sourceType":"script"}