{"ast":null,"code":"'use strict';\n\nconst fetch = require('npm-registry-fetch');\n\nconst {\n  HttpErrorBase\n} = require('npm-registry-fetch/errors.js');\n\nconst os = require('os');\n\nconst {\n  URL\n} = require('url'); // try loginWeb, catch the \"not supported\" message and fall back to couch\n\n\nconst login = (opener, prompter, opts = {}) => {\n  const {\n    creds\n  } = opts;\n  return loginWeb(opener, opts).catch(er => {\n    if (er instanceof WebLoginNotSupported) {\n      process.emit('log', 'verbose', 'web login not supported, trying couch');\n      return prompter(creds).then(data => loginCouch(data.username, data.password, opts));\n    } else {\n      throw er;\n    }\n  });\n};\n\nconst adduser = (opener, prompter, opts = {}) => {\n  const {\n    creds\n  } = opts;\n  return adduserWeb(opener, opts).catch(er => {\n    if (er instanceof WebLoginNotSupported) {\n      process.emit('log', 'verbose', 'web adduser not supported, trying couch');\n      return prompter(creds).then(data => adduserCouch(data.username, data.email, data.password, opts));\n    } else {\n      throw er;\n    }\n  });\n};\n\nconst adduserWeb = (opener, opts = {}) => {\n  process.emit('log', 'verbose', 'web adduser', 'before first POST');\n  return webAuth(opener, opts, {\n    create: true\n  });\n};\n\nconst loginWeb = (opener, opts = {}) => {\n  process.emit('log', 'verbose', 'web login', 'before first POST');\n  return webAuth(opener, opts, {});\n};\n\nconst isValidUrl = u => {\n  try {\n    return /^https?:$/.test(new URL(u).protocol);\n  } catch (er) {\n    return false;\n  }\n};\n\nconst webAuth = (opener, opts, body) => {\n  const {\n    hostname\n  } = opts;\n  body.hostname = hostname || os.hostname();\n  const target = '/-/v1/login';\n  return fetch(target, { ...opts,\n    method: 'POST',\n    body\n  }).then(res => {\n    return Promise.all([res, res.json()]);\n  }).then(([res, content]) => {\n    const {\n      doneUrl,\n      loginUrl\n    } = content;\n    process.emit('log', 'verbose', 'web auth', 'got response', content);\n\n    if (!isValidUrl(doneUrl) || !isValidUrl(loginUrl)) {\n      throw new WebLoginInvalidResponse('POST', res, content);\n    }\n\n    return content;\n  }).then(({\n    doneUrl,\n    loginUrl\n  }) => {\n    process.emit('log', 'verbose', 'web auth', 'opening url pair');\n    return opener(loginUrl).then(() => webAuthCheckLogin(doneUrl, { ...opts,\n      cache: false\n    }));\n  }).catch(er => {\n    if (er.statusCode >= 400 && er.statusCode <= 499 || er.statusCode === 500) {\n      throw new WebLoginNotSupported('POST', {\n        status: er.statusCode,\n        headers: {\n          raw: () => er.headers\n        }\n      }, er.body);\n    } else {\n      throw er;\n    }\n  });\n};\n\nconst webAuthCheckLogin = (doneUrl, opts) => {\n  return fetch(doneUrl, opts).then(res => {\n    return Promise.all([res, res.json()]);\n  }).then(([res, content]) => {\n    if (res.status === 200) {\n      if (!content.token) {\n        throw new WebLoginInvalidResponse('GET', res, content);\n      } else {\n        return content;\n      }\n    } else if (res.status === 202) {\n      const retry = +res.headers.get('retry-after') * 1000;\n\n      if (retry > 0) {\n        return sleep(retry).then(() => webAuthCheckLogin(doneUrl, opts));\n      } else {\n        return webAuthCheckLogin(doneUrl, opts);\n      }\n    } else {\n      throw new WebLoginInvalidResponse('GET', res, content);\n    }\n  });\n};\n\nconst adduserCouch = (username, email, password, opts = {}) => {\n  const body = {\n    _id: 'org.couchdb.user:' + username,\n    name: username,\n    password: password,\n    email: email,\n    type: 'user',\n    roles: [],\n    date: new Date().toISOString()\n  };\n  const logObj = { ...body,\n    password: 'XXXXX'\n  };\n  process.emit('log', 'verbose', 'adduser', 'before first PUT', logObj);\n  const target = '/-/user/org.couchdb.user:' + encodeURIComponent(username);\n  return fetch.json(target, { ...opts,\n    method: 'PUT',\n    body\n  }).then(result => {\n    result.username = username;\n    return result;\n  });\n};\n\nconst loginCouch = (username, password, opts = {}) => {\n  const body = {\n    _id: 'org.couchdb.user:' + username,\n    name: username,\n    password: password,\n    type: 'user',\n    roles: [],\n    date: new Date().toISOString()\n  };\n  const logObj = { ...body,\n    password: 'XXXXX'\n  };\n  process.emit('log', 'verbose', 'login', 'before first PUT', logObj);\n  const target = '-/user/org.couchdb.user:' + encodeURIComponent(username);\n  return fetch.json(target, { ...opts,\n    method: 'PUT',\n    body\n  }).catch(err => {\n    if (err.code === 'E400') {\n      err.message = `There is no user with the username \"${username}\".`;\n      throw err;\n    }\n\n    if (err.code !== 'E409') throw err;\n    return fetch.json(target, { ...opts,\n      query: {\n        write: true\n      }\n    }).then(result => {\n      Object.keys(result).forEach(k => {\n        if (!body[k] || k === 'roles') {\n          body[k] = result[k];\n        }\n      });\n      const {\n        otp\n      } = opts;\n      return fetch.json(`${target}/-rev/${body._rev}`, { ...opts,\n        method: 'PUT',\n        body,\n        forceAuth: {\n          username,\n          password: Buffer.from(password, 'utf8').toString('base64'),\n          otp\n        }\n      });\n    });\n  }).then(result => {\n    result.username = username;\n    return result;\n  });\n};\n\nconst get = (opts = {}) => fetch.json('/-/npm/v1/user', opts);\n\nconst set = (profile, opts = {}) => {\n  Object.keys(profile).forEach(key => {\n    // profile keys can't be empty strings, but they CAN be null\n    if (profile[key] === '') profile[key] = null;\n  });\n  return fetch.json('/-/npm/v1/user', { ...opts,\n    method: 'POST',\n    body: profile\n  });\n};\n\nconst listTokens = (opts = {}) => {\n  const untilLastPage = (href, objects) => {\n    return fetch.json(href, opts).then(result => {\n      objects = objects ? objects.concat(result.objects) : result.objects;\n\n      if (result.urls.next) {\n        return untilLastPage(result.urls.next, objects);\n      } else {\n        return objects;\n      }\n    });\n  };\n\n  return untilLastPage('/-/npm/v1/tokens');\n};\n\nconst removeToken = (tokenKey, opts = {}) => {\n  const target = `/-/npm/v1/tokens/token/${tokenKey}`;\n  return fetch(target, { ...opts,\n    method: 'DELETE',\n    ignoreBody: true\n  }).then(() => null);\n};\n\nconst createToken = (password, readonly, cidrs, opts = {}) => {\n  return fetch.json('/-/npm/v1/tokens', { ...opts,\n    method: 'POST',\n    body: {\n      password: password,\n      readonly: readonly,\n      cidr_whitelist: cidrs\n    }\n  });\n};\n\nclass WebLoginInvalidResponse extends HttpErrorBase {\n  constructor(method, res, body) {\n    super(method, res, body);\n    this.message = 'Invalid response from web login endpoint';\n    Error.captureStackTrace(this, WebLoginInvalidResponse);\n  }\n\n}\n\nclass WebLoginNotSupported extends HttpErrorBase {\n  constructor(method, res, body) {\n    super(method, res, body);\n    this.message = 'Web login not supported';\n    this.code = 'ENYI';\n    Error.captureStackTrace(this, WebLoginNotSupported);\n  }\n\n}\n\nconst sleep = ms => new Promise((resolve, reject) => setTimeout(resolve, ms));\n\nmodule.exports = {\n  adduserCouch,\n  loginCouch,\n  adduserWeb,\n  loginWeb,\n  login,\n  adduser,\n  get,\n  set,\n  listTokens,\n  removeToken,\n  createToken\n};","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/npm-profile/index.js"],"names":["fetch","require","HttpErrorBase","os","URL","login","opener","prompter","opts","creds","loginWeb","catch","er","WebLoginNotSupported","process","emit","then","data","loginCouch","username","password","adduser","adduserWeb","adduserCouch","email","webAuth","create","isValidUrl","u","test","protocol","body","hostname","target","method","res","Promise","all","json","content","doneUrl","loginUrl","WebLoginInvalidResponse","webAuthCheckLogin","cache","statusCode","status","headers","raw","token","retry","get","sleep","_id","name","type","roles","date","Date","toISOString","logObj","encodeURIComponent","result","err","code","message","query","write","Object","keys","forEach","k","otp","_rev","forceAuth","Buffer","from","toString","set","profile","key","listTokens","untilLastPage","href","objects","concat","urls","next","removeToken","tokenKey","ignoreBody","createToken","readonly","cidrs","cidr_whitelist","constructor","Error","captureStackTrace","ms","resolve","reject","setTimeout","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst fetch = require('npm-registry-fetch')\nconst { HttpErrorBase } = require('npm-registry-fetch/errors.js')\nconst os = require('os')\nconst { URL } = require('url')\n\n// try loginWeb, catch the \"not supported\" message and fall back to couch\nconst login = (opener, prompter, opts = {}) => {\n  const { creds } = opts\n  return loginWeb(opener, opts).catch(er => {\n    if (er instanceof WebLoginNotSupported) {\n      process.emit('log', 'verbose', 'web login not supported, trying couch')\n      return prompter(creds)\n        .then(data => loginCouch(data.username, data.password, opts))\n    } else {\n      throw er\n    }\n  })\n}\n\nconst adduser = (opener, prompter, opts = {}) => {\n  const { creds } = opts\n  return adduserWeb(opener, opts).catch(er => {\n    if (er instanceof WebLoginNotSupported) {\n      process.emit('log', 'verbose', 'web adduser not supported, trying couch')\n      return prompter(creds)\n        .then(data => adduserCouch(data.username, data.email, data.password, opts))\n    } else {\n      throw er\n    }\n  })\n}\n\nconst adduserWeb = (opener, opts = {}) => {\n  process.emit('log', 'verbose', 'web adduser', 'before first POST')\n  return webAuth(opener, opts, { create: true })\n}\n\nconst loginWeb = (opener, opts = {}) => {\n  process.emit('log', 'verbose', 'web login', 'before first POST')\n  return webAuth(opener, opts, {})\n}\n\nconst isValidUrl = u => {\n  try {\n    return /^https?:$/.test(new URL(u).protocol)\n  } catch (er) {\n    return false\n  }\n}\n\nconst webAuth = (opener, opts, body) => {\n  const { hostname } = opts\n  body.hostname = hostname || os.hostname()\n  const target = '/-/v1/login'\n  return fetch(target, {\n    ...opts,\n    method: 'POST',\n    body\n  }).then(res => {\n    return Promise.all([res, res.json()])\n  }).then(([res, content]) => {\n    const { doneUrl, loginUrl } = content\n    process.emit('log', 'verbose', 'web auth', 'got response', content)\n    if (!isValidUrl(doneUrl) || !isValidUrl(loginUrl)) {\n      throw new WebLoginInvalidResponse('POST', res, content)\n    }\n    return content\n  }).then(({ doneUrl, loginUrl }) => {\n    process.emit('log', 'verbose', 'web auth', 'opening url pair')\n    return opener(loginUrl).then(\n      () => webAuthCheckLogin(doneUrl, { ...opts, cache: false })\n    )\n  }).catch(er => {\n    if ((er.statusCode >= 400 && er.statusCode <= 499) || er.statusCode === 500) {\n      throw new WebLoginNotSupported('POST', {\n        status: er.statusCode,\n        headers: { raw: () => er.headers }\n      }, er.body)\n    } else {\n      throw er\n    }\n  })\n}\n\nconst webAuthCheckLogin = (doneUrl, opts) => {\n  return fetch(doneUrl, opts).then(res => {\n    return Promise.all([res, res.json()])\n  }).then(([res, content]) => {\n    if (res.status === 200) {\n      if (!content.token) {\n        throw new WebLoginInvalidResponse('GET', res, content)\n      } else {\n        return content\n      }\n    } else if (res.status === 202) {\n      const retry = +res.headers.get('retry-after') * 1000\n      if (retry > 0) {\n        return sleep(retry).then(() => webAuthCheckLogin(doneUrl, opts))\n      } else {\n        return webAuthCheckLogin(doneUrl, opts)\n      }\n    } else {\n      throw new WebLoginInvalidResponse('GET', res, content)\n    }\n  })\n}\n\nconst adduserCouch = (username, email, password, opts = {}) => {\n  const body = {\n    _id: 'org.couchdb.user:' + username,\n    name: username,\n    password: password,\n    email: email,\n    type: 'user',\n    roles: [],\n    date: new Date().toISOString()\n  }\n  const logObj = {\n    ...body,\n    password: 'XXXXX'\n  }\n  process.emit('log', 'verbose', 'adduser', 'before first PUT', logObj)\n\n  const target = '/-/user/org.couchdb.user:' + encodeURIComponent(username)\n  return fetch.json(target, {\n    ...opts,\n    method: 'PUT',\n    body\n  }).then(result => {\n    result.username = username\n    return result\n  })\n}\n\nconst loginCouch = (username, password, opts = {}) => {\n  const body = {\n    _id: 'org.couchdb.user:' + username,\n    name: username,\n    password: password,\n    type: 'user',\n    roles: [],\n    date: new Date().toISOString()\n  }\n  const logObj = {\n    ...body,\n    password: 'XXXXX'\n  }\n  process.emit('log', 'verbose', 'login', 'before first PUT', logObj)\n\n  const target = '-/user/org.couchdb.user:' + encodeURIComponent(username)\n  return fetch.json(target, {\n    ...opts,\n    method: 'PUT',\n    body\n  }).catch(err => {\n    if (err.code === 'E400') {\n      err.message = `There is no user with the username \"${username}\".`\n      throw err\n    }\n    if (err.code !== 'E409') throw err\n    return fetch.json(target, {\n      ...opts,\n      query: { write: true }\n    }).then(result => {\n      Object.keys(result).forEach(k => {\n        if (!body[k] || k === 'roles') {\n          body[k] = result[k]\n        }\n      })\n      const { otp } = opts\n      return fetch.json(`${target}/-rev/${body._rev}`, {\n        ...opts,\n        method: 'PUT',\n        body,\n        forceAuth: {\n          username,\n          password: Buffer.from(password, 'utf8').toString('base64'),\n          otp\n        }\n      })\n    })\n  }).then(result => {\n    result.username = username\n    return result\n  })\n}\n\nconst get = (opts = {}) => fetch.json('/-/npm/v1/user', opts)\n\nconst set = (profile, opts = {}) => {\n  Object.keys(profile).forEach(key => {\n    // profile keys can't be empty strings, but they CAN be null\n    if (profile[key] === '') profile[key] = null\n  })\n  return fetch.json('/-/npm/v1/user', {\n    ...opts,\n    method: 'POST',\n    body: profile\n  })\n}\n\nconst listTokens = (opts = {}) => {\n  const untilLastPage = (href, objects) => {\n    return fetch.json(href, opts).then(result => {\n      objects = objects ? objects.concat(result.objects) : result.objects\n      if (result.urls.next) {\n        return untilLastPage(result.urls.next, objects)\n      } else {\n        return objects\n      }\n    })\n  }\n  return untilLastPage('/-/npm/v1/tokens')\n}\n\nconst removeToken = (tokenKey, opts = {}) => {\n  const target = `/-/npm/v1/tokens/token/${tokenKey}`\n  return fetch(target, {\n    ...opts,\n    method: 'DELETE',\n    ignoreBody: true\n  }).then(() => null)\n}\n\nconst createToken = (password, readonly, cidrs, opts = {}) => {\n  return fetch.json('/-/npm/v1/tokens', {\n    ...opts,\n    method: 'POST',\n    body: {\n      password: password,\n      readonly: readonly,\n      cidr_whitelist: cidrs\n    }\n  })\n}\n\nclass WebLoginInvalidResponse extends HttpErrorBase {\n  constructor (method, res, body) {\n    super(method, res, body)\n    this.message = 'Invalid response from web login endpoint'\n    Error.captureStackTrace(this, WebLoginInvalidResponse)\n  }\n}\n\nclass WebLoginNotSupported extends HttpErrorBase {\n  constructor (method, res, body) {\n    super(method, res, body)\n    this.message = 'Web login not supported'\n    this.code = 'ENYI'\n    Error.captureStackTrace(this, WebLoginNotSupported)\n  }\n}\n\nconst sleep = (ms) =>\n  new Promise((resolve, reject) => setTimeout(resolve, ms))\n\nmodule.exports = {\n  adduserCouch,\n  loginCouch,\n  adduserWeb,\n  loginWeb,\n  login,\n  adduser,\n  get,\n  set,\n  listTokens,\n  removeToken,\n  createToken\n}\n"]},"metadata":{},"sourceType":"script"}