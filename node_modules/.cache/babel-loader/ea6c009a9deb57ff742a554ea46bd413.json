{"ast":null,"code":"// Perform a depth-first walk of a tree.\n//\n// `visit(node)` is called when the node is first encountered.\n// `leave(node, children)` is called when all of the node's children\n// have been left or (in the case of cyclic graphs) visited.\n//\n// Only one of visit or leave is required.  (Technically both are optional,\n// but if you don't provide at least one, the tree is just walked without\n// doing anything, which is a bit pointless.)  If visit is provided, and\n// leave is not, then this is a root->leaf traversal.  If leave is provided,\n// and visit is not, then it's leaf->root.  Both can be provided for a\n// map-reduce operation.\n//\n// If either visit or leave return a Promise for any node, then the\n// walk returns a Promise.\nconst depthDescent = require('./depth-descent.js');\n\nconst depth = ({\n  visit,\n  leave,\n  filter = () => true,\n  seen = new Map(),\n  getChildren,\n  tree\n}) => {\n  if (!leave) return depthDescent({\n    visit,\n    filter,\n    getChildren,\n    tree\n  });\n  if (seen.has(tree)) return seen.get(tree);\n  seen.set(tree, null);\n\n  const visitNode = () => {\n    const res = visit ? visit(tree) : tree;\n\n    if (isPromise(res)) {\n      const fullResult = res.then(res => {\n        seen.set(tree, res);\n        return kidNodes();\n      });\n      seen.set(tree, fullResult);\n      return fullResult;\n    } else {\n      seen.set(tree, res);\n      return kidNodes();\n    }\n  };\n\n  const kidNodes = () => {\n    const kids = getChildren(tree, seen.get(tree));\n    return isPromise(kids) ? kids.then(processKids) : processKids(kids);\n  };\n\n  const processKids = kidNodes => {\n    const kids = (kidNodes || []).filter(filter).map(kid => depth({\n      visit,\n      leave,\n      filter,\n      seen,\n      getChildren,\n      tree: kid\n    }));\n    return kids.some(isPromise) ? Promise.all(kids).then(leaveNode) : leaveNode(kids);\n  };\n\n  const leaveNode = kids => {\n    const res = leave(seen.get(tree), kids);\n    seen.set(tree, res); // if it's a promise at this point, the caller deals with it\n\n    return res;\n  };\n\n  return visitNode();\n};\n\nconst isPromise = p => p && typeof p.then === 'function';\n\nmodule.exports = depth;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/treeverse/lib/depth.js"],"names":["depthDescent","require","depth","visit","leave","filter","seen","Map","getChildren","tree","has","get","set","visitNode","res","isPromise","fullResult","then","kidNodes","kids","processKids","map","kid","some","Promise","all","leaveNode","p","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,YAAY,GAAGC,OAAO,CAAC,oBAAD,CAA5B;;AACA,MAAMC,KAAK,GAAG,CAAC;AACbC,EAAAA,KADa;AAEbC,EAAAA,KAFa;AAGbC,EAAAA,MAAM,GAAG,MAAM,IAHF;AAIbC,EAAAA,IAAI,GAAG,IAAIC,GAAJ,EAJM;AAKbC,EAAAA,WALa;AAMbC,EAAAA;AANa,CAAD,KAOR;AACJ,MAAI,CAACL,KAAL,EACE,OAAOJ,YAAY,CAAC;AAAEG,IAAAA,KAAF;AAASE,IAAAA,MAAT;AAAiBG,IAAAA,WAAjB;AAA8BC,IAAAA;AAA9B,GAAD,CAAnB;AAEF,MAAIH,IAAI,CAACI,GAAL,CAASD,IAAT,CAAJ,EACE,OAAOH,IAAI,CAACK,GAAL,CAASF,IAAT,CAAP;AAEFH,EAAAA,IAAI,CAACM,GAAL,CAASH,IAAT,EAAe,IAAf;;AAEA,QAAMI,SAAS,GAAG,MAAM;AACtB,UAAMC,GAAG,GAAGX,KAAK,GAAGA,KAAK,CAACM,IAAD,CAAR,GAAiBA,IAAlC;;AACA,QAAIM,SAAS,CAACD,GAAD,CAAb,EAAoB;AAClB,YAAME,UAAU,GAAGF,GAAG,CAACG,IAAJ,CAASH,GAAG,IAAI;AACjCR,QAAAA,IAAI,CAACM,GAAL,CAASH,IAAT,EAAeK,GAAf;AACA,eAAOI,QAAQ,EAAf;AACD,OAHkB,CAAnB;AAIAZ,MAAAA,IAAI,CAACM,GAAL,CAASH,IAAT,EAAeO,UAAf;AACA,aAAOA,UAAP;AACD,KAPD,MAOO;AACLV,MAAAA,IAAI,CAACM,GAAL,CAASH,IAAT,EAAeK,GAAf;AACA,aAAOI,QAAQ,EAAf;AACD;AACF,GAbD;;AAeA,QAAMA,QAAQ,GAAG,MAAM;AACrB,UAAMC,IAAI,GAAGX,WAAW,CAACC,IAAD,EAAOH,IAAI,CAACK,GAAL,CAASF,IAAT,CAAP,CAAxB;AACA,WAAOM,SAAS,CAACI,IAAD,CAAT,GAAkBA,IAAI,CAACF,IAAL,CAAUG,WAAV,CAAlB,GAA2CA,WAAW,CAACD,IAAD,CAA7D;AACD,GAHD;;AAKA,QAAMC,WAAW,GAAGF,QAAQ,IAAI;AAC9B,UAAMC,IAAI,GAAG,CAACD,QAAQ,IAAI,EAAb,EAAiBb,MAAjB,CAAwBA,MAAxB,EAAgCgB,GAAhC,CAAoCC,GAAG,IAClDpB,KAAK,CAAC;AAACC,MAAAA,KAAD;AAAQC,MAAAA,KAAR;AAAeC,MAAAA,MAAf;AAAuBC,MAAAA,IAAvB;AAA6BE,MAAAA,WAA7B;AAA0CC,MAAAA,IAAI,EAAEa;AAAhD,KAAD,CADM,CAAb;AAEA,WAAOH,IAAI,CAACI,IAAL,CAAUR,SAAV,IACHS,OAAO,CAACC,GAAR,CAAYN,IAAZ,EAAkBF,IAAlB,CAAuBS,SAAvB,CADG,GAEHA,SAAS,CAACP,IAAD,CAFb;AAGD,GAND;;AAQA,QAAMO,SAAS,GAAGP,IAAI,IAAI;AACxB,UAAML,GAAG,GAAGV,KAAK,CAACE,IAAI,CAACK,GAAL,CAASF,IAAT,CAAD,EAAiBU,IAAjB,CAAjB;AACAb,IAAAA,IAAI,CAACM,GAAL,CAASH,IAAT,EAAeK,GAAf,EAFwB,CAGxB;;AACA,WAAOA,GAAP;AACD,GALD;;AAOA,SAAOD,SAAS,EAAhB;AACD,CApDD;;AAsDA,MAAME,SAAS,GAAGY,CAAC,IAAIA,CAAC,IAAI,OAAOA,CAAC,CAACV,IAAT,KAAkB,UAA9C;;AAEAW,MAAM,CAACC,OAAP,GAAiB3B,KAAjB","sourcesContent":["// Perform a depth-first walk of a tree.\n//\n// `visit(node)` is called when the node is first encountered.\n// `leave(node, children)` is called when all of the node's children\n// have been left or (in the case of cyclic graphs) visited.\n//\n// Only one of visit or leave is required.  (Technically both are optional,\n// but if you don't provide at least one, the tree is just walked without\n// doing anything, which is a bit pointless.)  If visit is provided, and\n// leave is not, then this is a root->leaf traversal.  If leave is provided,\n// and visit is not, then it's leaf->root.  Both can be provided for a\n// map-reduce operation.\n//\n// If either visit or leave return a Promise for any node, then the\n// walk returns a Promise.\n\nconst depthDescent = require('./depth-descent.js')\nconst depth = ({\n  visit,\n  leave,\n  filter = () => true,\n  seen = new Map(),\n  getChildren,\n  tree,\n}) => {\n  if (!leave)\n    return depthDescent({ visit, filter, getChildren, tree })\n\n  if (seen.has(tree))\n    return seen.get(tree)\n\n  seen.set(tree, null)\n\n  const visitNode = () => {\n    const res = visit ? visit(tree) : tree\n    if (isPromise(res)) {\n      const fullResult = res.then(res => {\n        seen.set(tree, res)\n        return kidNodes()\n      })\n      seen.set(tree, fullResult)\n      return fullResult\n    } else {\n      seen.set(tree, res)\n      return kidNodes()\n    }\n  }\n\n  const kidNodes = () => {\n    const kids = getChildren(tree, seen.get(tree))\n    return isPromise(kids) ? kids.then(processKids) : processKids(kids)\n  }\n\n  const processKids = kidNodes => {\n    const kids = (kidNodes || []).filter(filter).map(kid =>\n      depth({visit, leave, filter, seen, getChildren, tree: kid}))\n    return kids.some(isPromise)\n      ? Promise.all(kids).then(leaveNode)\n      : leaveNode(kids)\n  }\n\n  const leaveNode = kids => {\n    const res = leave(seen.get(tree), kids)\n    seen.set(tree, res)\n    // if it's a promise at this point, the caller deals with it\n    return res\n  }\n\n  return visitNode()\n}\n\nconst isPromise = p => p && typeof p.then === 'function'\n\nmodule.exports = depth\n"]},"metadata":{},"sourceType":"script"}