{"ast":null,"code":"const tar = require('tar');\n\nconst minimatch = require('minimatch');\n\nconst normalizeMatch = str => str.replace(/\\\\+/g, '/').replace(/^\\.\\/|^\\./, ''); // files and refs are mutating params\n// filterFiles, item, prefix and opts are read-only options\n\n\nconst untar = ({\n  files,\n  refs\n}, {\n  filterFiles,\n  item,\n  prefix\n}) => {\n  tar.list({\n    filter: (path, entry) => {\n      const fileMatch = () => !filterFiles.length || filterFiles.some(f => {\n        const pattern = normalizeMatch(f);\n        return minimatch(normalizeMatch(path), `{package/,}${pattern}`, {\n          matchBase: pattern.startsWith('*')\n        });\n      }); // expands usage of simple path filters, e.g: lib or src/\n\n\n      const folderMatch = () => filterFiles.some(f => normalizeMatch(path).startsWith(normalizeMatch(f)) || normalizeMatch(path).startsWith(`package/${normalizeMatch(f)}`));\n\n      if (entry.type === 'File' && (fileMatch() || folderMatch())) {\n        const key = path.replace(/^[^/]+\\/?/, '');\n        files.add(key); // should skip reading file when using --name-only option\n\n        let content;\n\n        try {\n          entry.setEncoding('utf8');\n          content = entry.concat();\n        } catch (e) {\n          /* istanbul ignore next */\n          throw Object.assign(new Error('failed to read files'), {\n            code: 'EDIFFUNTAR'\n          });\n        }\n\n        refs.set(`${prefix}${key}`, {\n          content,\n          mode: `100${entry.mode.toString(8)}`\n        });\n        return true;\n      }\n    }\n  }).on('error',\n  /* istanbul ignore next */\n  e => {\n    throw e;\n  }).end(item);\n};\n\nconst readTarballs = async (tarballs, opts = {}) => {\n  const files = new Set();\n  const refs = new Map();\n  const arr = [].concat(tarballs);\n  const filterFiles = opts.diffFiles || [];\n\n  for (const i of arr) {\n    untar({\n      files,\n      refs\n    }, {\n      item: i.item,\n      prefix: i.prefix,\n      filterFiles\n    });\n  } // await to read all content from included files\n\n\n  const allRefs = [...refs.values()];\n  const contents = await Promise.all(allRefs.map(async ref => ref.content));\n  contents.forEach((content, index) => {\n    allRefs[index].content = content;\n  });\n  return {\n    files,\n    refs\n  };\n};\n\nmodule.exports = readTarballs;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/libnpmdiff/lib/untar.js"],"names":["tar","require","minimatch","normalizeMatch","str","replace","untar","files","refs","filterFiles","item","prefix","list","filter","path","entry","fileMatch","length","some","f","pattern","matchBase","startsWith","folderMatch","type","key","add","content","setEncoding","concat","e","Object","assign","Error","code","set","mode","toString","on","end","readTarballs","tarballs","opts","Set","Map","arr","diffFiles","i","allRefs","values","contents","Promise","all","map","ref","forEach","index","module","exports"],"mappings":"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","sourcesContent":["const tar = require('tar')\nconst minimatch = require('minimatch')\n\nconst normalizeMatch = str => str\n  .replace(/\\\\+/g, '/')\n  .replace(/^\\.\\/|^\\./, '')\n\n// files and refs are mutating params\n// filterFiles, item, prefix and opts are read-only options\nconst untar = ({ files, refs }, { filterFiles, item, prefix }) => {\n  tar.list({\n    filter: (path, entry) => {\n      const fileMatch = () =>\n        (!filterFiles.length ||\n          filterFiles.some(f => {\n            const pattern = normalizeMatch(f)\n            return minimatch(\n              normalizeMatch(path),\n              `{package/,}${pattern}`,\n              { matchBase: pattern.startsWith('*') }\n            )\n          }))\n\n      // expands usage of simple path filters, e.g: lib or src/\n      const folderMatch = () =>\n        filterFiles.some(f =>\n          normalizeMatch(path).startsWith(normalizeMatch(f)) ||\n          normalizeMatch(path).startsWith(`package/${normalizeMatch(f)}`))\n\n      if (\n        entry.type === 'File' &&\n        (fileMatch() || folderMatch())\n      ) {\n        const key = path.replace(/^[^/]+\\/?/, '')\n        files.add(key)\n\n        // should skip reading file when using --name-only option\n        let content\n        try {\n          entry.setEncoding('utf8')\n          content = entry.concat()\n        } catch (e) {\n          /* istanbul ignore next */\n          throw Object.assign(\n            new Error('failed to read files'),\n            { code: 'EDIFFUNTAR' }\n          )\n        }\n\n        refs.set(`${prefix}${key}`, {\n          content,\n          mode: `100${entry.mode.toString(8)}`,\n        })\n        return true\n      }\n    },\n  })\n    .on('error', /* istanbul ignore next */ e => {\n      throw e\n    })\n    .end(item)\n}\n\nconst readTarballs = async (tarballs, opts = {}) => {\n  const files = new Set()\n  const refs = new Map()\n  const arr = [].concat(tarballs)\n\n  const filterFiles = opts.diffFiles || []\n\n  for (const i of arr) {\n    untar({\n      files,\n      refs,\n    }, {\n      item: i.item,\n      prefix: i.prefix,\n      filterFiles,\n    })\n  }\n\n  // await to read all content from included files\n  const allRefs = [...refs.values()]\n  const contents = await Promise.all(allRefs.map(async ref => ref.content))\n\n  contents.forEach((content, index) => {\n    allRefs[index].content = content\n  })\n\n  return {\n    files,\n    refs,\n  }\n}\n\nmodule.exports = readTarballs\n"]},"metadata":{},"sourceType":"script"}