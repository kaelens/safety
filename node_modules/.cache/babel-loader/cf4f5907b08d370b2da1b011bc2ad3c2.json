{"ast":null,"code":"// Each command has a completion function that takes an options object and a cb\n// The callback gets called with an error and an array of possible completions.\n// The options object is built up based on the environment variables set by\n// zsh or bash when calling a function for completion, based on the cursor\n// position and the command line thus far.  These are:\n// COMP_CWORD: the index of the \"word\" in the command line being completed\n// COMP_LINE: the full command line thusfar as a string\n// COMP_POINT: the cursor index at the point of triggering completion\n//\n// We parse the command line with nopt, like npm does, and then create an\n// options object containing:\n// words: array of words in the command line\n// w: the index of the word being completed (ie, COMP_CWORD)\n// word: the word being completed\n// line: the COMP_LINE\n// lineLength\n// point: the COMP_POINT, usually equal to line length, but not always, eg if\n// the user has pressed the left-arrow to complete an earlier word\n// partialLine: the line up to the point\n// partialWord: the word being completed (which might be ''), up to the point\n// conf: a nopt parse of the command line\n//\n// When the implementation completion method returns its list of strings,\n// and arrays of strings, we filter that by any that start with the\n// partialWord, since only those can possibly be valid matches.\n//\n// Matches are wrapped with ' to escape them, if necessary, and then printed\n// one per line for the shell completion method to consume in IFS=$'\\n' mode\n// as an array.\n//\nconst {\n  definitions,\n  shorthands\n} = require('./utils/config/index.js');\n\nconst deref = require('./utils/deref-command.js');\n\nconst {\n  aliases,\n  cmdList,\n  plumbing\n} = require('./utils/cmd-list.js');\n\nconst aliasNames = Object.keys(aliases);\nconst fullList = cmdList.concat(aliasNames).filter(c => !plumbing.includes(c));\n\nconst nopt = require('nopt');\n\nconst configNames = Object.keys(definitions);\nconst shorthandNames = Object.keys(shorthands);\nconst allConfs = configNames.concat(shorthandNames);\n\nconst isWindowsShell = require('./utils/is-windows-shell.js');\n\nconst fileExists = require('./utils/file-exists.js');\n\nconst {\n  promisify\n} = require('util');\n\nconst BaseCommand = require('./base-command.js');\n\nclass Completion extends BaseCommand {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description() {\n    return 'Tab Completion for npm';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get name() {\n    return 'completion';\n  } // completion for the completion command\n\n\n  async completion(opts) {\n    if (opts.w > 2) return;\n\n    const {\n      resolve\n    } = require('path');\n\n    const [bashExists, zshExists] = await Promise.all([fileExists(resolve(process.env.HOME, '.bashrc')), fileExists(resolve(process.env.HOME, '.zshrc'))]);\n    const out = [];\n    if (zshExists) out.push(['>>', '~/.zshrc']);\n    if (bashExists) out.push(['>>', '~/.bashrc']);\n    return out;\n  }\n\n  exec(args, cb) {\n    this.compl(args).then(() => cb()).catch(cb);\n  }\n\n  async compl(args) {\n    if (isWindowsShell) {\n      const msg = 'npm completion supported only in MINGW / Git bash on Windows';\n      throw Object.assign(new Error(msg), {\n        code: 'ENOTSUP'\n      });\n    }\n\n    const {\n      COMP_CWORD,\n      COMP_LINE,\n      COMP_POINT\n    } = process.env; // if the COMP_* isn't in the env, then just dump the script.\n\n    if (COMP_CWORD === undefined || COMP_LINE === undefined || COMP_POINT === undefined) return dumpScript(); // ok we're actually looking at the envs and outputting the suggestions\n    // get the partial line and partial word,\n    // if the point isn't at the end.\n    // ie, tabbing at: npm foo b|ar\n\n    const w = +COMP_CWORD;\n    const words = args.map(unescape);\n    const word = words[w];\n    const line = COMP_LINE;\n    const point = +COMP_POINT;\n    const partialLine = line.substr(0, point);\n    const partialWords = words.slice(0, w); // figure out where in that last word the point is.\n\n    const partialWordRaw = args[w];\n    let i = partialWordRaw.length;\n\n    while (partialWordRaw.substr(0, i) !== partialLine.substr(-1 * i) && i > 0) i--;\n\n    const partialWord = unescape(partialWordRaw.substr(0, i));\n    partialWords.push(partialWord);\n    const opts = {\n      words,\n      w,\n      word,\n      line,\n      lineLength: line.length,\n      point,\n      partialLine,\n      partialWords,\n      partialWord,\n      raw: args\n    };\n\n    if (partialWords.slice(0, -1).indexOf('--') === -1) {\n      if (word.charAt(0) === '-') return this.wrap(opts, configCompl(opts));\n\n      if (words[w - 1] && words[w - 1].charAt(0) === '-' && !isFlag(words[w - 1])) {\n        // awaiting a value for a non-bool config.\n        // don't even try to do this for now\n        return this.wrap(opts, configValueCompl(opts));\n      }\n    } // try to find the npm command.\n    // it's the first thing after all the configs.\n    // take a little shortcut and use npm's arg parsing logic.\n    // don't have to worry about the last arg being implicitly\n    // boolean'ed, since the last block will catch that.\n\n\n    const types = Object.entries(definitions).reduce((types, [key, def]) => {\n      types[key] = def.type;\n      return types;\n    }, {});\n    const parsed = opts.conf = nopt(types, shorthands, partialWords.slice(0, -1), 0); // check if there's a command already.\n\n    const cmd = parsed.argv.remain[1];\n    if (!cmd) return this.wrap(opts, cmdCompl(opts));\n    Object.keys(parsed).forEach(k => this.npm.config.set(k, parsed[k])); // at this point, if words[1] is some kind of npm command,\n    // then complete on it.\n    // otherwise, do nothing\n\n    const impl = this.npm.commands[cmd];\n\n    if (impl && impl.completion) {\n      const comps = await impl.completion(opts);\n      return this.wrap(opts, comps);\n    }\n  } // The command should respond with an array.  Loop over that,\n  // wrapping quotes around any that have spaces, and writing\n  // them to stdout.\n  // If any of the items are arrays, then join them with a space.\n  // Ie, returning ['a', 'b c', ['d', 'e']] would allow it to expand\n  // to: 'a', 'b c', or 'd' 'e'\n\n\n  wrap(opts, compls) {\n    if (!Array.isArray(compls)) compls = compls ? [compls] : [];\n    compls = compls.map(c => Array.isArray(c) ? c.map(escape).join(' ') : escape(c));\n    if (opts.partialWord) compls = compls.filter(c => c.startsWith(opts.partialWord));\n    if (compls.length > 0) this.npm.output(compls.join('\\n'));\n  }\n\n}\n\nconst dumpScript = async () => {\n  const fs = require('fs');\n\n  const readFile = promisify(fs.readFile);\n\n  const {\n    resolve\n  } = require('path');\n\n  const p = resolve(__dirname, 'utils/completion.sh');\n  const d = (await readFile(p, 'utf8')).replace(/^#!.*?\\n/, '');\n  await new Promise((res, rej) => {\n    let done = false;\n    process.stdout.write(d, () => {\n      if (done) return;\n      done = true;\n      res();\n    });\n    process.stdout.on('error', er => {\n      if (done) return;\n      done = true; // Darwin is a pain sometimes.\n      //\n      // This is necessary because the \"source\" or \".\" program in\n      // bash on OS X closes its file argument before reading\n      // from it, meaning that you get exactly 1 write, which will\n      // work most of the time, and will always raise an EPIPE.\n      //\n      // Really, one should not be tossing away EPIPE errors, or any\n      // errors, so casually.  But, without this, `. <(npm completion)`\n      // can never ever work on OS X.\n\n      if (er.errno === 'EPIPE') res();else rej(er);\n    });\n  });\n};\n\nconst unescape = w => w.charAt(0) === '\\'' ? w.replace(/^'|'$/g, '') : w.replace(/\\\\ /g, ' ');\n\nconst escape = w => !/\\s+/.test(w) ? w : '\\'' + w + '\\''; // the current word has a dash.  Return the config names,\n// with the same number of dashes as the current word has.\n\n\nconst configCompl = opts => {\n  const word = opts.word;\n  const split = word.match(/^(-+)((?:no-)*)(.*)$/);\n  const dashes = split[1];\n  const no = split[2];\n  const flags = configNames.filter(isFlag);\n  return allConfs.map(c => dashes + c).concat(flags.map(f => dashes + (no || 'no-') + f));\n}; // expand with the valid values of various config values.\n// not yet implemented.\n\n\nconst configValueCompl = opts => []; // check if the thing is a flag or not.\n\n\nconst isFlag = word => {\n  // shorthands never take args.\n  const split = word.match(/^(-*)((?:no-)+)?(.*)$/);\n  const no = split[2];\n  const conf = split[3];\n  const {\n    type\n  } = definitions[conf];\n  return no || type === Boolean || Array.isArray(type) && type.includes(Boolean) || shorthands[conf];\n}; // complete against the npm commands\n// if they all resolve to the same thing, just return the thing it already is\n\n\nconst cmdCompl = opts => {\n  const matches = fullList.filter(c => c.startsWith(opts.partialWord));\n  if (!matches.length) return matches;\n  const derefs = new Set([...matches.map(c => deref(c))]);\n  if (derefs.size === 1) return [...derefs];\n  return fullList;\n};\n\nmodule.exports = Completion;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/lib/completion.js"],"names":["definitions","shorthands","require","deref","aliases","cmdList","plumbing","aliasNames","Object","keys","fullList","concat","filter","c","includes","nopt","configNames","shorthandNames","allConfs","isWindowsShell","fileExists","promisify","BaseCommand","Completion","description","name","completion","opts","w","resolve","bashExists","zshExists","Promise","all","process","env","HOME","out","push","exec","args","cb","compl","then","catch","msg","assign","Error","code","COMP_CWORD","COMP_LINE","COMP_POINT","undefined","dumpScript","words","map","unescape","word","line","point","partialLine","substr","partialWords","slice","partialWordRaw","i","length","partialWord","lineLength","raw","indexOf","charAt","wrap","configCompl","isFlag","configValueCompl","types","entries","reduce","key","def","type","parsed","conf","cmd","argv","remain","cmdCompl","forEach","k","npm","config","set","impl","commands","comps","compls","Array","isArray","escape","join","startsWith","output","fs","readFile","p","__dirname","d","replace","res","rej","done","stdout","write","on","er","errno","test","split","match","dashes","no","flags","f","Boolean","matches","derefs","Set","size","module","exports"],"mappings":"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","sourcesContent":["// Each command has a completion function that takes an options object and a cb\n// The callback gets called with an error and an array of possible completions.\n// The options object is built up based on the environment variables set by\n// zsh or bash when calling a function for completion, based on the cursor\n// position and the command line thus far.  These are:\n// COMP_CWORD: the index of the \"word\" in the command line being completed\n// COMP_LINE: the full command line thusfar as a string\n// COMP_POINT: the cursor index at the point of triggering completion\n//\n// We parse the command line with nopt, like npm does, and then create an\n// options object containing:\n// words: array of words in the command line\n// w: the index of the word being completed (ie, COMP_CWORD)\n// word: the word being completed\n// line: the COMP_LINE\n// lineLength\n// point: the COMP_POINT, usually equal to line length, but not always, eg if\n// the user has pressed the left-arrow to complete an earlier word\n// partialLine: the line up to the point\n// partialWord: the word being completed (which might be ''), up to the point\n// conf: a nopt parse of the command line\n//\n// When the implementation completion method returns its list of strings,\n// and arrays of strings, we filter that by any that start with the\n// partialWord, since only those can possibly be valid matches.\n//\n// Matches are wrapped with ' to escape them, if necessary, and then printed\n// one per line for the shell completion method to consume in IFS=$'\\n' mode\n// as an array.\n//\n\nconst { definitions, shorthands } = require('./utils/config/index.js')\nconst deref = require('./utils/deref-command.js')\nconst { aliases, cmdList, plumbing } = require('./utils/cmd-list.js')\nconst aliasNames = Object.keys(aliases)\nconst fullList = cmdList.concat(aliasNames).filter(c => !plumbing.includes(c))\nconst nopt = require('nopt')\nconst configNames = Object.keys(definitions)\nconst shorthandNames = Object.keys(shorthands)\nconst allConfs = configNames.concat(shorthandNames)\nconst isWindowsShell = require('./utils/is-windows-shell.js')\nconst fileExists = require('./utils/file-exists.js')\n\nconst { promisify } = require('util')\nconst BaseCommand = require('./base-command.js')\n\nclass Completion extends BaseCommand {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description () {\n    return 'Tab Completion for npm'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'completion'\n  }\n\n  // completion for the completion command\n  async completion (opts) {\n    if (opts.w > 2)\n      return\n\n    const { resolve } = require('path')\n    const [bashExists, zshExists] = await Promise.all([\n      fileExists(resolve(process.env.HOME, '.bashrc')),\n      fileExists(resolve(process.env.HOME, '.zshrc')),\n    ])\n    const out = []\n    if (zshExists)\n      out.push(['>>', '~/.zshrc'])\n\n    if (bashExists)\n      out.push(['>>', '~/.bashrc'])\n\n    return out\n  }\n\n  exec (args, cb) {\n    this.compl(args).then(() => cb()).catch(cb)\n  }\n\n  async compl (args) {\n    if (isWindowsShell) {\n      const msg = 'npm completion supported only in MINGW / Git bash on Windows'\n      throw Object.assign(new Error(msg), {\n        code: 'ENOTSUP',\n      })\n    }\n\n    const { COMP_CWORD, COMP_LINE, COMP_POINT } = process.env\n\n    // if the COMP_* isn't in the env, then just dump the script.\n    if (COMP_CWORD === undefined ||\n      COMP_LINE === undefined ||\n      COMP_POINT === undefined)\n      return dumpScript()\n\n    // ok we're actually looking at the envs and outputting the suggestions\n    // get the partial line and partial word,\n    // if the point isn't at the end.\n    // ie, tabbing at: npm foo b|ar\n    const w = +COMP_CWORD\n    const words = args.map(unescape)\n    const word = words[w]\n    const line = COMP_LINE\n    const point = +COMP_POINT\n    const partialLine = line.substr(0, point)\n    const partialWords = words.slice(0, w)\n\n    // figure out where in that last word the point is.\n    const partialWordRaw = args[w]\n    let i = partialWordRaw.length\n    while (partialWordRaw.substr(0, i) !== partialLine.substr(-1 * i) && i > 0)\n      i--\n\n    const partialWord = unescape(partialWordRaw.substr(0, i))\n    partialWords.push(partialWord)\n\n    const opts = {\n      words,\n      w,\n      word,\n      line,\n      lineLength: line.length,\n      point,\n      partialLine,\n      partialWords,\n      partialWord,\n      raw: args,\n    }\n\n    if (partialWords.slice(0, -1).indexOf('--') === -1) {\n      if (word.charAt(0) === '-')\n        return this.wrap(opts, configCompl(opts))\n\n      if (words[w - 1] &&\n        words[w - 1].charAt(0) === '-' &&\n        !isFlag(words[w - 1])) {\n        // awaiting a value for a non-bool config.\n        // don't even try to do this for now\n        return this.wrap(opts, configValueCompl(opts))\n      }\n    }\n\n    // try to find the npm command.\n    // it's the first thing after all the configs.\n    // take a little shortcut and use npm's arg parsing logic.\n    // don't have to worry about the last arg being implicitly\n    // boolean'ed, since the last block will catch that.\n    const types = Object.entries(definitions).reduce((types, [key, def]) => {\n      types[key] = def.type\n      return types\n    }, {})\n    const parsed = opts.conf =\n      nopt(types, shorthands, partialWords.slice(0, -1), 0)\n    // check if there's a command already.\n    const cmd = parsed.argv.remain[1]\n    if (!cmd)\n      return this.wrap(opts, cmdCompl(opts))\n\n    Object.keys(parsed).forEach(k => this.npm.config.set(k, parsed[k]))\n\n    // at this point, if words[1] is some kind of npm command,\n    // then complete on it.\n    // otherwise, do nothing\n    const impl = this.npm.commands[cmd]\n    if (impl && impl.completion) {\n      const comps = await impl.completion(opts)\n      return this.wrap(opts, comps)\n    }\n  }\n\n  // The command should respond with an array.  Loop over that,\n  // wrapping quotes around any that have spaces, and writing\n  // them to stdout.\n  // If any of the items are arrays, then join them with a space.\n  // Ie, returning ['a', 'b c', ['d', 'e']] would allow it to expand\n  // to: 'a', 'b c', or 'd' 'e'\n  wrap (opts, compls) {\n    if (!Array.isArray(compls))\n      compls = compls ? [compls] : []\n\n    compls = compls.map(c =>\n      Array.isArray(c) ? c.map(escape).join(' ') : escape(c))\n\n    if (opts.partialWord)\n      compls = compls.filter(c => c.startsWith(opts.partialWord))\n\n    if (compls.length > 0)\n      this.npm.output(compls.join('\\n'))\n  }\n}\n\nconst dumpScript = async () => {\n  const fs = require('fs')\n  const readFile = promisify(fs.readFile)\n  const { resolve } = require('path')\n  const p = resolve(__dirname, 'utils/completion.sh')\n\n  const d = (await readFile(p, 'utf8')).replace(/^#!.*?\\n/, '')\n  await new Promise((res, rej) => {\n    let done = false\n    process.stdout.write(d, () => {\n      if (done)\n        return\n\n      done = true\n      res()\n    })\n\n    process.stdout.on('error', er => {\n      if (done)\n        return\n\n      done = true\n\n      // Darwin is a pain sometimes.\n      //\n      // This is necessary because the \"source\" or \".\" program in\n      // bash on OS X closes its file argument before reading\n      // from it, meaning that you get exactly 1 write, which will\n      // work most of the time, and will always raise an EPIPE.\n      //\n      // Really, one should not be tossing away EPIPE errors, or any\n      // errors, so casually.  But, without this, `. <(npm completion)`\n      // can never ever work on OS X.\n      if (er.errno === 'EPIPE')\n        res()\n      else\n        rej(er)\n    })\n  })\n}\n\nconst unescape = w => w.charAt(0) === '\\'' ? w.replace(/^'|'$/g, '')\n  : w.replace(/\\\\ /g, ' ')\n\nconst escape = w => !/\\s+/.test(w) ? w\n  : '\\'' + w + '\\''\n\n// the current word has a dash.  Return the config names,\n// with the same number of dashes as the current word has.\nconst configCompl = opts => {\n  const word = opts.word\n  const split = word.match(/^(-+)((?:no-)*)(.*)$/)\n  const dashes = split[1]\n  const no = split[2]\n  const flags = configNames.filter(isFlag)\n  return allConfs.map(c => dashes + c)\n    .concat(flags.map(f => dashes + (no || 'no-') + f))\n}\n\n// expand with the valid values of various config values.\n// not yet implemented.\nconst configValueCompl = opts => []\n\n// check if the thing is a flag or not.\nconst isFlag = word => {\n  // shorthands never take args.\n  const split = word.match(/^(-*)((?:no-)+)?(.*)$/)\n  const no = split[2]\n  const conf = split[3]\n  const {type} = definitions[conf]\n  return no ||\n    type === Boolean ||\n    (Array.isArray(type) && type.includes(Boolean)) ||\n    shorthands[conf]\n}\n\n// complete against the npm commands\n// if they all resolve to the same thing, just return the thing it already is\nconst cmdCompl = opts => {\n  const matches = fullList.filter(c => c.startsWith(opts.partialWord))\n  if (!matches.length)\n    return matches\n\n  const derefs = new Set([...matches.map(c => deref(c))])\n  if (derefs.size === 1)\n    return [...derefs]\n\n  return fullList\n}\n\nmodule.exports = Completion\n"]},"metadata":{},"sourceType":"script"}