{"ast":null,"code":"// if the thing isn't there, skip it\n// if there's a non-symlink there already, eexist\n// if there's a symlink already, pointing somewhere else, eexist\n// if there's a symlink already, pointing into our pkg, remove it first\n// then create the symlink\nconst {\n  promisify\n} = require('util');\n\nconst {\n  resolve,\n  dirname\n} = require('path');\n\nconst mkdirp = require('mkdirp-infer-owner');\n\nconst fs = require('fs');\n\nconst symlink = promisify(fs.symlink);\nconst readlink = promisify(fs.readlink);\nconst lstat = promisify(fs.lstat);\n\nconst throwNonEnoent = er => {\n  if (er.code !== 'ENOENT') throw er;\n}; // even in --force mode, we never create a link over a link we've\n// already created.  you can have multiple packages in a tree trying\n// to contend for the same bin, or the same manpage listed multiple times,\n// which creates a race condition and nondeterminism.\n\n\nconst seen = new Set(); // disable glob in our rimraf calls\n\nconst rimraf = promisify(require('rimraf'));\n\nconst rm = path => rimraf(path, {\n  glob: false\n});\n\nconst SKIP = Symbol('skip - missing or already installed');\nconst CLOBBER = Symbol('clobber - ours or in forceful mode');\n\nconst linkGently = async ({\n  path,\n  to,\n  from,\n  absFrom,\n  force\n}) => {\n  if (seen.has(to)) return true;\n  seen.add(to); // if the script or manpage isn't there, just ignore it.\n  // this arguably *should* be an install error of some sort,\n  // or at least a warning, but npm has always behaved this\n  // way in the past, so it'd be a breaking change\n\n  return Promise.all([lstat(absFrom).catch(throwNonEnoent), lstat(to).catch(throwNonEnoent)]).then(([stFrom, stTo]) => {\n    // not present in package, skip it\n    if (!stFrom) return SKIP; // exists! maybe clobber if we can\n\n    if (stTo) {\n      if (!stTo.isSymbolicLink()) return force && rm(to).then(() => CLOBBER);\n      return readlink(to).then(target => {\n        if (target === from) return SKIP; // skip it, already set up like we want it.\n\n        target = resolve(dirname(to), target);\n        if (target.indexOf(path) === 0 || force) return rm(to).then(() => CLOBBER);\n      });\n    } else {\n      // doesn't exist, dir might not either\n      return mkdirp(dirname(to));\n    }\n  }).then(skipOrClobber => {\n    if (skipOrClobber === SKIP) return true;\n    return symlink(from, to, 'file').catch(er => {\n      if (skipOrClobber === CLOBBER || force) return rm(to).then(() => symlink(from, to, 'file'));\n      throw er;\n    }).then(() => true);\n  });\n};\n\nconst resetSeen = () => {\n  for (const p of seen) {\n    seen.delete(p);\n  }\n};\n\nmodule.exports = Object.assign(linkGently, {\n  resetSeen\n});","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/bin-links/lib/link-gently.js"],"names":["promisify","require","resolve","dirname","mkdirp","fs","symlink","readlink","lstat","throwNonEnoent","er","code","seen","Set","rimraf","rm","path","glob","SKIP","Symbol","CLOBBER","linkGently","to","from","absFrom","force","has","add","Promise","all","catch","then","stFrom","stTo","isSymbolicLink","target","indexOf","skipOrClobber","resetSeen","p","delete","module","exports","Object","assign"],"mappings":"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","sourcesContent":["// if the thing isn't there, skip it\n// if there's a non-symlink there already, eexist\n// if there's a symlink already, pointing somewhere else, eexist\n// if there's a symlink already, pointing into our pkg, remove it first\n// then create the symlink\n\nconst { promisify } = require('util')\nconst { resolve, dirname } = require('path')\nconst mkdirp = require('mkdirp-infer-owner')\nconst fs = require('fs')\nconst symlink = promisify(fs.symlink)\nconst readlink = promisify(fs.readlink)\nconst lstat = promisify(fs.lstat)\nconst throwNonEnoent = er => { if (er.code !== 'ENOENT') throw er }\n\n// even in --force mode, we never create a link over a link we've\n// already created.  you can have multiple packages in a tree trying\n// to contend for the same bin, or the same manpage listed multiple times,\n// which creates a race condition and nondeterminism.\nconst seen = new Set()\n\n// disable glob in our rimraf calls\nconst rimraf = promisify(require('rimraf'))\nconst rm = path => rimraf(path, { glob: false })\n\nconst SKIP = Symbol('skip - missing or already installed')\nconst CLOBBER  = Symbol('clobber - ours or in forceful mode')\n\nconst linkGently = async ({path, to, from, absFrom, force}) => {\n  if (seen.has(to))\n    return true\n  seen.add(to)\n\n  // if the script or manpage isn't there, just ignore it.\n  // this arguably *should* be an install error of some sort,\n  // or at least a warning, but npm has always behaved this\n  // way in the past, so it'd be a breaking change\n  return Promise.all([\n    lstat(absFrom).catch(throwNonEnoent),\n    lstat(to).catch(throwNonEnoent),\n  ]).then(([stFrom, stTo]) => {\n    // not present in package, skip it\n    if (!stFrom)\n      return SKIP\n\n    // exists! maybe clobber if we can\n    if (stTo) {\n      if (!stTo.isSymbolicLink())\n        return force && rm(to).then(() => CLOBBER)\n\n      return readlink(to).then(target => {\n        if (target === from)\n          return SKIP // skip it, already set up like we want it.\n\n        target = resolve(dirname(to), target)\n        if (target.indexOf(path) === 0 || force)\n          return rm(to).then(() => CLOBBER)\n      })\n    } else {\n      // doesn't exist, dir might not either\n      return mkdirp(dirname(to))\n    }\n  })\n  .then(skipOrClobber => {\n    if (skipOrClobber === SKIP)\n      return true\n    return symlink(from, to, 'file').catch(er => {\n      if (skipOrClobber === CLOBBER || force)\n        return rm(to).then(() => symlink(from, to, 'file'))\n      throw er\n    }).then(() => true)\n  })\n}\n\nconst resetSeen = () => {\n  for (const p of seen) {\n    seen.delete(p)\n  }\n}\n\nmodule.exports = Object.assign(linkGently, { resetSeen })\n"]},"metadata":{},"sourceType":"script"}