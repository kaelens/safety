{"ast":null,"code":"// check to see if a bin is allowed to be overwritten\n// either rejects or resolves to nothing.  return value not relevant.\nconst isWindows = require('./is-windows.js');\n\nconst binTarget = require('./bin-target.js');\n\nconst {\n  resolve,\n  dirname\n} = require('path');\n\nconst readCmdShim = require('read-cmd-shim');\n\nconst fs = require('fs');\n\nconst {\n  promisify\n} = require('util');\n\nconst readlink = promisify(fs.readlink);\n\nconst checkBin = async ({\n  bin,\n  path,\n  top,\n  global,\n  force\n}) => {\n  // always ok to clobber when forced\n  // always ok to clobber local bins, or when forced\n  if (force || !global || !top) return; // ok, need to make sure, then\n\n  const target = resolve(binTarget({\n    path,\n    top\n  }), bin);\n  path = resolve(path);\n  return isWindows ? checkShim({\n    target,\n    path\n  }) : checkLink({\n    target,\n    path\n  });\n}; // only enoent is allowed.  anything else is a problem.\n\n\nconst handleReadLinkError = async ({\n  er,\n  target\n}) => er.code === 'ENOENT' ? null : failEEXIST({\n  target\n});\n\nconst checkLink = async ({\n  target,\n  path\n}) => {\n  const current = await readlink(target).catch(er => handleReadLinkError({\n    er,\n    target\n  }));\n  if (!current) return;\n  const resolved = resolve(dirname(target), current);\n  if (resolved.toLowerCase().indexOf(path.toLowerCase()) !== 0) return failEEXIST({\n    target\n  });\n};\n\nconst handleReadCmdShimError = ({\n  er,\n  target\n}) => er.code === 'ENOENT' ? null : failEEXIST({\n  target\n});\n\nconst failEEXIST = ({\n  target\n}) => Promise.reject(Object.assign(new Error('EEXIST: file already exists'), {\n  path: target,\n  code: 'EEXIST'\n}));\n\nconst checkShim = async ({\n  target,\n  path\n}) => {\n  const shims = [target, target + '.cmd', target + '.ps1'];\n  await Promise.all(shims.map(async target => {\n    const current = await readCmdShim(target).catch(er => handleReadCmdShimError({\n      er,\n      target\n    }));\n    if (!current) return;\n    const resolved = resolve(dirname(target), current.replace(/\\\\/g, '/'));\n    if (resolved.toLowerCase().indexOf(path.toLowerCase()) !== 0) return failEEXIST({\n      target\n    });\n  }));\n};\n\nmodule.exports = checkBin;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/bin-links/lib/check-bin.js"],"names":["isWindows","require","binTarget","resolve","dirname","readCmdShim","fs","promisify","readlink","checkBin","bin","path","top","global","force","target","checkShim","checkLink","handleReadLinkError","er","code","failEEXIST","current","catch","resolved","toLowerCase","indexOf","handleReadCmdShimError","Promise","reject","Object","assign","Error","shims","all","map","replace","module","exports"],"mappings":"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","sourcesContent":["// check to see if a bin is allowed to be overwritten\n// either rejects or resolves to nothing.  return value not relevant.\nconst isWindows = require('./is-windows.js')\nconst binTarget = require('./bin-target.js')\nconst {resolve, dirname} = require('path')\nconst readCmdShim = require('read-cmd-shim')\nconst fs = require('fs')\nconst {promisify} = require('util')\nconst readlink = promisify(fs.readlink)\n\nconst checkBin = async ({bin, path, top, global, force}) => {\n  // always ok to clobber when forced\n  // always ok to clobber local bins, or when forced\n  if (force || !global || !top)\n    return\n\n  // ok, need to make sure, then\n  const target = resolve(binTarget({path, top}), bin)\n  path = resolve(path)\n  return isWindows ? checkShim({target, path}) : checkLink({target, path})\n}\n\n// only enoent is allowed.  anything else is a problem.\nconst handleReadLinkError = async ({er, target}) =>\n  er.code === 'ENOENT' ? null\n  : failEEXIST({target})\n\nconst checkLink = async ({target, path}) => {\n  const current = await readlink(target)\n    .catch(er => handleReadLinkError({er, target}))\n\n  if (!current)\n    return\n\n  const resolved = resolve(dirname(target), current)\n\n  if (resolved.toLowerCase().indexOf(path.toLowerCase()) !== 0)\n    return failEEXIST({target})\n}\n\nconst handleReadCmdShimError = ({er, target}) =>\n  er.code === 'ENOENT' ? null\n  : failEEXIST({target})\n\nconst failEEXIST = ({target}) =>\n  Promise.reject(Object.assign(new Error('EEXIST: file already exists'), {\n    path: target,\n    code: 'EEXIST',\n  }))\n\nconst checkShim = async ({target, path}) => {\n  const shims = [\n    target,\n    target + '.cmd',\n    target + '.ps1',\n  ]\n  await Promise.all(shims.map(async target => {\n    const current = await readCmdShim(target)\n      .catch(er => handleReadCmdShimError({er, target}))\n\n    if (!current)\n      return\n\n    const resolved = resolve(dirname(target), current.replace(/\\\\/g, '/'))\n\n    if (resolved.toLowerCase().indexOf(path.toLowerCase()) !== 0)\n      return failEEXIST({target})\n  }))\n}\n\nmodule.exports = checkBin\n"]},"metadata":{},"sourceType":"script"}