{"ast":null,"code":"const objectAssign = require('object-assign');\n\nconst stringWidth = require('string-width');\n\nfunction codeRegex(capture) {\n  return capture ? /\\u001b\\[((?:\\d*;){0,5}\\d*)m/g : /\\u001b\\[(?:\\d*;){0,5}\\d*m/g;\n}\n\nfunction strlen(str) {\n  let code = codeRegex();\n  let stripped = ('' + str).replace(code, '');\n  let split = stripped.split('\\n');\n  return split.reduce(function (memo, s) {\n    return stringWidth(s) > memo ? stringWidth(s) : memo;\n  }, 0);\n}\n\nfunction repeat(str, times) {\n  return Array(times + 1).join(str);\n}\n\nfunction pad(str, len, pad, dir) {\n  let length = strlen(str);\n\n  if (len + 1 >= length) {\n    let padlen = len - length;\n\n    switch (dir) {\n      case 'right':\n        {\n          str = repeat(pad, padlen) + str;\n          break;\n        }\n\n      case 'center':\n        {\n          let right = Math.ceil(padlen / 2);\n          let left = padlen - right;\n          str = repeat(pad, left) + str + repeat(pad, right);\n          break;\n        }\n\n      default:\n        {\n          str = str + repeat(pad, padlen);\n          break;\n        }\n    }\n  }\n\n  return str;\n}\n\nlet codeCache = {};\n\nfunction addToCodeCache(name, on, off) {\n  on = '\\u001b[' + on + 'm';\n  off = '\\u001b[' + off + 'm';\n  codeCache[on] = {\n    set: name,\n    to: true\n  };\n  codeCache[off] = {\n    set: name,\n    to: false\n  };\n  codeCache[name] = {\n    on: on,\n    off: off\n  };\n} //https://github.com/Marak/colors.js/blob/master/lib/styles.js\n\n\naddToCodeCache('bold', 1, 22);\naddToCodeCache('italics', 3, 23);\naddToCodeCache('underline', 4, 24);\naddToCodeCache('inverse', 7, 27);\naddToCodeCache('strikethrough', 9, 29);\n\nfunction updateState(state, controlChars) {\n  let controlCode = controlChars[1] ? parseInt(controlChars[1].split(';')[0]) : 0;\n\n  if (controlCode >= 30 && controlCode <= 39 || controlCode >= 90 && controlCode <= 97) {\n    state.lastForegroundAdded = controlChars[0];\n    return;\n  }\n\n  if (controlCode >= 40 && controlCode <= 49 || controlCode >= 100 && controlCode <= 107) {\n    state.lastBackgroundAdded = controlChars[0];\n    return;\n  }\n\n  if (controlCode === 0) {\n    for (let i in state) {\n      /* istanbul ignore else */\n      if (Object.prototype.hasOwnProperty.call(state, i)) {\n        delete state[i];\n      }\n    }\n\n    return;\n  }\n\n  let info = codeCache[controlChars[0]];\n\n  if (info) {\n    state[info.set] = info.to;\n  }\n}\n\nfunction readState(line) {\n  let code = codeRegex(true);\n  let controlChars = code.exec(line);\n  let state = {};\n\n  while (controlChars !== null) {\n    updateState(state, controlChars);\n    controlChars = code.exec(line);\n  }\n\n  return state;\n}\n\nfunction unwindState(state, ret) {\n  let lastBackgroundAdded = state.lastBackgroundAdded;\n  let lastForegroundAdded = state.lastForegroundAdded;\n  delete state.lastBackgroundAdded;\n  delete state.lastForegroundAdded;\n  Object.keys(state).forEach(function (key) {\n    if (state[key]) {\n      ret += codeCache[key].off;\n    }\n  });\n\n  if (lastBackgroundAdded && lastBackgroundAdded != '\\u001b[49m') {\n    ret += '\\u001b[49m';\n  }\n\n  if (lastForegroundAdded && lastForegroundAdded != '\\u001b[39m') {\n    ret += '\\u001b[39m';\n  }\n\n  return ret;\n}\n\nfunction rewindState(state, ret) {\n  let lastBackgroundAdded = state.lastBackgroundAdded;\n  let lastForegroundAdded = state.lastForegroundAdded;\n  delete state.lastBackgroundAdded;\n  delete state.lastForegroundAdded;\n  Object.keys(state).forEach(function (key) {\n    if (state[key]) {\n      ret = codeCache[key].on + ret;\n    }\n  });\n\n  if (lastBackgroundAdded && lastBackgroundAdded != '\\u001b[49m') {\n    ret = lastBackgroundAdded + ret;\n  }\n\n  if (lastForegroundAdded && lastForegroundAdded != '\\u001b[39m') {\n    ret = lastForegroundAdded + ret;\n  }\n\n  return ret;\n}\n\nfunction truncateWidth(str, desiredLength) {\n  if (str.length === strlen(str)) {\n    return str.substr(0, desiredLength);\n  }\n\n  while (strlen(str) > desiredLength) {\n    str = str.slice(0, -1);\n  }\n\n  return str;\n}\n\nfunction truncateWidthWithAnsi(str, desiredLength) {\n  let code = codeRegex(true);\n  let split = str.split(codeRegex());\n  let splitIndex = 0;\n  let retLen = 0;\n  let ret = '';\n  let myArray;\n  let state = {};\n\n  while (retLen < desiredLength) {\n    myArray = code.exec(str);\n    let toAdd = split[splitIndex];\n    splitIndex++;\n\n    if (retLen + strlen(toAdd) > desiredLength) {\n      toAdd = truncateWidth(toAdd, desiredLength - retLen);\n    }\n\n    ret += toAdd;\n    retLen += strlen(toAdd);\n\n    if (retLen < desiredLength) {\n      if (!myArray) {\n        break;\n      } // full-width chars may cause a whitespace which cannot be filled\n\n\n      ret += myArray[0];\n      updateState(state, myArray);\n    }\n  }\n\n  return unwindState(state, ret);\n}\n\nfunction truncate(str, desiredLength, truncateChar) {\n  truncateChar = truncateChar || '…';\n  let lengthOfStr = strlen(str);\n\n  if (lengthOfStr <= desiredLength) {\n    return str;\n  }\n\n  desiredLength -= strlen(truncateChar);\n  let ret = truncateWidthWithAnsi(str, desiredLength);\n  return ret + truncateChar;\n}\n\nfunction defaultOptions() {\n  return {\n    chars: {\n      top: '─',\n      'top-mid': '┬',\n      'top-left': '┌',\n      'top-right': '┐',\n      bottom: '─',\n      'bottom-mid': '┴',\n      'bottom-left': '└',\n      'bottom-right': '┘',\n      left: '│',\n      'left-mid': '├',\n      mid: '─',\n      'mid-mid': '┼',\n      right: '│',\n      'right-mid': '┤',\n      middle: '│'\n    },\n    truncate: '…',\n    colWidths: [],\n    rowHeights: [],\n    colAligns: [],\n    rowAligns: [],\n    style: {\n      'padding-left': 1,\n      'padding-right': 1,\n      head: ['red'],\n      border: ['grey'],\n      compact: false\n    },\n    head: []\n  };\n}\n\nfunction mergeOptions(options, defaults) {\n  options = options || {};\n  defaults = defaults || defaultOptions();\n  let ret = objectAssign({}, defaults, options);\n  ret.chars = objectAssign({}, defaults.chars, options.chars);\n  ret.style = objectAssign({}, defaults.style, options.style);\n  return ret;\n}\n\nfunction wordWrap(maxLength, input) {\n  let lines = [];\n  let split = input.split(/(\\s+)/g);\n  let line = [];\n  let lineLength = 0;\n  let whitespace;\n\n  for (let i = 0; i < split.length; i += 2) {\n    let word = split[i];\n    let newLength = lineLength + strlen(word);\n\n    if (lineLength > 0 && whitespace) {\n      newLength += whitespace.length;\n    }\n\n    if (newLength > maxLength) {\n      if (lineLength !== 0) {\n        lines.push(line.join(''));\n      }\n\n      line = [word];\n      lineLength = strlen(word);\n    } else {\n      line.push(whitespace || '', word);\n      lineLength = newLength;\n    }\n\n    whitespace = split[i + 1];\n  }\n\n  if (lineLength) {\n    lines.push(line.join(''));\n  }\n\n  return lines;\n}\n\nfunction multiLineWordWrap(maxLength, input) {\n  let output = [];\n  input = input.split('\\n');\n\n  for (let i = 0; i < input.length; i++) {\n    output.push.apply(output, wordWrap(maxLength, input[i]));\n  }\n\n  return output;\n}\n\nfunction colorizeLines(input) {\n  let state = {};\n  let output = [];\n\n  for (let i = 0; i < input.length; i++) {\n    let line = rewindState(state, input[i]);\n    state = readState(line);\n    let temp = objectAssign({}, state);\n    output.push(unwindState(temp, line));\n  }\n\n  return output;\n}\n\nmodule.exports = {\n  strlen: strlen,\n  repeat: repeat,\n  pad: pad,\n  truncate: truncate,\n  mergeOptions: mergeOptions,\n  wordWrap: multiLineWordWrap,\n  colorizeLines: colorizeLines\n};","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/cli-table3/src/utils.js"],"names":["objectAssign","require","stringWidth","codeRegex","capture","strlen","str","code","stripped","replace","split","reduce","memo","s","repeat","times","Array","join","pad","len","dir","length","padlen","right","Math","ceil","left","codeCache","addToCodeCache","name","on","off","set","to","updateState","state","controlChars","controlCode","parseInt","lastForegroundAdded","lastBackgroundAdded","i","Object","prototype","hasOwnProperty","call","info","readState","line","exec","unwindState","ret","keys","forEach","key","rewindState","truncateWidth","desiredLength","substr","slice","truncateWidthWithAnsi","splitIndex","retLen","myArray","toAdd","truncate","truncateChar","lengthOfStr","defaultOptions","chars","top","bottom","mid","middle","colWidths","rowHeights","colAligns","rowAligns","style","head","border","compact","mergeOptions","options","defaults","wordWrap","maxLength","input","lines","lineLength","whitespace","word","newLength","push","multiLineWordWrap","output","apply","colorizeLines","temp","module","exports"],"mappings":"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","sourcesContent":["const objectAssign = require('object-assign');\nconst stringWidth = require('string-width');\n\nfunction codeRegex(capture) {\n  return capture ? /\\u001b\\[((?:\\d*;){0,5}\\d*)m/g : /\\u001b\\[(?:\\d*;){0,5}\\d*m/g;\n}\n\nfunction strlen(str) {\n  let code = codeRegex();\n  let stripped = ('' + str).replace(code, '');\n  let split = stripped.split('\\n');\n  return split.reduce(function (memo, s) {\n    return stringWidth(s) > memo ? stringWidth(s) : memo;\n  }, 0);\n}\n\nfunction repeat(str, times) {\n  return Array(times + 1).join(str);\n}\n\nfunction pad(str, len, pad, dir) {\n  let length = strlen(str);\n  if (len + 1 >= length) {\n    let padlen = len - length;\n    switch (dir) {\n      case 'right': {\n        str = repeat(pad, padlen) + str;\n        break;\n      }\n      case 'center': {\n        let right = Math.ceil(padlen / 2);\n        let left = padlen - right;\n        str = repeat(pad, left) + str + repeat(pad, right);\n        break;\n      }\n      default: {\n        str = str + repeat(pad, padlen);\n        break;\n      }\n    }\n  }\n  return str;\n}\n\nlet codeCache = {};\n\nfunction addToCodeCache(name, on, off) {\n  on = '\\u001b[' + on + 'm';\n  off = '\\u001b[' + off + 'm';\n  codeCache[on] = { set: name, to: true };\n  codeCache[off] = { set: name, to: false };\n  codeCache[name] = { on: on, off: off };\n}\n\n//https://github.com/Marak/colors.js/blob/master/lib/styles.js\naddToCodeCache('bold', 1, 22);\naddToCodeCache('italics', 3, 23);\naddToCodeCache('underline', 4, 24);\naddToCodeCache('inverse', 7, 27);\naddToCodeCache('strikethrough', 9, 29);\n\nfunction updateState(state, controlChars) {\n  let controlCode = controlChars[1] ? parseInt(controlChars[1].split(';')[0]) : 0;\n  if ((controlCode >= 30 && controlCode <= 39) || (controlCode >= 90 && controlCode <= 97)) {\n    state.lastForegroundAdded = controlChars[0];\n    return;\n  }\n  if ((controlCode >= 40 && controlCode <= 49) || (controlCode >= 100 && controlCode <= 107)) {\n    state.lastBackgroundAdded = controlChars[0];\n    return;\n  }\n  if (controlCode === 0) {\n    for (let i in state) {\n      /* istanbul ignore else */\n      if (Object.prototype.hasOwnProperty.call(state, i)) {\n        delete state[i];\n      }\n    }\n    return;\n  }\n  let info = codeCache[controlChars[0]];\n  if (info) {\n    state[info.set] = info.to;\n  }\n}\n\nfunction readState(line) {\n  let code = codeRegex(true);\n  let controlChars = code.exec(line);\n  let state = {};\n  while (controlChars !== null) {\n    updateState(state, controlChars);\n    controlChars = code.exec(line);\n  }\n  return state;\n}\n\nfunction unwindState(state, ret) {\n  let lastBackgroundAdded = state.lastBackgroundAdded;\n  let lastForegroundAdded = state.lastForegroundAdded;\n\n  delete state.lastBackgroundAdded;\n  delete state.lastForegroundAdded;\n\n  Object.keys(state).forEach(function (key) {\n    if (state[key]) {\n      ret += codeCache[key].off;\n    }\n  });\n\n  if (lastBackgroundAdded && lastBackgroundAdded != '\\u001b[49m') {\n    ret += '\\u001b[49m';\n  }\n  if (lastForegroundAdded && lastForegroundAdded != '\\u001b[39m') {\n    ret += '\\u001b[39m';\n  }\n\n  return ret;\n}\n\nfunction rewindState(state, ret) {\n  let lastBackgroundAdded = state.lastBackgroundAdded;\n  let lastForegroundAdded = state.lastForegroundAdded;\n\n  delete state.lastBackgroundAdded;\n  delete state.lastForegroundAdded;\n\n  Object.keys(state).forEach(function (key) {\n    if (state[key]) {\n      ret = codeCache[key].on + ret;\n    }\n  });\n\n  if (lastBackgroundAdded && lastBackgroundAdded != '\\u001b[49m') {\n    ret = lastBackgroundAdded + ret;\n  }\n  if (lastForegroundAdded && lastForegroundAdded != '\\u001b[39m') {\n    ret = lastForegroundAdded + ret;\n  }\n\n  return ret;\n}\n\nfunction truncateWidth(str, desiredLength) {\n  if (str.length === strlen(str)) {\n    return str.substr(0, desiredLength);\n  }\n\n  while (strlen(str) > desiredLength) {\n    str = str.slice(0, -1);\n  }\n\n  return str;\n}\n\nfunction truncateWidthWithAnsi(str, desiredLength) {\n  let code = codeRegex(true);\n  let split = str.split(codeRegex());\n  let splitIndex = 0;\n  let retLen = 0;\n  let ret = '';\n  let myArray;\n  let state = {};\n\n  while (retLen < desiredLength) {\n    myArray = code.exec(str);\n    let toAdd = split[splitIndex];\n    splitIndex++;\n    if (retLen + strlen(toAdd) > desiredLength) {\n      toAdd = truncateWidth(toAdd, desiredLength - retLen);\n    }\n    ret += toAdd;\n    retLen += strlen(toAdd);\n\n    if (retLen < desiredLength) {\n      if (!myArray) {\n        break;\n      } // full-width chars may cause a whitespace which cannot be filled\n      ret += myArray[0];\n      updateState(state, myArray);\n    }\n  }\n\n  return unwindState(state, ret);\n}\n\nfunction truncate(str, desiredLength, truncateChar) {\n  truncateChar = truncateChar || '…';\n  let lengthOfStr = strlen(str);\n  if (lengthOfStr <= desiredLength) {\n    return str;\n  }\n  desiredLength -= strlen(truncateChar);\n\n  let ret = truncateWidthWithAnsi(str, desiredLength);\n\n  return ret + truncateChar;\n}\n\nfunction defaultOptions() {\n  return {\n    chars: {\n      top: '─',\n      'top-mid': '┬',\n      'top-left': '┌',\n      'top-right': '┐',\n      bottom: '─',\n      'bottom-mid': '┴',\n      'bottom-left': '└',\n      'bottom-right': '┘',\n      left: '│',\n      'left-mid': '├',\n      mid: '─',\n      'mid-mid': '┼',\n      right: '│',\n      'right-mid': '┤',\n      middle: '│',\n    },\n    truncate: '…',\n    colWidths: [],\n    rowHeights: [],\n    colAligns: [],\n    rowAligns: [],\n    style: {\n      'padding-left': 1,\n      'padding-right': 1,\n      head: ['red'],\n      border: ['grey'],\n      compact: false,\n    },\n    head: [],\n  };\n}\n\nfunction mergeOptions(options, defaults) {\n  options = options || {};\n  defaults = defaults || defaultOptions();\n  let ret = objectAssign({}, defaults, options);\n  ret.chars = objectAssign({}, defaults.chars, options.chars);\n  ret.style = objectAssign({}, defaults.style, options.style);\n  return ret;\n}\n\nfunction wordWrap(maxLength, input) {\n  let lines = [];\n  let split = input.split(/(\\s+)/g);\n  let line = [];\n  let lineLength = 0;\n  let whitespace;\n  for (let i = 0; i < split.length; i += 2) {\n    let word = split[i];\n    let newLength = lineLength + strlen(word);\n    if (lineLength > 0 && whitespace) {\n      newLength += whitespace.length;\n    }\n    if (newLength > maxLength) {\n      if (lineLength !== 0) {\n        lines.push(line.join(''));\n      }\n      line = [word];\n      lineLength = strlen(word);\n    } else {\n      line.push(whitespace || '', word);\n      lineLength = newLength;\n    }\n    whitespace = split[i + 1];\n  }\n  if (lineLength) {\n    lines.push(line.join(''));\n  }\n  return lines;\n}\n\nfunction multiLineWordWrap(maxLength, input) {\n  let output = [];\n  input = input.split('\\n');\n  for (let i = 0; i < input.length; i++) {\n    output.push.apply(output, wordWrap(maxLength, input[i]));\n  }\n  return output;\n}\n\nfunction colorizeLines(input) {\n  let state = {};\n  let output = [];\n  for (let i = 0; i < input.length; i++) {\n    let line = rewindState(state, input[i]);\n    state = readState(line);\n    let temp = objectAssign({}, state);\n    output.push(unwindState(temp, line));\n  }\n  return output;\n}\n\nmodule.exports = {\n  strlen: strlen,\n  repeat: repeat,\n  pad: pad,\n  truncate: truncate,\n  mergeOptions: mergeOptions,\n  wordWrap: multiLineWordWrap,\n  colorizeLines: colorizeLines,\n};\n"]},"metadata":{},"sourceType":"script"}