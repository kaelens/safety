{"ast":null,"code":"'use strict';\n\nconst util = require('util');\n\nconst fs = require('fs');\n\nconst index = require('./lib/entry-index');\n\nconst memo = require('./lib/memoization');\n\nconst read = require('./lib/content/read');\n\nconst Minipass = require('minipass');\n\nconst Collect = require('minipass-collect');\n\nconst Pipeline = require('minipass-pipeline');\n\nconst writeFile = util.promisify(fs.writeFile);\n\nmodule.exports = function get(cache, key, opts) {\n  return getData(false, cache, key, opts);\n};\n\nmodule.exports.byDigest = function getByDigest(cache, digest, opts) {\n  return getData(true, cache, digest, opts);\n};\n\nfunction getData(byDigest, cache, key, opts = {}) {\n  const {\n    integrity,\n    memoize,\n    size\n  } = opts;\n  const memoized = byDigest ? memo.get.byDigest(cache, key, opts) : memo.get(cache, key, opts);\n\n  if (memoized && memoize !== false) {\n    return Promise.resolve(byDigest ? memoized : {\n      metadata: memoized.entry.metadata,\n      data: memoized.data,\n      integrity: memoized.entry.integrity,\n      size: memoized.entry.size\n    });\n  }\n\n  return (byDigest ? Promise.resolve(null) : index.find(cache, key, opts)).then(entry => {\n    if (!entry && !byDigest) {\n      throw new index.NotFoundError(cache, key);\n    }\n\n    return read(cache, byDigest ? key : entry.integrity, {\n      integrity,\n      size\n    }).then(data => byDigest ? data : {\n      data,\n      metadata: entry.metadata,\n      size: entry.size,\n      integrity: entry.integrity\n    }).then(res => {\n      if (memoize && byDigest) {\n        memo.put.byDigest(cache, key, res, opts);\n      } else if (memoize) {\n        memo.put(cache, entry, res.data, opts);\n      }\n\n      return res;\n    });\n  });\n}\n\nmodule.exports.sync = function get(cache, key, opts) {\n  return getDataSync(false, cache, key, opts);\n};\n\nmodule.exports.sync.byDigest = function getByDigest(cache, digest, opts) {\n  return getDataSync(true, cache, digest, opts);\n};\n\nfunction getDataSync(byDigest, cache, key, opts = {}) {\n  const {\n    integrity,\n    memoize,\n    size\n  } = opts;\n  const memoized = byDigest ? memo.get.byDigest(cache, key, opts) : memo.get(cache, key, opts);\n\n  if (memoized && memoize !== false) {\n    return byDigest ? memoized : {\n      metadata: memoized.entry.metadata,\n      data: memoized.data,\n      integrity: memoized.entry.integrity,\n      size: memoized.entry.size\n    };\n  }\n\n  const entry = !byDigest && index.find.sync(cache, key, opts);\n\n  if (!entry && !byDigest) {\n    throw new index.NotFoundError(cache, key);\n  }\n\n  const data = read.sync(cache, byDigest ? key : entry.integrity, {\n    integrity: integrity,\n    size: size\n  });\n  const res = byDigest ? data : {\n    metadata: entry.metadata,\n    data: data,\n    size: entry.size,\n    integrity: entry.integrity\n  };\n\n  if (memoize && byDigest) {\n    memo.put.byDigest(cache, key, res, opts);\n  } else if (memoize) {\n    memo.put(cache, entry, res.data, opts);\n  }\n\n  return res;\n}\n\nmodule.exports.stream = getStream;\n\nconst getMemoizedStream = memoized => {\n  const stream = new Minipass();\n  stream.on('newListener', function (ev, cb) {\n    ev === 'metadata' && cb(memoized.entry.metadata);\n    ev === 'integrity' && cb(memoized.entry.integrity);\n    ev === 'size' && cb(memoized.entry.size);\n  });\n  stream.end(memoized.data);\n  return stream;\n};\n\nfunction getStream(cache, key, opts = {}) {\n  const {\n    memoize,\n    size\n  } = opts;\n  const memoized = memo.get(cache, key, opts);\n\n  if (memoized && memoize !== false) {\n    return getMemoizedStream(memoized);\n  }\n\n  const stream = new Pipeline();\n  index.find(cache, key).then(entry => {\n    if (!entry) {\n      throw new index.NotFoundError(cache, key);\n    }\n\n    stream.emit('metadata', entry.metadata);\n    stream.emit('integrity', entry.integrity);\n    stream.emit('size', entry.size);\n    stream.on('newListener', function (ev, cb) {\n      ev === 'metadata' && cb(entry.metadata);\n      ev === 'integrity' && cb(entry.integrity);\n      ev === 'size' && cb(entry.size);\n    });\n    const src = read.readStream(cache, entry.integrity, { ...opts,\n      size: typeof size !== 'number' ? entry.size : size\n    });\n\n    if (memoize) {\n      const memoStream = new Collect.PassThrough();\n      memoStream.on('collect', data => memo.put(cache, entry, data, opts));\n      stream.unshift(memoStream);\n    }\n\n    stream.unshift(src);\n  }).catch(err => stream.emit('error', err));\n  return stream;\n}\n\nmodule.exports.stream.byDigest = getStreamDigest;\n\nfunction getStreamDigest(cache, integrity, opts = {}) {\n  const {\n    memoize\n  } = opts;\n  const memoized = memo.get.byDigest(cache, integrity, opts);\n\n  if (memoized && memoize !== false) {\n    const stream = new Minipass();\n    stream.end(memoized);\n    return stream;\n  } else {\n    const stream = read.readStream(cache, integrity, opts);\n\n    if (!memoize) {\n      return stream;\n    }\n\n    const memoStream = new Collect.PassThrough();\n    memoStream.on('collect', data => memo.put.byDigest(cache, integrity, data, opts));\n    return new Pipeline(stream, memoStream);\n  }\n}\n\nmodule.exports.info = info;\n\nfunction info(cache, key, opts = {}) {\n  const {\n    memoize\n  } = opts;\n  const memoized = memo.get(cache, key, opts);\n\n  if (memoized && memoize !== false) {\n    return Promise.resolve(memoized.entry);\n  } else {\n    return index.find(cache, key);\n  }\n}\n\nmodule.exports.hasContent = read.hasContent;\n\nfunction cp(cache, key, dest, opts) {\n  return copy(false, cache, key, dest, opts);\n}\n\nmodule.exports.copy = cp;\n\nfunction cpDigest(cache, digest, dest, opts) {\n  return copy(true, cache, digest, dest, opts);\n}\n\nmodule.exports.copy.byDigest = cpDigest;\n\nfunction copy(byDigest, cache, key, dest, opts = {}) {\n  if (read.copy) {\n    return (byDigest ? Promise.resolve(null) : index.find(cache, key, opts)).then(entry => {\n      if (!entry && !byDigest) {\n        throw new index.NotFoundError(cache, key);\n      }\n\n      return read.copy(cache, byDigest ? key : entry.integrity, dest, opts).then(() => {\n        return byDigest ? key : {\n          metadata: entry.metadata,\n          size: entry.size,\n          integrity: entry.integrity\n        };\n      });\n    });\n  }\n\n  return getData(byDigest, cache, key, opts).then(res => {\n    return writeFile(dest, byDigest ? res : res.data).then(() => {\n      return byDigest ? key : {\n        metadata: res.metadata,\n        size: res.size,\n        integrity: res.integrity\n      };\n    });\n  });\n}","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/cacache/get.js"],"names":["util","require","fs","index","memo","read","Minipass","Collect","Pipeline","writeFile","promisify","module","exports","get","cache","key","opts","getData","byDigest","getByDigest","digest","integrity","memoize","size","memoized","Promise","resolve","metadata","entry","data","find","then","NotFoundError","res","put","sync","getDataSync","stream","getStream","getMemoizedStream","on","ev","cb","end","emit","src","readStream","memoStream","PassThrough","unshift","catch","err","getStreamDigest","info","hasContent","cp","dest","copy","cpDigest"],"mappings":"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","sourcesContent":["'use strict'\n\nconst util = require('util')\nconst fs = require('fs')\nconst index = require('./lib/entry-index')\nconst memo = require('./lib/memoization')\nconst read = require('./lib/content/read')\n\nconst Minipass = require('minipass')\nconst Collect = require('minipass-collect')\nconst Pipeline = require('minipass-pipeline')\n\nconst writeFile = util.promisify(fs.writeFile)\n\nmodule.exports = function get (cache, key, opts) {\n  return getData(false, cache, key, opts)\n}\nmodule.exports.byDigest = function getByDigest (cache, digest, opts) {\n  return getData(true, cache, digest, opts)\n}\n\nfunction getData (byDigest, cache, key, opts = {}) {\n  const { integrity, memoize, size } = opts\n  const memoized = byDigest\n    ? memo.get.byDigest(cache, key, opts)\n    : memo.get(cache, key, opts)\n  if (memoized && memoize !== false) {\n    return Promise.resolve(\n      byDigest\n        ? memoized\n        : {\n          metadata: memoized.entry.metadata,\n          data: memoized.data,\n          integrity: memoized.entry.integrity,\n          size: memoized.entry.size\n        }\n    )\n  }\n  return (byDigest ? Promise.resolve(null) : index.find(cache, key, opts)).then(\n    (entry) => {\n      if (!entry && !byDigest) {\n        throw new index.NotFoundError(cache, key)\n      }\n      return read(cache, byDigest ? key : entry.integrity, {\n        integrity,\n        size\n      })\n        .then((data) =>\n          byDigest\n            ? data\n            : {\n              data,\n              metadata: entry.metadata,\n              size: entry.size,\n              integrity: entry.integrity\n            }\n        )\n        .then((res) => {\n          if (memoize && byDigest) {\n            memo.put.byDigest(cache, key, res, opts)\n          } else if (memoize) {\n            memo.put(cache, entry, res.data, opts)\n          }\n          return res\n        })\n    }\n  )\n}\n\nmodule.exports.sync = function get (cache, key, opts) {\n  return getDataSync(false, cache, key, opts)\n}\nmodule.exports.sync.byDigest = function getByDigest (cache, digest, opts) {\n  return getDataSync(true, cache, digest, opts)\n}\n\nfunction getDataSync (byDigest, cache, key, opts = {}) {\n  const { integrity, memoize, size } = opts\n  const memoized = byDigest\n    ? memo.get.byDigest(cache, key, opts)\n    : memo.get(cache, key, opts)\n  if (memoized && memoize !== false) {\n    return byDigest\n      ? memoized\n      : {\n        metadata: memoized.entry.metadata,\n        data: memoized.data,\n        integrity: memoized.entry.integrity,\n        size: memoized.entry.size\n      }\n  }\n  const entry = !byDigest && index.find.sync(cache, key, opts)\n  if (!entry && !byDigest) {\n    throw new index.NotFoundError(cache, key)\n  }\n  const data = read.sync(cache, byDigest ? key : entry.integrity, {\n    integrity: integrity,\n    size: size\n  })\n  const res = byDigest\n    ? data\n    : {\n      metadata: entry.metadata,\n      data: data,\n      size: entry.size,\n      integrity: entry.integrity\n    }\n  if (memoize && byDigest) {\n    memo.put.byDigest(cache, key, res, opts)\n  } else if (memoize) {\n    memo.put(cache, entry, res.data, opts)\n  }\n  return res\n}\n\nmodule.exports.stream = getStream\n\nconst getMemoizedStream = (memoized) => {\n  const stream = new Minipass()\n  stream.on('newListener', function (ev, cb) {\n    ev === 'metadata' && cb(memoized.entry.metadata)\n    ev === 'integrity' && cb(memoized.entry.integrity)\n    ev === 'size' && cb(memoized.entry.size)\n  })\n  stream.end(memoized.data)\n  return stream\n}\n\nfunction getStream (cache, key, opts = {}) {\n  const { memoize, size } = opts\n  const memoized = memo.get(cache, key, opts)\n  if (memoized && memoize !== false) {\n    return getMemoizedStream(memoized)\n  }\n\n  const stream = new Pipeline()\n  index\n    .find(cache, key)\n    .then((entry) => {\n      if (!entry) {\n        throw new index.NotFoundError(cache, key)\n      }\n      stream.emit('metadata', entry.metadata)\n      stream.emit('integrity', entry.integrity)\n      stream.emit('size', entry.size)\n      stream.on('newListener', function (ev, cb) {\n        ev === 'metadata' && cb(entry.metadata)\n        ev === 'integrity' && cb(entry.integrity)\n        ev === 'size' && cb(entry.size)\n      })\n\n      const src = read.readStream(\n        cache,\n        entry.integrity,\n        { ...opts, size: typeof size !== 'number' ? entry.size : size }\n      )\n\n      if (memoize) {\n        const memoStream = new Collect.PassThrough()\n        memoStream.on('collect', data => memo.put(cache, entry, data, opts))\n        stream.unshift(memoStream)\n      }\n      stream.unshift(src)\n    })\n    .catch((err) => stream.emit('error', err))\n\n  return stream\n}\n\nmodule.exports.stream.byDigest = getStreamDigest\n\nfunction getStreamDigest (cache, integrity, opts = {}) {\n  const { memoize } = opts\n  const memoized = memo.get.byDigest(cache, integrity, opts)\n  if (memoized && memoize !== false) {\n    const stream = new Minipass()\n    stream.end(memoized)\n    return stream\n  } else {\n    const stream = read.readStream(cache, integrity, opts)\n    if (!memoize) {\n      return stream\n    }\n    const memoStream = new Collect.PassThrough()\n    memoStream.on('collect', data => memo.put.byDigest(\n      cache,\n      integrity,\n      data,\n      opts\n    ))\n    return new Pipeline(stream, memoStream)\n  }\n}\n\nmodule.exports.info = info\n\nfunction info (cache, key, opts = {}) {\n  const { memoize } = opts\n  const memoized = memo.get(cache, key, opts)\n  if (memoized && memoize !== false) {\n    return Promise.resolve(memoized.entry)\n  } else {\n    return index.find(cache, key)\n  }\n}\n\nmodule.exports.hasContent = read.hasContent\n\nfunction cp (cache, key, dest, opts) {\n  return copy(false, cache, key, dest, opts)\n}\n\nmodule.exports.copy = cp\n\nfunction cpDigest (cache, digest, dest, opts) {\n  return copy(true, cache, digest, dest, opts)\n}\n\nmodule.exports.copy.byDigest = cpDigest\n\nfunction copy (byDigest, cache, key, dest, opts = {}) {\n  if (read.copy) {\n    return (byDigest\n      ? Promise.resolve(null)\n      : index.find(cache, key, opts)\n    ).then((entry) => {\n      if (!entry && !byDigest) {\n        throw new index.NotFoundError(cache, key)\n      }\n      return read\n        .copy(cache, byDigest ? key : entry.integrity, dest, opts)\n        .then(() => {\n          return byDigest\n            ? key\n            : {\n              metadata: entry.metadata,\n              size: entry.size,\n              integrity: entry.integrity\n            }\n        })\n    })\n  }\n\n  return getData(byDigest, cache, key, opts).then((res) => {\n    return writeFile(dest, byDigest ? res : res.data).then(() => {\n      return byDigest\n        ? key\n        : {\n          metadata: res.metadata,\n          size: res.size,\n          integrity: res.integrity\n        }\n    })\n  })\n}\n"]},"metadata":{},"sourceType":"script"}